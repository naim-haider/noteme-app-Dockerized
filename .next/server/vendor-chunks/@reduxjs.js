"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@reduxjs";
exports.ids = ["vendor-chunks/@reduxjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/cjs/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./redux-toolkit.development.cjs */ \"(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/redux-toolkit.development.cjs\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQywySkFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3RlbWUtYXBwLy4vbm9kZV9tb2R1bGVzL0ByZWR1eGpzL3Rvb2xraXQvZGlzdC9janMvaW5kZXguanM/NzU2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWR1eC10b29sa2l0LnByb2R1Y3Rpb24ubWluLmNqcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVkdXgtdG9vbGtpdC5kZXZlbG9wbWVudC5janMnKVxufSJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/redux-toolkit.development.cjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/cjs/redux-toolkit.development.cjs ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all)=>{\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __reExport = (target, mod, secondTarget)=>(__copyProps(target, mod, \"default\"), secondTarget && __copyProps(secondTarget, mod, \"default\"));\nvar __toCommonJS = (mod)=>__copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    ReducerType: ()=>ReducerType,\n    SHOULD_AUTOBATCH: ()=>SHOULD_AUTOBATCH,\n    TaskAbortError: ()=>TaskAbortError,\n    Tuple: ()=>Tuple,\n    addListener: ()=>addListener,\n    asyncThunkCreator: ()=>asyncThunkCreator,\n    autoBatchEnhancer: ()=>autoBatchEnhancer,\n    buildCreateSlice: ()=>buildCreateSlice,\n    clearAllListeners: ()=>clearAllListeners,\n    combineSlices: ()=>combineSlices,\n    configureStore: ()=>configureStore,\n    createAction: ()=>createAction,\n    createActionCreatorInvariantMiddleware: ()=>createActionCreatorInvariantMiddleware,\n    createAsyncThunk: ()=>createAsyncThunk,\n    createDraftSafeSelector: ()=>createDraftSafeSelector,\n    createDraftSafeSelectorCreator: ()=>createDraftSafeSelectorCreator,\n    createDynamicMiddleware: ()=>createDynamicMiddleware,\n    createEntityAdapter: ()=>createEntityAdapter,\n    createImmutableStateInvariantMiddleware: ()=>createImmutableStateInvariantMiddleware,\n    createListenerMiddleware: ()=>createListenerMiddleware,\n    createNextState: ()=>import_immer5.produce,\n    createReducer: ()=>createReducer,\n    createSelector: ()=>import_reselect2.createSelector,\n    createSelectorCreator: ()=>import_reselect2.createSelectorCreator,\n    createSerializableStateInvariantMiddleware: ()=>createSerializableStateInvariantMiddleware,\n    createSlice: ()=>createSlice,\n    current: ()=>import_immer5.current,\n    findNonSerializableValue: ()=>findNonSerializableValue,\n    formatProdErrorMessage: ()=>formatProdErrorMessage,\n    freeze: ()=>import_immer5.freeze,\n    isActionCreator: ()=>isActionCreator,\n    isAllOf: ()=>isAllOf,\n    isAnyOf: ()=>isAnyOf,\n    isAsyncThunkAction: ()=>isAsyncThunkAction,\n    isDraft: ()=>import_immer5.isDraft,\n    isFluxStandardAction: ()=>isFSA,\n    isFulfilled: ()=>isFulfilled,\n    isImmutableDefault: ()=>isImmutableDefault,\n    isPending: ()=>isPending,\n    isPlain: ()=>isPlain,\n    isRejected: ()=>isRejected,\n    isRejectedWithValue: ()=>isRejectedWithValue,\n    lruMemoize: ()=>import_reselect2.lruMemoize,\n    miniSerializeError: ()=>miniSerializeError,\n    nanoid: ()=>nanoid,\n    original: ()=>import_immer5.original,\n    prepareAutoBatched: ()=>prepareAutoBatched,\n    removeListener: ()=>removeListener,\n    unwrapResult: ()=>unwrapResult,\n    weakMapMemoize: ()=>import_reselect2.weakMapMemoize\n});\nmodule.exports = __toCommonJS(src_exports);\n__reExport(src_exports, __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\"), module.exports);\nvar import_immer5 = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\nvar import_reselect2 = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/cjs/reselect.cjs\");\n// src/createDraftSafeSelector.ts\nvar import_immer = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\nvar import_reselect = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/cjs/reselect.cjs\");\nvar createDraftSafeSelectorCreator = (...args)=>{\n    const createSelector2 = (0, import_reselect.createSelectorCreator)(...args);\n    return (...args2)=>{\n        const selector = createSelector2(...args2);\n        const wrappedSelector = (value, ...rest)=>selector((0, import_immer.isDraft)(value) ? (0, import_immer.current)(value) : value, ...rest);\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    };\n};\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(import_reselect.weakMapMemoize);\n// src/configureStore.ts\nvar import_redux4 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\n// src/devtoolsExtension.ts\nvar import_redux = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return import_redux.compose;\n    return import_redux.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\nvar import_redux_thunk = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/cjs/redux-thunk.cjs\");\n// src/createAction.ts\nvar import_redux2 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator(...args) {\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>`${type}`;\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0, import_redux2.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0, import_redux2.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? `${type}`.split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\nvar import_immer2 = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n            }\n        }\n    };\n}\nfunction find(iterable, comparator) {\n    for (const entry of iterable){\n        if (comparator(entry)) {\n            return entry;\n        }\n    }\n    return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat(...arr) {\n        return super.concat.apply(this, arr);\n    }\n    prepend(...arr) {\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n};\nfunction freezeDraftable(val) {\n    return (0, import_immer2.isDraftable)(val) ? (0, import_immer2.produce)(val, ()=>{}) : val;\n}\nfunction emplace(map, key, handler) {\n    if (map.has(key)) {\n        let value = map.get(key);\n        if (handler.update) {\n            value = handler.update(value, key, map);\n            map.set(key, value);\n        }\n        return value;\n    }\n    if (!handler.insert) throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n    const inserted = handler.insert(key, map);\n    map.set(key, inserted);\n    return inserted;\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(const key in obj){\n            const childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return ({ getState })=>{\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\nvar import_redux3 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0, import_redux3.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache?.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0, import_redux3.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options ?? {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(import_redux_thunk.thunk);\n            } else {\n                middlewareArray.push((0, import_redux_thunk.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = (options = {\n    type: \"raf\"\n})=>(next)=>(...args)=>{\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options ?? {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nvar IS_PRODUCTION = false;\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0, import_redux4.isPlainObject)(reducer)) {\n        rootReducer = (0, import_redux4.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    let finalCompose = import_redux4.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: !IS_PRODUCTION,\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0, import_redux4.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if (!IS_PRODUCTION && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0, import_redux4.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\nvar import_immer3 = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer(state = getInitialState(), action) {\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0, import_immer3.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0, import_immer3.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0, import_immer3.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf(...matchers) {\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf(...matchers) {\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.pending);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.rejected);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue(...asyncThunks) {\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return (action)=>{\n            const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = [];\n        for (const asyncThunk of asyncThunks){\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: error?.name === \"AbortError\",\n                    condition: error?.name === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg) {\n            return (dispatch, getState, extra)=>{\n                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        let conditionResult = options?.condition?.(arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>abortController.signal.addEventListener(\"abort\", ()=>reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                })));\n                        dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({ creators } = {}) {\n    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && true) {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer) {\n                context.sliceCaseReducersByName[name2] = reducer;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new WeakMap();\n        let _reducer;\n        const slice = {\n            name,\n            reducerPath,\n            reducer (state, action) {\n                if (!_reducer) _reducer = buildReducer();\n                return _reducer(state, action);\n            },\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState () {\n                if (!_reducer) _reducer = buildReducer();\n                return _reducer.getInitialState();\n            },\n            getSelectors (selectState = selectSelf) {\n                const selectorCache = emplace(injectedSelectorCache, this, {\n                    insert: ()=>/* @__PURE__ */ new WeakMap()\n                });\n                return emplace(selectorCache, selectState, {\n                    insert: ()=>{\n                        const map = {};\n                        for (const [name2, selector] of Object.entries(options.selectors ?? {})){\n                            map[name2] = wrapSelector(this, selector, selectState, this !== slice);\n                        }\n                        return map;\n                    }\n                });\n            },\n            selectSlice (state) {\n                let sliceState = state[this.reducerPath];\n                if (typeof sliceState === \"undefined\") {\n                    if (this !== slice) {\n                        sliceState = this.getInitialState();\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            },\n            get selectors () {\n                return this.getSelectors(this.selectSlice);\n            },\n            injectInto (injectable, { reducerPath: pathOpt, ...config } = {}) {\n                const reducerPath2 = pathOpt ?? this.reducerPath;\n                injectable.inject({\n                    reducerPath: reducerPath2,\n                    reducer: this.reducer\n                }, config);\n                return {\n                    ...this,\n                    reducerPath: reducerPath2\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(slice, selector, selectState, injected) {\n    function wrapper(rootState, ...args) {\n        let sliceState = selectState.call(slice, rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = slice.getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] (...args) {\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState = {}) {\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState, options = {}) {\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\nvar import_immer4 = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/cjs/index.js\");\nvar isDraftTyped = import_immer4.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0, import_immer4.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if (key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const added = [];\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const models = newEntities.filter((model)=>!(selectIdValue(model, selectId) in state.entities));\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach((model)=>{\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        const allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        const newSortedIds = allEntities.map(selectId);\n        const { ids } = state;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateFactory = createInitialStateFactory();\n    const selectorsFactory = createSelectorsFactory();\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/index.ts\nvar import_redux5 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new Error( false ? 0 : `${expected} is not a function`);\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = (promise, onError = noop2)=>{\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason)=>{\n    const signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = `${task} ${cancelled} (reason: ${code})`;\n    }\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        const { reason } = signal;\n        throw new TaskAbortError(reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp?.();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));\n        if (opts?.autoJoin) {\n            parentBlockingPromises.push(result);\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = (options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const id = nanoid();\n    const entry = {\n        id,\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap)=>{\n    return ()=>{\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(`${alm}/add`);\nvar clearAllListeners = createAction(`${alm}/removeAll`);\nvar removeListener = createAction(`${alm}/remove`);\nvar defaultErrorHandler = (...args)=>{\n    console.error(`${alm}/error`, ...args);\n};\nfunction createListenerMiddleware(middlewareOptions = {}) {\n    const listenerMap = /* @__PURE__ */ new Map();\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions?.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        let entry = find(Array.from(listenerMap.values()), (existingEntry)=>existingEntry.effect === options.effect);\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    const stopListening = (options)=>{\n        const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n        const entry = find(Array.from(listenerMap.values()), (entry2)=>{\n            const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            abortControllerWithReason(controller, listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    abortControllerWithReason(internalTaskController, listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.allSettled(autoJoinPromises);\n            abortControllerWithReason(internalTaskController, listenerCompleted);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0, import_redux5.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        let currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (let entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/dynamicMiddleware/index.ts\nvar import_redux6 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\nvar createMiddlewareEntry = (middleware)=>({\n        id: nanoid(),\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares)=>({\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        })), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n        middlewares.forEach((middleware2)=>{\n            let entry = find(Array.from(middlewareMap.values()), (entry2)=>entry2.middleware === middleware2);\n            if (!entry) {\n                entry = createMiddlewareEntry(middleware2);\n            }\n            middlewareMap.set(entry.id, entry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>emplace(entry.applied, api, {\n                insert: ()=>entry.middleware(api)\n            }));\n        return (0, import_redux6.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\nvar import_redux7 = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/cjs/redux.cjs\");\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap)=>emplace(stateProxyMap, state, {\n        insert: ()=>new Proxy(state, {\n                get: (target, prop, receiver)=>{\n                    if (prop === ORIGINAL_STATE) return target;\n                    const result = Reflect.get(target, prop, receiver);\n                    if (typeof result === \"undefined\") {\n                        const reducer = reducerMap[prop.toString()];\n                        if (reducer) {\n                            const reducerResult = reducer(void 0, {\n                                type: nanoid()\n                            });\n                            if (typeof reducerResult === \"undefined\") {\n                                throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n                            }\n                            return reducerResult;\n                        }\n                    }\n                    return result;\n                }\n            })\n    });\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nfunction combineSlices(...slices) {\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>(0, import_redux7.combineReducers)(reducerMap);\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const inject = (slice, config = {})=>{\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && true) {\n                console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n            }\n            return combinedReducer;\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state, ...args) {\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n} //# sourceMappingURL=redux-toolkit.development.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L2Nqcy9yZWR1eC10b29sa2l0LmRldmVsb3BtZW50LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CRixPQUFPRyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CSixPQUFPSyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZU4sT0FBT08sU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLFdBQVcsQ0FBQ0MsUUFBUUM7SUFDdEIsSUFBSyxJQUFJQyxRQUFRRCxJQUNmWixVQUFVVyxRQUFRRSxNQUFNO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsS0FBSztRQUFFRSxZQUFZO0lBQUs7QUFDL0Q7QUFDQSxJQUFJQyxjQUFjLENBQUNDLElBQUlDLE1BQU1DLFFBQVFDO0lBQ25DLElBQUlGLFFBQVEsT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWTtRQUNsRSxLQUFLLElBQUlHLE9BQU9oQixrQkFBa0JhLE1BQ2hDLElBQUksQ0FBQ1gsYUFBYWUsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q25CLFVBQVVpQixJQUFJSSxLQUFLO1lBQUVQLEtBQUssSUFBTUksSUFBSSxDQUFDRyxJQUFJO1lBQUVOLFlBQVksQ0FBRUssQ0FBQUEsT0FBT2pCLGlCQUFpQmUsTUFBTUcsSUFBRyxLQUFNRCxLQUFLTCxVQUFVO1FBQUM7SUFDdEg7SUFDQSxPQUFPRTtBQUNUO0FBQ0EsSUFBSU0sYUFBYSxDQUFDWixRQUFRYSxLQUFLQyxlQUFrQlQsQ0FBQUEsWUFBWUwsUUFBUWEsS0FBSyxZQUFZQyxnQkFBZ0JULFlBQVlTLGNBQWNELEtBQUssVUFBUztBQUM5SSxJQUFJRSxlQUFlLENBQUNGLE1BQVFSLFlBQVloQixVQUFVLENBQUMsR0FBRyxjQUFjO1FBQUUyQixPQUFPO0lBQUssSUFBSUg7QUFFdEYsZUFBZTtBQUNmLElBQUlJ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QUFPNkYsTUFBTSxDQUFDcWxCLGlCQUFpQjtRQUNwQ3RPO1FBQ0FsWDtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsU0FBUy9CLHVCQUF1QjBnQixJQUFJO0lBQ2xDLE9BQU8sQ0FBQyw4QkFBOEIsRUFBRUEsS0FBSyxpREFBaUQsRUFBRUEsS0FBSywrRUFBK0UsQ0FBQztBQUN2TCxFQUNBLHNEQUFzRCIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGVtZS1hcHAvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L2Nqcy9yZWR1eC10b29sa2l0LmRldmVsb3BtZW50LmNqcz84MzEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX19yZUV4cG9ydCA9ICh0YXJnZXQsIG1vZCwgc2Vjb25kVGFyZ2V0KSA9PiAoX19jb3B5UHJvcHModGFyZ2V0LCBtb2QsIFwiZGVmYXVsdFwiKSwgc2Vjb25kVGFyZ2V0ICYmIF9fY29weVByb3BzKHNlY29uZFRhcmdldCwgbW9kLCBcImRlZmF1bHRcIikpO1xudmFyIF9fdG9Db21tb25KUyA9IChtb2QpID0+IF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSksIG1vZCk7XG5cbi8vIHNyYy9pbmRleC50c1xudmFyIHNyY19leHBvcnRzID0ge307XG5fX2V4cG9ydChzcmNfZXhwb3J0cywge1xuICBSZWR1Y2VyVHlwZTogKCkgPT4gUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0g6ICgpID0+IFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yOiAoKSA9PiBUYXNrQWJvcnRFcnJvcixcbiAgVHVwbGU6ICgpID0+IFR1cGxlLFxuICBhZGRMaXN0ZW5lcjogKCkgPT4gYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yOiAoKSA9PiBhc3luY1RodW5rQ3JlYXRvcixcbiAgYXV0b0JhdGNoRW5oYW5jZXI6ICgpID0+IGF1dG9CYXRjaEVuaGFuY2VyLFxuICBidWlsZENyZWF0ZVNsaWNlOiAoKSA9PiBidWlsZENyZWF0ZVNsaWNlLFxuICBjbGVhckFsbExpc3RlbmVyczogKCkgPT4gY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXM6ICgpID0+IGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlOiAoKSA9PiBjb25maWd1cmVTdG9yZSxcbiAgY3JlYXRlQWN0aW9uOiAoKSA9PiBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlOiAoKSA9PiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlQXN5bmNUaHVuazogKCkgPT4gY3JlYXRlQXN5bmNUaHVuayxcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3I6ICgpID0+IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3I6ICgpID0+IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlRHluYW1pY01pZGRsZXdhcmU6ICgpID0+IGNyZWF0ZUR5bmFtaWNNaWRkbGV3YXJlLFxuICBjcmVhdGVFbnRpdHlBZGFwdGVyOiAoKSA9PiBjcmVhdGVFbnRpdHlBZGFwdGVyLFxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmU6ICgpID0+IGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlOiAoKSA9PiBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIGNyZWF0ZU5leHRTdGF0ZTogKCkgPT4gaW1wb3J0X2ltbWVyNS5wcm9kdWNlLFxuICBjcmVhdGVSZWR1Y2VyOiAoKSA9PiBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcjogKCkgPT4gaW1wb3J0X3Jlc2VsZWN0Mi5jcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yOiAoKSA9PiBpbXBvcnRfcmVzZWxlY3QyLmNyZWF0ZVNlbGVjdG9yQ3JlYXRvcixcbiAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlOiAoKSA9PiBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXG4gIGNyZWF0ZVNsaWNlOiAoKSA9PiBjcmVhdGVTbGljZSxcbiAgY3VycmVudDogKCkgPT4gaW1wb3J0X2ltbWVyNS5jdXJyZW50LFxuICBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWU6ICgpID0+IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcbiAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZTogKCkgPT4gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSxcbiAgZnJlZXplOiAoKSA9PiBpbXBvcnRfaW1tZXI1LmZyZWV6ZSxcbiAgaXNBY3Rpb25DcmVhdG9yOiAoKSA9PiBpc0FjdGlvbkNyZWF0b3IsXG4gIGlzQWxsT2Y6ICgpID0+IGlzQWxsT2YsXG4gIGlzQW55T2Y6ICgpID0+IGlzQW55T2YsXG4gIGlzQXN5bmNUaHVua0FjdGlvbjogKCkgPT4gaXNBc3luY1RodW5rQWN0aW9uLFxuICBpc0RyYWZ0OiAoKSA9PiBpbXBvcnRfaW1tZXI1LmlzRHJhZnQsXG4gIGlzRmx1eFN0YW5kYXJkQWN0aW9uOiAoKSA9PiBpc0ZTQSxcbiAgaXNGdWxmaWxsZWQ6ICgpID0+IGlzRnVsZmlsbGVkLFxuICBpc0ltbXV0YWJsZURlZmF1bHQ6ICgpID0+IGlzSW1tdXRhYmxlRGVmYXVsdCxcbiAgaXNQZW5kaW5nOiAoKSA9PiBpc1BlbmRpbmcsXG4gIGlzUGxhaW46ICgpID0+IGlzUGxhaW4sXG4gIGlzUmVqZWN0ZWQ6ICgpID0+IGlzUmVqZWN0ZWQsXG4gIGlzUmVqZWN0ZWRXaXRoVmFsdWU6ICgpID0+IGlzUmVqZWN0ZWRXaXRoVmFsdWUsXG4gIGxydU1lbW9pemU6ICgpID0+IGltcG9ydF9yZXNlbGVjdDIubHJ1TWVtb2l6ZSxcbiAgbWluaVNlcmlhbGl6ZUVycm9yOiAoKSA9PiBtaW5pU2VyaWFsaXplRXJyb3IsXG4gIG5hbm9pZDogKCkgPT4gbmFub2lkLFxuICBvcmlnaW5hbDogKCkgPT4gaW1wb3J0X2ltbWVyNS5vcmlnaW5hbCxcbiAgcHJlcGFyZUF1dG9CYXRjaGVkOiAoKSA9PiBwcmVwYXJlQXV0b0JhdGNoZWQsXG4gIHJlbW92ZUxpc3RlbmVyOiAoKSA9PiByZW1vdmVMaXN0ZW5lcixcbiAgdW53cmFwUmVzdWx0OiAoKSA9PiB1bndyYXBSZXN1bHQsXG4gIHdlYWtNYXBNZW1vaXplOiAoKSA9PiBpbXBvcnRfcmVzZWxlY3QyLndlYWtNYXBNZW1vaXplXG59KTtcbm1vZHVsZS5leHBvcnRzID0gX190b0NvbW1vbkpTKHNyY19leHBvcnRzKTtcbl9fcmVFeHBvcnQoc3JjX2V4cG9ydHMsIHJlcXVpcmUoXCJyZWR1eFwiKSwgbW9kdWxlLmV4cG9ydHMpO1xudmFyIGltcG9ydF9pbW1lcjUgPSByZXF1aXJlKFwiaW1tZXJcIik7XG52YXIgaW1wb3J0X3Jlc2VsZWN0MiA9IHJlcXVpcmUoXCJyZXNlbGVjdFwiKTtcblxuLy8gc3JjL2NyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yLnRzXG52YXIgaW1wb3J0X2ltbWVyID0gcmVxdWlyZShcImltbWVyXCIpO1xudmFyIGltcG9ydF9yZXNlbGVjdCA9IHJlcXVpcmUoXCJyZXNlbGVjdFwiKTtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSAoMCwgaW1wb3J0X3Jlc2VsZWN0LmNyZWF0ZVNlbGVjdG9yQ3JlYXRvcikoLi4uYXJncyk7XG4gIHJldHVybiAoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3RvcigoMCwgaW1wb3J0X2ltbWVyLmlzRHJhZnQpKHZhbHVlKSA/ICgwLCBpbXBvcnRfaW1tZXIuY3VycmVudCkodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfTtcbn07XG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IoaW1wb3J0X3Jlc2VsZWN0LndlYWtNYXBNZW1vaXplKTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG52YXIgaW1wb3J0X3JlZHV4NCA9IHJlcXVpcmUoXCJyZWR1eFwiKTtcblxuLy8gc3JjL2RldnRvb2xzRXh0ZW5zaW9uLnRzXG52YXIgaW1wb3J0X3JlZHV4ID0gcmVxdWlyZShcInJlZHV4XCIpO1xudmFyIGNvbXBvc2VXaXRoRGV2VG9vbHMgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIDogZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBpbXBvcnRfcmVkdXguY29tcG9zZTtcbiAgcmV0dXJuIGltcG9ydF9yZWR1eC5jb21wb3NlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59O1xudmFyIGRldlRvb2xzRW5oYW5jZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gOiBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vb3AzKSB7XG4gICAgcmV0dXJuIG5vb3AzO1xuICB9O1xufTtcblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG52YXIgaW1wb3J0X3JlZHV4X3RodW5rID0gcmVxdWlyZShcInJlZHV4LXRodW5rXCIpO1xuXG4vLyBzcmMvY3JlYXRlQWN0aW9uLnRzXG52YXIgaW1wb3J0X3JlZHV4MiA9IHJlcXVpcmUoXCJyZWR1eFwiKTtcblxuLy8gc3JjL3RzSGVscGVycy50c1xudmFyIGhhc01hdGNoRnVuY3Rpb24gPSAodikgPT4ge1xuICByZXR1cm4gdiAmJiB0eXBlb2Ygdi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcbiAgICAgIGxldCBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24oLi4uYXJncyk7XG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHByZXBhcmVkLnBheWxvYWQsXG4gICAgICAgIC4uLlwibWV0YVwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICAgIH0sXG4gICAgICAgIC4uLlwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogYXJnc1swXVxuICAgIH07XG4gIH1cbiAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9ICgpID0+IGAke3R5cGV9YDtcbiAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb24pID0+ICgwLCBpbXBvcnRfcmVkdXgyLmlzQWN0aW9uKShhY3Rpb24pICYmIGFjdGlvbi50eXBlID09PSB0eXBlO1xuICByZXR1cm4gYWN0aW9uQ3JlYXRvcjtcbn1cbmZ1bmN0aW9uIGlzQWN0aW9uQ3JlYXRvcihhY3Rpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09IFwiZnVuY3Rpb25cIiAmJiBcInR5cGVcIiBpbiBhY3Rpb24gJiYgLy8gaGFzTWF0Y2hGdW5jdGlvbiBvbmx5IHdhbnRzIE1hdGNoZXJzIGJ1dCBJIGRvbid0IHNlZSB0aGUgcG9pbnQgaW4gcmV3cml0aW5nIGl0XG4gIGhhc01hdGNoRnVuY3Rpb24oYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzRlNBKGFjdGlvbikge1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWR1eDIuaXNBY3Rpb24pKGFjdGlvbikgJiYgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XG4gIHJldHVybiBbXCJ0eXBlXCIsIFwicGF5bG9hZFwiLCBcImVycm9yXCIsIFwibWV0YVwiXS5pbmRleE9mKGtleSkgPiAtMTtcbn1cblxuLy8gc3JjL2FjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBnZXRNZXNzYWdlKHR5cGUpIHtcbiAgY29uc3Qgc3BsaXRUeXBlID0gdHlwZSA/IGAke3R5cGV9YC5zcGxpdChcIi9cIikgOiBbXTtcbiAgY29uc3QgYWN0aW9uTmFtZSA9IHNwbGl0VHlwZVtzcGxpdFR5cGUubGVuZ3RoIC0gMV0gfHwgXCJhY3Rpb25DcmVhdG9yXCI7XG4gIHJldHVybiBgRGV0ZWN0ZWQgYW4gYWN0aW9uIGNyZWF0b3Igd2l0aCB0eXBlIFwiJHt0eXBlIHx8IFwidW5rbm93blwifVwiIGJlaW5nIGRpc3BhdGNoZWQuIFxuTWFrZSBzdXJlIHlvdSdyZSBjYWxsaW5nIHRoZSBhY3Rpb24gY3JlYXRvciBiZWZvcmUgZGlzcGF0Y2hpbmcsIGkuZS4gXFxgZGlzcGF0Y2goJHthY3Rpb25OYW1lfSgpKVxcYCBpbnN0ZWFkIG9mIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0pXFxgLiBUaGlzIGlzIG5lY2Vzc2FyeSBldmVuIGlmIHRoZSBhY3Rpb24gaGFzIG5vIHBheWxvYWQuYDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAoZmFsc2UpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfVxuICBjb25zdCB7XG4gICAgaXNBY3Rpb25DcmVhdG9yOiBpc0FjdGlvbkNyZWF0b3IyID0gaXNBY3Rpb25DcmVhdG9yXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNBY3Rpb25DcmVhdG9yMihhY3Rpb24pKSB7XG4gICAgICBjb25zb2xlLndhcm4oZ2V0TWVzc2FnZShhY3Rpb24udHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICB9O1xufVxuXG4vLyBzcmMvdXRpbHMudHNcbnZhciBpbXBvcnRfaW1tZXIyID0gcmVxdWlyZShcImltbWVyXCIpO1xuZnVuY3Rpb24gZ2V0VGltZU1lYXN1cmVVdGlscyhtYXhEZWxheSwgZm5OYW1lKSB7XG4gIGxldCBlbGFwc2VkID0gMDtcbiAgcmV0dXJuIHtcbiAgICBtZWFzdXJlVGltZShmbikge1xuICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnN0IGZpbmlzaGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZWxhcHNlZCArPSBmaW5pc2hlZCAtIHN0YXJ0ZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXJuSWZFeGNlZWRlZCgpIHtcbiAgICAgIGlmIChlbGFwc2VkID4gbWF4RGVsYXkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGAke2ZuTmFtZX0gdG9vayAke2VsYXBzZWR9bXMsIHdoaWNoIGlzIG1vcmUgdGhhbiB0aGUgd2FybmluZyB0aHJlc2hvbGQgb2YgJHttYXhEZWxheX1tcy4gXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXG5JdCBpcyBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcywgc28geW91IGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhhdC5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBmaW5kKGl0ZXJhYmxlLCBjb21wYXJhdG9yKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgaXRlcmFibGUpIHtcbiAgICBpZiAoY29tcGFyYXRvcihlbnRyeSkpIHtcbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbnZhciBUdXBsZSA9IGNsYXNzIF9UdXBsZSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoLi4uaXRlbXMpIHtcbiAgICBzdXBlciguLi5pdGVtcyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9UdXBsZS5wcm90b3R5cGUpO1xuICB9XG4gIHN0YXRpYyBnZXQgW1N5bWJvbC5zcGVjaWVzXSgpIHtcbiAgICByZXR1cm4gX1R1cGxlO1xuICB9XG4gIGNvbmNhdCguLi5hcnIpIHtcbiAgICByZXR1cm4gc3VwZXIuY29uY2F0LmFwcGx5KHRoaXMsIGFycik7XG4gIH1cbiAgcHJlcGVuZCguLi5hcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyclswXSkpIHtcbiAgICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyclswXS5jb25jYXQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IF9UdXBsZSguLi5hcnIuY29uY2F0KHRoaXMpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZyZWV6ZURyYWZ0YWJsZSh2YWwpIHtcbiAgcmV0dXJuICgwLCBpbXBvcnRfaW1tZXIyLmlzRHJhZnRhYmxlKSh2YWwpID8gKDAsIGltcG9ydF9pbW1lcjIucHJvZHVjZSkodmFsLCAoKSA9PiB7XG4gIH0pIDogdmFsO1xufVxuZnVuY3Rpb24gZW1wbGFjZShtYXAsIGtleSwgaGFuZGxlcikge1xuICBpZiAobWFwLmhhcyhrZXkpKSB7XG4gICAgbGV0IHZhbHVlID0gbWFwLmdldChrZXkpO1xuICAgIGlmIChoYW5kbGVyLnVwZGF0ZSkge1xuICAgICAgdmFsdWUgPSBoYW5kbGVyLnVwZGF0ZSh2YWx1ZSwga2V5LCBtYXApO1xuICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICghaGFuZGxlci5pbnNlcnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTApIDogXCJObyBpbnNlcnQgcHJvdmlkZWQgZm9yIGtleSBub3QgYWxyZWFkeSBpbiBtYXBcIik7XG4gIGNvbnN0IGluc2VydGVkID0gaGFuZGxlci5pbnNlcnQoa2V5LCBtYXApO1xuICBtYXAuc2V0KGtleSwgaW5zZXJ0ZWQpO1xuICByZXR1cm4gaW5zZXJ0ZWQ7XG59XG5cbi8vIHNyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGlzSW1tdXRhYmxlRGVmYXVsdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgT2JqZWN0LmlzRnJvemVuKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKSB7XG4gIGNvbnN0IHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKTtcbiAgcmV0dXJuIHtcbiAgICBkZXRlY3RNdXRhdGlvbnMoKSB7XG4gICAgICByZXR1cm4gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgdHJhY2tlZFByb3BlcnRpZXMsIG9iaik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocyA9IFtdLCBvYmosIHBhdGggPSBcIlwiLCBjaGVja2VkT2JqZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpIHtcbiAgY29uc3QgdHJhY2tlZCA9IHtcbiAgICB2YWx1ZTogb2JqXG4gIH07XG4gIGlmICghaXNJbW11dGFibGUob2JqKSAmJiAhY2hlY2tlZE9iamVjdHMuaGFzKG9iaikpIHtcbiAgICBjaGVja2VkT2JqZWN0cy5hZGQob2JqKTtcbiAgICB0cmFja2VkLmNoaWxkcmVuID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgICAgaWYgKGlnbm9yZVBhdGhzLmxlbmd0aCAmJiBpZ25vcmVQYXRocy5pbmRleE9mKGNoaWxkUGF0aCkgIT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqW2tleV0sIGNoaWxkUGF0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFja2VkO1xufVxuZnVuY3Rpb24gZGV0ZWN0TXV0YXRpb25zKGlzSW1tdXRhYmxlLCBpZ25vcmVkUGF0aHMgPSBbXSwgdHJhY2tlZFByb3BlcnR5LCBvYmosIHNhbWVQYXJlbnRSZWYgPSBmYWxzZSwgcGF0aCA9IFwiXCIpIHtcbiAgY29uc3QgcHJldk9iaiA9IHRyYWNrZWRQcm9wZXJ0eSA/IHRyYWNrZWRQcm9wZXJ0eS52YWx1ZSA6IHZvaWQgMDtcbiAgY29uc3Qgc2FtZVJlZiA9IHByZXZPYmogPT09IG9iajtcbiAgaWYgKHNhbWVQYXJlbnRSZWYgJiYgIXNhbWVSZWYgJiYgIU51bWJlci5pc05hTihvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IHRydWUsXG4gICAgICBwYXRoXG4gICAgfTtcbiAgfVxuICBpZiAoaXNJbW11dGFibGUocHJldk9iaikgfHwgaXNJbW11dGFibGUob2JqKSkge1xuICAgIHJldHVybiB7XG4gICAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29uc3Qga2V5c1RvRGV0ZWN0ID0ge307XG4gIGZvciAobGV0IGtleSBpbiB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW4pIHtcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWU7XG4gIH1cbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChsZXQga2V5IGluIGtleXNUb0RldGVjdCkge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocywgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sIG9ialtrZXldLCBzYW1lUmVmLCBuZXN0ZWRQYXRoKTtcbiAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2FzTXV0YXRlZDogZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKGZhbHNlKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpXG4gICAgICAgIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH4uXCIgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKFwiLlwiKSArIFwiXVwiO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gZGVjeWNsZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5MiwgZ2V0U2VyaWFsaXplID0gZ2V0U2VyaWFsaXplMjtcbiAgICBsZXQge1xuICAgICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXG4gICAgICBpZ25vcmVkUGF0aHMsXG4gICAgICB3YXJuQWZ0ZXIgPSAzMlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcbiAgICByZXR1cm4gKHtcbiAgICAgIGdldFN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHJldHVybiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9Jy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlZEFjdGlvbiA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDIwKSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBpbnNpZGUgYSBkaXNwYXRjaCwgaW4gdGhlIHBhdGg6ICR7cmVzdWx0LnBhdGggfHwgXCJcIn0uIFRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoZSBhY3Rpb24gJHtzdHJpbmdpZnkyKGFjdGlvbil9LiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvc3R5bGUtZ3VpZGUvc3R5bGUtZ3VpZGUjZG8tbm90LW11dGF0ZS1zdGF0ZSlgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKTtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoZWRBY3Rpb247XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3NlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xudmFyIGltcG9ydF9yZWR1eDMgPSByZXF1aXJlKFwicmVkdXhcIik7XG5mdW5jdGlvbiBpc1BsYWluKHZhbCkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbDtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbCkgfHwgKDAsIGltcG9ydF9yZWR1eDMuaXNQbGFpbk9iamVjdCkodmFsKTtcbn1cbmZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSh2YWx1ZSwgcGF0aCA9IFwiXCIsIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbiwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzID0gW10sIGNhY2hlKSB7XG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5UGF0aDogcGF0aCB8fCBcIjxyb290PlwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNhY2hlPy5oYXModmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMDtcbiAgZm9yIChjb25zdCBba2V5LCBuZXN0ZWRWYWx1ZV0gb2YgZW50cmllcykge1xuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoID8gcGF0aCArIFwiLlwiICsga2V5IDoga2V5O1xuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMpIHtcbiAgICAgIGNvbnN0IGhhc01hdGNoZXMgPSBpZ25vcmVkUGF0aHMuc29tZSgoaWdub3JlZCkgPT4ge1xuICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgIHJldHVybiBpZ25vcmVkLnRlc3QobmVzdGVkUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5lc3RlZFBhdGggPT09IGlnbm9yZWQ7XG4gICAgICB9KTtcbiAgICAgIGlmIChoYXNNYXRjaGVzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5UGF0aDogbmVzdGVkUGF0aCxcbiAgICAgICAgdmFsdWU6IG5lc3RlZFZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5lc3RlZFZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShuZXN0ZWRWYWx1ZSwgbmVzdGVkUGF0aCwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XG4gICAgICAgIHJldHVybiBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNhY2hlICYmIGlzTmVzdGVkRnJvemVuKHZhbHVlKSlcbiAgICBjYWNoZS5hZGQodmFsdWUpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05lc3RlZEZyb3plbih2YWx1ZSkge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbih2YWx1ZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IG5lc3RlZFZhbHVlIG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCBuZXN0ZWRWYWx1ZSA9PT0gbnVsbClcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmICghaXNOZXN0ZWRGcm96ZW4obmVzdGVkVmFsdWUpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAoZmFsc2UpIHtcbiAgICByZXR1cm4gKCkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IG5leHQoYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sXG4gICAgICBnZXRFbnRyaWVzLFxuICAgICAgaWdub3JlZEFjdGlvbnMgPSBbXSxcbiAgICAgIGlnbm9yZWRBY3Rpb25QYXRocyA9IFtcIm1ldGEuYXJnXCIsIFwibWV0YS5iYXNlUXVlcnlNZXRhXCJdLFxuICAgICAgaWdub3JlZFBhdGhzID0gW10sXG4gICAgICB3YXJuQWZ0ZXIgPSAzMixcbiAgICAgIGlnbm9yZVN0YXRlID0gZmFsc2UsXG4gICAgICBpZ25vcmVBY3Rpb25zID0gZmFsc2UsXG4gICAgICBkaXNhYmxlQ2FjaGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNhY2hlID0gIWRpc2FibGVDYWNoZSAmJiBXZWFrU2V0ID8gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIChzdG9yZUFQSSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICAgIGlmICghKDAsIGltcG9ydF9yZWR1eDMuaXNBY3Rpb24pKGFjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGNvbnN0IG1lYXN1cmVVdGlscyA9IGdldFRpbWVNZWFzdXJlVXRpbHMod2FybkFmdGVyLCBcIlNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZVwiKTtcbiAgICAgIGlmICghaWdub3JlQWN0aW9ucyAmJiAhKGlnbm9yZWRBY3Rpb25zLmxlbmd0aCAmJiBpZ25vcmVkQWN0aW9ucy5pbmRleE9mKGFjdGlvbi50eXBlKSAhPT0gLTEpKSB7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShhY3Rpb24sIFwiXCIsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkQWN0aW9uUGF0aHMsIGNhY2hlKTtcbiAgICAgICAgICBpZiAoZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IFxcYCR7a2V5UGF0aH1cXGAuIFZhbHVlOmAsIHZhbHVlLCBcIlxcblRha2UgYSBsb29rIGF0IHRoZSBsb2dpYyB0aGF0IGRpc3BhdGNoZWQgdGhpcyBhY3Rpb246IFwiLCBhY3Rpb24sIFwiXFxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvYWN0aW9ucyN3aHktc2hvdWxkLXR5cGUtYmUtYS1zdHJpbmctb3ItYXQtbGVhc3Qtc2VyaWFsaXphYmxlLXdoeS1zaG91bGQtbXktYWN0aW9uLXR5cGVzLWJlLWNvbnN0YW50cylcIiwgXCJcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlnbm9yZVN0YXRlKSB7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZUFQSS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShzdGF0ZSwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0gPSBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWU7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIHRoZSBzdGF0ZSwgaW4gdGhlIHBhdGg6IFxcYCR7a2V5UGF0aH1cXGAuIFZhbHVlOmAsIHZhbHVlLCBgXG5UYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGlzIGFjdGlvbiB0eXBlOiAke2FjdGlvbi50eXBlfS5cbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL29yZ2FuaXppbmctc3RhdGUjY2FuLWktcHV0LWZ1bmN0aW9ucy1wcm9taXNlcy1vci1vdGhlci1ub24tc2VyaWFsaXphYmxlLWl0ZW1zLWluLW15LXN0b3JlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG59XG5cbi8vIHNyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNCb29sZWFuKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImJvb2xlYW5cIjtcbn1cbnZhciBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlID0gKCkgPT4gZnVuY3Rpb24gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgdGh1bmsgPSB0cnVlLFxuICAgIGltbXV0YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBzZXJpYWxpemFibGVDaGVjayA9IHRydWUsXG4gICAgYWN0aW9uQ3JlYXRvckNoZWNrID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IG1pZGRsZXdhcmVBcnJheSA9IG5ldyBUdXBsZSgpO1xuICBpZiAodGh1bmspIHtcbiAgICBpZiAoaXNCb29sZWFuKHRodW5rKSkge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goaW1wb3J0X3JlZHV4X3RodW5rLnRodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goKDAsIGltcG9ydF9yZWR1eF90aHVuay53aXRoRXh0cmFBcmd1bWVudCkodGh1bmsuZXh0cmFBcmd1bWVudCkpO1xuICAgIH1cbiAgfVxuICBpZiAodHJ1ZSkge1xuICAgIGlmIChpbW11dGFibGVDaGVjaykge1xuICAgICAgbGV0IGltbXV0YWJsZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2s7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcbiAgICAgIGxldCBzZXJpYWxpemFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcbiAgICAgICAgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHNlcmlhbGl6YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGFjdGlvbkNyZWF0b3JDaGVjaykge1xuICAgICAgbGV0IGFjdGlvbkNyZWF0b3JPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihhY3Rpb25DcmVhdG9yQ2hlY2spKSB7XG4gICAgICAgIGFjdGlvbkNyZWF0b3JPcHRpb25zID0gYWN0aW9uQ3JlYXRvckNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUoYWN0aW9uQ3JlYXRvck9wdGlvbnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pZGRsZXdhcmVBcnJheTtcbn07XG5cbi8vIHNyYy9hdXRvQmF0Y2hFbmhhbmNlci50c1xudmFyIFNIT1VMRF9BVVRPQkFUQ0ggPSBcIlJUS19hdXRvQmF0Y2hcIjtcbnZhciBwcmVwYXJlQXV0b0JhdGNoZWQgPSAoKSA9PiAocGF5bG9hZCkgPT4gKHtcbiAgcGF5bG9hZCxcbiAgbWV0YToge1xuICAgIFtTSE9VTERfQVVUT0JBVENIXTogdHJ1ZVxuICB9XG59KTtcbnZhciBjcmVhdGVRdWV1ZVdpdGhUaW1lciA9ICh0aW1lb3V0KSA9PiB7XG4gIHJldHVybiAobm90aWZ5KSA9PiB7XG4gICAgc2V0VGltZW91dChub3RpZnksIHRpbWVvdXQpO1xuICB9O1xufTtcbnZhciByQUYgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogY3JlYXRlUXVldWVXaXRoVGltZXIoMTApO1xudmFyIGF1dG9CYXRjaEVuaGFuY2VyID0gKG9wdGlvbnMgPSB7XG4gIHR5cGU6IFwicmFmXCJcbn0pID0+IChuZXh0KSA9PiAoLi4uYXJncykgPT4ge1xuICBjb25zdCBzdG9yZSA9IG5leHQoLi4uYXJncyk7XG4gIGxldCBub3RpZnlpbmcgPSB0cnVlO1xuICBsZXQgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgbGV0IG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gb3B0aW9ucy50eXBlID09PSBcInRpY2tcIiA/IHF1ZXVlTWljcm90YXNrIDogb3B0aW9ucy50eXBlID09PSBcInJhZlwiID8gckFGIDogb3B0aW9ucy50eXBlID09PSBcImNhbGxiYWNrXCIgPyBvcHRpb25zLnF1ZXVlTm90aWZpY2F0aW9uIDogY3JlYXRlUXVldWVXaXRoVGltZXIob3B0aW9ucy50aW1lb3V0KTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IGZhbHNlO1xuICAgIGlmIChzaG91bGROb3RpZnlBdEVuZE9mVGljaykge1xuICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChsKSA9PiBsKCkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0b3JlLCB7XG4gICAgLy8gT3ZlcnJpZGUgdGhlIGJhc2UgYHN0b3JlLnN1YnNjcmliZWAgbWV0aG9kIHRvIGtlZXAgb3JpZ2luYWwgbGlzdGVuZXJzXG4gICAgLy8gZnJvbSBydW5uaW5nIGlmIHdlJ3JlIGRlbGF5aW5nIG5vdGlmaWNhdGlvbnNcbiAgICBzdWJzY3JpYmUobGlzdGVuZXIyKSB7XG4gICAgICBjb25zdCB3cmFwcGVkTGlzdGVuZXIgPSAoKSA9PiBub3RpZnlpbmcgJiYgbGlzdGVuZXIyKCk7XG4gICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHN0b3JlLnN1YnNjcmliZSh3cmFwcGVkTGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcjIpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcjIpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5kaXNwYXRjaGAgbWV0aG9kIHNvIHRoYXQgd2UgY2FuIGNoZWNrIGFjdGlvbnNcbiAgICAvLyBmb3IgdGhlIGBzaG91bGRBdXRvQmF0Y2hgIGZsYWcgYW5kIGRldGVybWluZSBpZiBiYXRjaGluZyBpcyBhY3RpdmVcbiAgICBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vdGlmeWluZyA9ICFhY3Rpb24/Lm1ldGE/LltTSE9VTERfQVVUT0JBVENIXTtcbiAgICAgICAgc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2sgPSAhbm90aWZ5aW5nO1xuICAgICAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgICAgICBpZiAoIW5vdGlmaWNhdGlvblF1ZXVlZCkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHF1ZXVlQ2FsbGJhY2sobm90aWZ5TGlzdGVuZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBub3RpZnlpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdEVuaGFuY2Vycy50c1xudmFyIGJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyA9IChtaWRkbGV3YXJlRW5oYW5jZXIpID0+IGZ1bmN0aW9uIGdldERlZmF1bHRFbmhhbmNlcnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgYXV0b0JhdGNoID0gdHJ1ZVxuICB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IGVuaGFuY2VyQXJyYXkgPSBuZXcgVHVwbGUobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKGF1dG9CYXRjaCkge1xuICAgIGVuaGFuY2VyQXJyYXkucHVzaChhdXRvQmF0Y2hFbmhhbmNlcih0eXBlb2YgYXV0b0JhdGNoID09PSBcIm9iamVjdFwiID8gYXV0b0JhdGNoIDogdm9pZCAwKSk7XG4gIH1cbiAgcmV0dXJuIGVuaGFuY2VyQXJyYXk7XG59O1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbnZhciBJU19QUk9EVUNUSU9OID0gZmFsc2U7XG5mdW5jdGlvbiBjb25maWd1cmVTdG9yZShvcHRpb25zKSB7XG4gIGNvbnN0IGdldERlZmF1bHRNaWRkbGV3YXJlID0gYnVpbGRHZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICBjb25zdCB7XG4gICAgcmVkdWNlciA9IHZvaWQgMCxcbiAgICBtaWRkbGV3YXJlLFxuICAgIGRldlRvb2xzID0gdHJ1ZSxcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHZvaWQgMCxcbiAgICBlbmhhbmNlcnMgPSB2b2lkIDBcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIGxldCByb290UmVkdWNlcjtcbiAgaWYgKHR5cGVvZiByZWR1Y2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByb290UmVkdWNlciA9IHJlZHVjZXI7XG4gIH0gZWxzZSBpZiAoKDAsIGltcG9ydF9yZWR1eDQuaXNQbGFpbk9iamVjdCkocmVkdWNlcikpIHtcbiAgICByb290UmVkdWNlciA9ICgwLCBpbXBvcnRfcmVkdXg0LmNvbWJpbmVSZWR1Y2VycykocmVkdWNlcik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UoMSkgOiBcImByZWR1Y2VyYCBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2Vyc1wiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMygzKSA6IFwid2hlbiB1c2luZyBhIG1pZGRsZXdhcmUgYnVpbGRlciBmdW5jdGlvbiwgYW4gYXJyYXkgb2YgbWlkZGxld2FyZSBtdXN0IGJlIHJldHVybmVkXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmaW5hbE1pZGRsZXdhcmUgPSBnZXREZWZhdWx0TWlkZGxld2FyZSgpO1xuICB9XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTQoNCkgOiBcImVhY2ggbWlkZGxld2FyZSBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGltcG9ydF9yZWR1eDQuY29tcG9zZTtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyh7XG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xuICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OLFxuICAgICAgLi4udHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gKDAsIGltcG9ydF9yZWR1eDQuYXBwbHlNaWRkbGV3YXJlKSguLi5maW5hbE1pZGRsZXdhcmUpO1xuICBjb25zdCBnZXREZWZhdWx0RW5oYW5jZXJzID0gYnVpbGRHZXREZWZhdWx0RW5oYW5jZXJzKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBlbmhhbmNlcnMgJiYgdHlwZW9mIGVuaGFuY2VycyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1KDUpIDogXCJgZW5oYW5jZXJzYCBmaWVsZCBtdXN0IGJlIGEgY2FsbGJhY2tcIik7XG4gIH1cbiAgbGV0IHN0b3JlRW5oYW5jZXJzID0gdHlwZW9mIGVuaGFuY2VycyA9PT0gXCJmdW5jdGlvblwiID8gZW5oYW5jZXJzKGdldERlZmF1bHRFbmhhbmNlcnMpIDogZ2V0RGVmYXVsdEVuaGFuY2VycygpO1xuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgIUFycmF5LmlzQXJyYXkoc3RvcmVFbmhhbmNlcnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U2KDYpIDogXCJgZW5oYW5jZXJzYCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheVwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTcoNykgOiBcImVhY2ggZW5oYW5jZXIgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGlmICghSVNfUFJPRFVDVElPTiAmJiBmaW5hbE1pZGRsZXdhcmUubGVuZ3RoICYmICFzdG9yZUVuaGFuY2Vycy5pbmNsdWRlcyhtaWRkbGV3YXJlRW5oYW5jZXIpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIm1pZGRsZXdhcmVzIHdlcmUgcHJvdmlkZWQsIGJ1dCBtaWRkbGV3YXJlIGVuaGFuY2VyIHdhcyBub3QgaW5jbHVkZWQgaW4gZmluYWwgZW5oYW5jZXJzIC0gbWFrZSBzdXJlIHRvIGNhbGwgYGdldERlZmF1bHRFbmhhbmNlcnNgXCIpO1xuICB9XG4gIGNvbnN0IGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UoLi4uc3RvcmVFbmhhbmNlcnMpO1xuICByZXR1cm4gKDAsIGltcG9ydF9yZWR1eDQuY3JlYXRlU3RvcmUpKHJvb3RSZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgY29tcG9zZWRFbmhhbmNlcik7XG59XG5cbi8vIHNyYy9jcmVhdGVSZWR1Y2VyLnRzXG52YXIgaW1wb3J0X2ltbWVyMyA9IHJlcXVpcmUoXCJpbW1lclwiKTtcblxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcbiAgY29uc3QgYWN0aW9uc01hcCA9IHt9O1xuICBjb25zdCBhY3Rpb25NYXRjaGVycyA9IFtdO1xuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xuICBjb25zdCBidWlsZGVyID0ge1xuICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgaWYgKGFjdGlvbk1hdGNoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNikgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGRNYXRjaGVyYFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDI3KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZERlZmF1bHRDYXNlYFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMjgpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgyOSkgOiBgXFxgYnVpbGRlci5hZGRDYXNlXFxgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlICcke3R5cGV9J2ApO1xuICAgICAgfVxuICAgICAgYWN0aW9uc01hcFt0eXBlXSA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9LFxuICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcikge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNigzMSkgOiBcImBidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH1cbiAgfTtcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpO1xuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuZnVuY3Rpb24gaXNTdGF0ZUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBjcmVhdGVSZWR1Y2VyKGluaXRpYWxTdGF0ZSwgbWFwT3JCdWlsZGVyQ2FsbGJhY2spIHtcbiAgaWYgKHRydWUpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcbiAgbGV0IGdldEluaXRpYWxTdGF0ZTtcbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpLCBhY3Rpb24pIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgIH0pID0+IHJlZHVjZXIyKV07XG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoKGNyKSA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XG4gICAgfVxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmICgoMCwgaW1wb3J0X2ltbWVyMy5pc0RyYWZ0KShwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCEoMCwgaW1wb3J0X2ltbWVyMy5pc0RyYWZ0YWJsZSkocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoOSkgOiBcIkEgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoMCwgaW1wb3J0X2ltbWVyMy5wcm9kdWNlKShwcmV2aW91c1N0YXRlLCAoZHJhZnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgfSwgc3RhdGUpO1xuICB9XG4gIHJlZHVjZXIuZ2V0SW5pdGlhbFN0YXRlID0gZ2V0SW5pdGlhbFN0YXRlO1xuICByZXR1cm4gcmVkdWNlcjtcbn1cblxuLy8gc3JjL25hbm9pZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXXCI7XG52YXIgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSBcIlwiO1xuICBsZXQgaSA9IHNpemU7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG4vLyBzcmMvbWF0Y2hlcnMudHNcbnZhciBtYXRjaGVzID0gKG1hdGNoZXIsIGFjdGlvbikgPT4ge1xuICBpZiAoaGFzTWF0Y2hGdW5jdGlvbihtYXRjaGVyKSkge1xuICAgIHJldHVybiBtYXRjaGVyLm1hdGNoKGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1hdGNoZXIoYWN0aW9uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGlzQW55T2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcikgPT4gbWF0Y2hlcyhtYXRjaGVyLCBhY3Rpb24pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQWxsT2YoLi4ubWF0Y2hlcnMpIHtcbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gbWF0Y2hlcnMuZXZlcnkoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIHZhbGlkU3RhdHVzKSB7XG4gIGlmICghYWN0aW9uIHx8ICFhY3Rpb24ubWV0YSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdElkID0gdHlwZW9mIGFjdGlvbi5tZXRhLnJlcXVlc3RJZCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzID0gdmFsaWRTdGF0dXMuaW5kZXhPZihhY3Rpb24ubWV0YS5yZXF1ZXN0U3RhdHVzKSA+IC0xO1xuICByZXR1cm4gaGFzVmFsaWRSZXF1ZXN0SWQgJiYgaGFzVmFsaWRSZXF1ZXN0U3RhdHVzO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rQXJyYXkoYSkge1xuICByZXR1cm4gdHlwZW9mIGFbMF0gPT09IFwiZnVuY3Rpb25cIiAmJiBcInBlbmRpbmdcIiBpbiBhWzBdICYmIFwiZnVsZmlsbGVkXCIgaW4gYVswXSAmJiBcInJlamVjdGVkXCIgaW4gYVswXTtcbn1cbmZ1bmN0aW9uIGlzUGVuZGluZyguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNQZW5kaW5nKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucGVuZGluZyk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZCguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicmVqZWN0ZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUmVqZWN0ZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5yZWplY3RlZCk7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNSZWplY3RlZFdpdGhWYWx1ZSguLi5hc3luY1RodW5rcykge1xuICBjb25zdCBoYXNGbGFnID0gKGFjdGlvbikgPT4ge1xuICAgIHJldHVybiBhY3Rpb24gJiYgYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWU7XG4gIH07XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gICAgfTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkV2l0aFZhbHVlKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbGxPZihpc1JlamVjdGVkKC4uLmFzeW5jVGh1bmtzKSwgaGFzRmxhZyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuZnVuY3Rpb24gaXNGdWxmaWxsZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcImZ1bGZpbGxlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNGdWxmaWxsZWQoKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IGFzeW5jVGh1bmtzLm1hcCgoYXN5bmNUaHVuaykgPT4gYXN5bmNUaHVuay5mdWxmaWxsZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FjdGlvbiguLi5hc3luY1RodW5rcykge1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IGhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhKGFjdGlvbiwgW1wicGVuZGluZ1wiLCBcImZ1bGZpbGxlZFwiLCBcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc0FzeW5jVGh1bmtBY3Rpb24oKShhc3luY1RodW5rc1swXSk7XG4gIH1cbiAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICBjb25zdCBtYXRjaGVycyA9IFtdO1xuICAgIGZvciAoY29uc3QgYXN5bmNUaHVuayBvZiBhc3luY1RodW5rcykge1xuICAgICAgbWF0Y2hlcnMucHVzaChhc3luY1RodW5rLnBlbmRpbmcsIGFzeW5jVGh1bmsucmVqZWN0ZWQsIGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICB9XG4gICAgY29uc3QgY29tYmluZWRNYXRjaGVyID0gaXNBbnlPZiguLi5tYXRjaGVycyk7XG4gICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICB9O1xufVxuXG4vLyBzcmMvY3JlYXRlQXN5bmNUaHVuay50c1xudmFyIGNvbW1vblByb3BlcnRpZXMgPSBbXCJuYW1lXCIsIFwibWVzc2FnZVwiLCBcInN0YWNrXCIsIFwiY29kZVwiXTtcbnZhciBSZWplY3RXaXRoVmFsdWUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBheWxvYWQsIG1ldGEpIHtcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gIH1cbiAgLypcbiAgdHlwZS1vbmx5IHByb3BlcnR5IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gUmVqZWN0V2l0aFZhbHVlIGFuZCBGdWxmaWxsV2l0aE1ldGFcbiAgZG9lcyBub3QgZXhpc3QgYXQgcnVudGltZVxuICAqL1xuICBfdHlwZTtcbn07XG52YXIgRnVsZmlsbFdpdGhNZXRhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgY29uc3Qgc2ltcGxlRXJyb3IgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVbcHJvcGVydHldID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHNpbXBsZUVycm9yW3Byb3BlcnR5XSA9IHZhbHVlW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpbXBsZUVycm9yO1xuICB9XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogU3RyaW5nKHZhbHVlKVxuICB9O1xufTtcbnZhciBjcmVhdGVBc3luY1RodW5rID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bmsyKHR5cGVQcmVmaXgsIHBheWxvYWRDcmVhdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZnVsZmlsbGVkID0gY3JlYXRlQWN0aW9uKHR5cGVQcmVmaXggKyBcIi9mdWxmaWxsZWRcIiwgKHBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZCxcbiAgICAgIG1ldGE6IHtcbiAgICAgICAgLi4ubWV0YSB8fCB7fSxcbiAgICAgICAgYXJnLFxuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlcXVlc3RTdGF0dXM6IFwiZnVsZmlsbGVkXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcGVuZGluZyA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcGVuZGluZ1wiLCAocmVxdWVzdElkLCBhcmcsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkOiB2b2lkIDAsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInBlbmRpbmdcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBjb25zdCByZWplY3RlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvcmVqZWN0ZWRcIiwgKGVycm9yLCByZXF1ZXN0SWQsIGFyZywgcGF5bG9hZCwgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBlcnJvcjogKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXJpYWxpemVFcnJvciB8fCBtaW5pU2VyaWFsaXplRXJyb3IpKGVycm9yIHx8IFwiUmVqZWN0ZWRcIiksXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZWplY3RlZFdpdGhWYWx1ZTogISFwYXlsb2FkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcInJlamVjdGVkXCIsXG4gICAgICAgIGFib3J0ZWQ6IGVycm9yPy5uYW1lID09PSBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgY29uZGl0aW9uOiBlcnJvcj8ubmFtZSA9PT0gXCJDb25kaXRpb25FcnJvclwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoYXJnKSB7XG4gICAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gb3B0aW9ucz8uaWRHZW5lcmF0b3IgPyBvcHRpb25zLmlkR2VuZXJhdG9yKGFyZykgOiBuYW5vaWQoKTtcbiAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBsZXQgYWJvcnRSZWFzb247XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uO1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgZmluYWxBY3Rpb247XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBvcHRpb25zPy5jb25kaXRpb24/LihhcmcsIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1RoZW5hYmxlKGNvbmRpdGlvblJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gYXdhaXQgY29uZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvblJlc3VsdCA9PT0gZmFsc2UgfHwgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbmRpdGlvbkVycm9yXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJBYm9ydGVkIGR1ZSB0byBjb25kaXRpb24gY2FsbGJhY2sgcmV0dXJuaW5nIGZhbHNlLlwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHJlamVjdCh7XG4gICAgICAgICAgICAgIG5hbWU6IFwiQWJvcnRFcnJvclwiLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBhYm9ydFJlYXNvbiB8fCBcIkFib3J0ZWRcIlxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGRpc3BhdGNoKHBlbmRpbmcocmVxdWVzdElkLCBhcmcsIG9wdGlvbnM/LmdldFBlbmRpbmdNZXRhPy4oe1xuICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgIGFyZ1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmFcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbYWJvcnRlZFByb21pc2UsIFByb21pc2UucmVzb2x2ZShwYXlsb2FkQ3JlYXRvcihhcmcsIHtcbiAgICAgICAgICAgICAgZGlzcGF0Y2gsXG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAgIGFib3J0LFxuICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVqZWN0V2l0aFZhbHVlKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZnVsZmlsbFdpdGhWYWx1ZTogKHZhbHVlLCBtZXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGdWxmaWxsV2l0aE1ldGEodmFsdWUsIG1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEZ1bGZpbGxXaXRoTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LnBheWxvYWQsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQubWV0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKTtcbiAgICAgICAgICAgIH0pXSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBmaW5hbEFjdGlvbiA9IGVyciBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSA/IHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCBlcnIucGF5bG9hZCwgZXJyLm1ldGEpIDogcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNraXBEaXNwYXRjaCA9IG9wdGlvbnMgJiYgIW9wdGlvbnMuZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24gJiYgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmIGZpbmFsQWN0aW9uLm1ldGEuY29uZGl0aW9uO1xuICAgICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XG4gICAgICAgICAgICBkaXNwYXRjaChmaW5hbEFjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmaW5hbEFjdGlvbjtcbiAgICAgICAgfSgpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7XG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIGFyZyxcbiAgICAgICAgICB1bndyYXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHVud3JhcFJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjdGlvbkNyZWF0b3IsIHtcbiAgICAgIHBlbmRpbmcsXG4gICAgICByZWplY3RlZCxcbiAgICAgIGZ1bGZpbGxlZCxcbiAgICAgIHNldHRsZWQ6IGlzQW55T2YocmVqZWN0ZWQsIGZ1bGZpbGxlZCksXG4gICAgICB0eXBlUHJlZml4XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQXN5bmNUaHVuazIud2l0aFR5cGVzID0gKCkgPT4gY3JlYXRlQXN5bmNUaHVuazI7XG4gIHJldHVybiBjcmVhdGVBc3luY1RodW5rMjtcbn0pKCk7XG5mdW5jdGlvbiB1bndyYXBSZXN1bHQoYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24ubWV0YSAmJiBhY3Rpb24ubWV0YS5yZWplY3RlZFdpdGhWYWx1ZSkge1xuICAgIHRocm93IGFjdGlvbi5wYXlsb2FkO1xuICB9XG4gIGlmIChhY3Rpb24uZXJyb3IpIHtcbiAgICB0aHJvdyBhY3Rpb24uZXJyb3I7XG4gIH1cbiAgcmV0dXJuIGFjdGlvbi5wYXlsb2FkO1xufVxuZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8vIHNyYy9jcmVhdGVTbGljZS50c1xudmFyIGFzeW5jVGh1bmtTeW1ib2wgPSBTeW1ib2wuZm9yKFwicnRrLXNsaWNlLWNyZWF0ZWFzeW5jdGh1bmtcIik7XG52YXIgYXN5bmNUaHVua0NyZWF0b3IgPSB7XG4gIFthc3luY1RodW5rU3ltYm9sXTogY3JlYXRlQXN5bmNUaHVua1xufTtcbnZhciBSZWR1Y2VyVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFJlZHVjZXJUeXBlMikgPT4ge1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyXCJdID0gXCJyZWR1Y2VyXCI7XG4gIFJlZHVjZXJUeXBlMltcInJlZHVjZXJXaXRoUHJlcGFyZVwiXSA9IFwicmVkdWNlcldpdGhQcmVwYXJlXCI7XG4gIFJlZHVjZXJUeXBlMltcImFzeW5jVGh1bmtcIl0gPSBcImFzeW5jVGh1bmtcIjtcbiAgcmV0dXJuIFJlZHVjZXJUeXBlMjtcbn0pKFJlZHVjZXJUeXBlIHx8IHt9KTtcbmZ1bmN0aW9uIGdldFR5cGUoc2xpY2UsIGFjdGlvbktleSkge1xuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWA7XG59XG5mdW5jdGlvbiBidWlsZENyZWF0ZVNsaWNlKHtcbiAgY3JlYXRvcnNcbn0gPSB7fSkge1xuICBjb25zdCBjQVQgPSBjcmVhdG9ycz8uYXN5bmNUaHVuaz8uW2FzeW5jVGh1bmtTeW1ib2xdO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU2xpY2UyKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgcmVkdWNlclBhdGggPSBuYW1lXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMSkgOiBcImBuYW1lYCBpcyBhIHJlcXVpcmVkIG9wdGlvbiBmb3IgY3JlYXRlU2xpY2VcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0cnVlKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbml0aWFsU3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhbiBgaW5pdGlhbFN0YXRlYCB2YWx1ZSB0aGF0IGlzIG5vdCBgdW5kZWZpbmVkYC4gWW91IG1heSBoYXZlIG1pc3NwZWxsZWQgYGluaXRpYWxTdGF0ZWBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlZHVjZXJzID0gKHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLnJlZHVjZXJzKGJ1aWxkUmVkdWNlckNyZWF0b3JzKCkpIDogb3B0aW9ucy5yZWR1Y2VycykgfHwge307XG4gICAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZToge30sXG4gICAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZToge30sXG4gICAgICBhY3Rpb25DcmVhdG9yczoge30sXG4gICAgICBzbGljZU1hdGNoZXJzOiBbXVxuICAgIH07XG4gICAgY29uc3QgY29udGV4dE1ldGhvZHMgPSB7XG4gICAgICBhZGRDYXNlKHR5cGVPckFjdGlvbkNyZWF0b3IsIHJlZHVjZXIpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSBcInN0cmluZ1wiID8gdHlwZU9yQWN0aW9uQ3JlYXRvciA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDEyKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTMoMTMpIDogXCJgY29udGV4dC5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggdHdvIHJlZHVjZXJzIGZvciB0aGUgc2FtZSBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGFkZE1hdGNoZXIobWF0Y2hlciwgcmVkdWNlcikge1xuICAgICAgICBjb250ZXh0LnNsaWNlTWF0Y2hlcnMucHVzaCh7XG4gICAgICAgICAgbWF0Y2hlcixcbiAgICAgICAgICByZWR1Y2VyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQWN0aW9uKG5hbWUyLCBhY3Rpb25DcmVhdG9yKSB7XG4gICAgICAgIGNvbnRleHQuYWN0aW9uQ3JlYXRvcnNbbmFtZTJdID0gYWN0aW9uQ3JlYXRvcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfSxcbiAgICAgIGV4cG9zZUNhc2VSZWR1Y2VyKG5hbWUyLCByZWR1Y2VyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWVbbmFtZTJdID0gcmVkdWNlcjtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRNZXRob2RzO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVkdWNlck5hbWVzLmZvckVhY2goKHJlZHVjZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCByZWR1Y2VyRGVmaW5pdGlvbiA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXTtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZXRhaWxzID0ge1xuICAgICAgICByZWR1Y2VyTmFtZSxcbiAgICAgICAgdHlwZTogZ2V0VHlwZShuYW1lLCByZWR1Y2VyTmFtZSksXG4gICAgICAgIGNyZWF0ZU5vdGF0aW9uOiB0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICB9O1xuICAgICAgaWYgKGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pKSB7XG4gICAgICAgIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMsIGNBVCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGV0YWlscywgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHRNZXRob2RzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBidWlsZFJlZHVjZXIoKSB7XG4gICAgICBpZiAodHJ1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IFtleHRyYVJlZHVjZXJzID0ge30sIGFjdGlvbk1hdGNoZXJzID0gW10sIGRlZmF1bHRDYXNlUmVkdWNlciA9IHZvaWQgMF0gPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHtcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZENhc2Uoa2V5LCBmaW5hbENhc2VSZWR1Y2Vyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzTSBvZiBjb250ZXh0LnNsaWNlTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIoc00ubWF0Y2hlciwgc00ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkRGVmYXVsdENhc2UoZGVmYXVsdENhc2VSZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGUpID0+IHN0YXRlO1xuICAgIGNvbnN0IGluamVjdGVkU2VsZWN0b3JDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIGxldCBfcmVkdWNlcjtcbiAgICBjb25zdCBzbGljZSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgIH0sXG4gICAgICBhY3Rpb25zOiBjb250ZXh0LmFjdGlvbkNyZWF0b3JzLFxuICAgICAgY2FzZVJlZHVjZXJzOiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lLFxuICAgICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0sXG4gICAgICBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUgPSBzZWxlY3RTZWxmKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBlbXBsYWNlKGluamVjdGVkU2VsZWN0b3JDYWNoZSwgdGhpcywge1xuICAgICAgICAgIGluc2VydDogKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbXBsYWNlKHNlbGVjdG9yQ2FjaGUsIHNlbGVjdFN0YXRlLCB7XG4gICAgICAgICAgaW5zZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUyLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zZWxlY3RvcnMgPz8ge30pKSB7XG4gICAgICAgICAgICAgIG1hcFtuYW1lMl0gPSB3cmFwU2VsZWN0b3IodGhpcywgc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCB0aGlzICE9PSBzbGljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2VsZWN0U2xpY2Uoc3RhdGUpIHtcbiAgICAgICAgbGV0IHNsaWNlU3RhdGUgPSBzdGF0ZVt0aGlzLnJlZHVjZXJQYXRoXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMgIT09IHNsaWNlKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNSgxNSkgOiBcInNlbGVjdFNsaWNlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2xpY2VTdGF0ZTtcbiAgICAgIH0sXG4gICAgICBnZXQgc2VsZWN0b3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3RvcnModGhpcy5zZWxlY3RTbGljZSk7XG4gICAgICB9LFxuICAgICAgaW5qZWN0SW50byhpbmplY3RhYmxlLCB7XG4gICAgICAgIHJlZHVjZXJQYXRoOiBwYXRoT3B0LFxuICAgICAgICAuLi5jb25maWdcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBjb25zdCByZWR1Y2VyUGF0aDIgPSBwYXRoT3B0ID8/IHRoaXMucmVkdWNlclBhdGg7XG4gICAgICAgIGluamVjdGFibGUuaW5qZWN0KHtcbiAgICAgICAgICByZWR1Y2VyUGF0aDogcmVkdWNlclBhdGgyLFxuICAgICAgICAgIHJlZHVjZXI6IHRoaXMucmVkdWNlclxuICAgICAgICB9LCBjb25maWcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRoaXMsXG4gICAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMlxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHNsaWNlO1xuICB9O1xufVxuZnVuY3Rpb24gd3JhcFNlbGVjdG9yKHNsaWNlLCBzZWxlY3Rvciwgc2VsZWN0U3RhdGUsIGluamVjdGVkKSB7XG4gIGZ1bmN0aW9uIHdyYXBwZXIocm9vdFN0YXRlLCAuLi5hcmdzKSB7XG4gICAgbGV0IHNsaWNlU3RhdGUgPSBzZWxlY3RTdGF0ZS5jYWxsKHNsaWNlLCByb290U3RhdGUpO1xuICAgIGlmICh0eXBlb2Ygc2xpY2VTdGF0ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKGluamVjdGVkKSB7XG4gICAgICAgIHNsaWNlU3RhdGUgPSBzbGljZS5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYoMTYpIDogXCJzZWxlY3RTdGF0ZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yKHNsaWNlU3RhdGUsIC4uLmFyZ3MpO1xuICB9XG4gIHdyYXBwZXIudW53cmFwcGVkID0gc2VsZWN0b3I7XG4gIHJldHVybiB3cmFwcGVyO1xufVxudmFyIGNyZWF0ZVNsaWNlID0gYnVpbGRDcmVhdGVTbGljZSgpO1xuZnVuY3Rpb24gYnVpbGRSZWR1Y2VyQ3JlYXRvcnMoKSB7XG4gIGZ1bmN0aW9uIGFzeW5jVGh1bmsocGF5bG9hZENyZWF0b3IsIGNvbmZpZykge1xuICAgIHJldHVybiB7XG4gICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcImFzeW5jVGh1bmtcIiAvKiBhc3luY1RodW5rICovLFxuICAgICAgcGF5bG9hZENyZWF0b3IsXG4gICAgICAuLi5jb25maWdcbiAgICB9O1xuICB9XG4gIGFzeW5jVGh1bmsud2l0aFR5cGVzID0gKCkgPT4gYXN5bmNUaHVuaztcbiAgcmV0dXJuIHtcbiAgICByZWR1Y2VyKGNhc2VSZWR1Y2VyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIC8vIGhhY2sgc28gdGhlIHdyYXBwaW5nIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBvcmlnaW5hbFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdyYXBwZXIgc28gdGhlIGByZWR1Y2VyRGVmaW5pdGlvblR5cGVgIGlzIG5vdCBhc3NpZ25lZCB0byB0aGUgb3JpZ2luYWxcbiAgICAgICAgW2Nhc2VSZWR1Y2VyLm5hbWVdKC4uLmFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1bY2FzZVJlZHVjZXIubmFtZV0sIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyXCIgLyogcmVkdWNlciAqL1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBwcmVwYXJlZFJlZHVjZXIocHJlcGFyZSwgcmVkdWNlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX3JlZHVjZXJEZWZpbml0aW9uVHlwZTogXCJyZWR1Y2VyV2l0aFByZXBhcmVcIiAvKiByZWR1Y2VyV2l0aFByZXBhcmUgKi8sXG4gICAgICAgIHByZXBhcmUsXG4gICAgICAgIHJlZHVjZXJcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luY1RodW5rXG4gIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOb3JtYWxSZWR1Y2VyRGVmaW5pdGlvbih7XG4gIHR5cGUsXG4gIHJlZHVjZXJOYW1lLFxuICBjcmVhdGVOb3RhdGlvblxufSwgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUsIGNvbnRleHQpIHtcbiAgbGV0IGNhc2VSZWR1Y2VyO1xuICBsZXQgcHJlcGFyZUNhbGxiYWNrO1xuICBpZiAoXCJyZWR1Y2VyXCIgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcbiAgICBpZiAoY3JlYXRlTm90YXRpb24gJiYgIWlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24obWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTcoMTcpIDogXCJQbGVhc2UgdXNlIHRoZSBgY3JlYXRlLnByZXBhcmVkUmVkdWNlcmAgbm90YXRpb24gZm9yIHByZXBhcmVkIGFjdGlvbiBjcmVhdG9ycyB3aXRoIHRoZSBgY3JlYXRlYCBub3RhdGlvbi5cIik7XG4gICAgfVxuICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucmVkdWNlcjtcbiAgICBwcmVwYXJlQ2FsbGJhY2sgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5wcmVwYXJlO1xuICB9IGVsc2Uge1xuICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmU7XG4gIH1cbiAgY29udGV4dC5hZGRDYXNlKHR5cGUsIGNhc2VSZWR1Y2VyKS5leHBvc2VDYXNlUmVkdWNlcihyZWR1Y2VyTmFtZSwgY2FzZVJlZHVjZXIpLmV4cG9zZUFjdGlvbihyZWR1Y2VyTmFtZSwgcHJlcGFyZUNhbGxiYWNrID8gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVDYWxsYmFjaykgOiBjcmVhdGVBY3Rpb24odHlwZSkpO1xufVxuZnVuY3Rpb24gaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikge1xuICByZXR1cm4gcmVkdWNlckRlZmluaXRpb24uX3JlZHVjZXJEZWZpbml0aW9uVHlwZSA9PT0gXCJhc3luY1RodW5rXCIgLyogYXN5bmNUaHVuayAqLztcbn1cbmZ1bmN0aW9uIGlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwicmVkdWNlcldpdGhQcmVwYXJlXCIgLyogcmVkdWNlcldpdGhQcmVwYXJlICovO1xufVxuZnVuY3Rpb24gaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24oe1xuICB0eXBlLFxuICByZWR1Y2VyTmFtZVxufSwgcmVkdWNlckRlZmluaXRpb24sIGNvbnRleHQsIGNBVCkge1xuICBpZiAoIWNBVCkge1xuICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlOCgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGUpID0+IHN0YXRlLmVudGl0aWVzO1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcykgPT4gaWRzLm1hcCgoaWQpID0+IGVudGl0aWVzW2lkXSkpO1xuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzLCBpZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgKGlkcykgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXG4gICAgICBzZWxlY3RBbGw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3RvcnNcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcbnZhciBpbXBvcnRfaW1tZXI0ID0gcmVxdWlyZShcImltbWVyXCIpO1xudmFyIGlzRHJhZnRUeXBlZCA9IGltcG9ydF9pbW1lcjQuaXNEcmFmdDtcbmZ1bmN0aW9uIGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIGNvbnN0IG9wZXJhdG9yID0gY3JlYXRlU3RhdGVPcGVyYXRvcigoXywgc3RhdGUpID0+IG11dGF0b3Ioc3RhdGUpKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG9wZXJhdGlvbihzdGF0ZSkge1xuICAgIHJldHVybiBvcGVyYXRvcihzdGF0ZSwgdm9pZCAwKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3IobXV0YXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlLCBhcmcpIHtcbiAgICBmdW5jdGlvbiBpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcyKSB7XG4gICAgICByZXR1cm4gaXNGU0EoYXJnMik7XG4gICAgfVxuICAgIGNvbnN0IHJ1bk11dGF0b3IgPSAoZHJhZnQpID0+IHtcbiAgICAgIGlmIChpc1BheWxvYWRBY3Rpb25Bcmd1bWVudChhcmcpKSB7XG4gICAgICAgIG11dGF0b3IoYXJnLnBheWxvYWQsIGRyYWZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11dGF0b3IoYXJnLCBkcmFmdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNEcmFmdFR5cGVkKHN0YXRlKSkge1xuICAgICAgcnVuTXV0YXRvcihzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIHJldHVybiAoMCwgaW1wb3J0X2ltbWVyNC5wcm9kdWNlKShzdGF0ZSwgcnVuTXV0YXRvcik7XG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91dGlscy50c1xuZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKSB7XG4gIGNvbnN0IGtleSA9IHNlbGVjdElkKGVudGl0eSk7XG4gIGlmIChrZXkgPT09IHZvaWQgMCkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBlbnRpdHkgcGFzc2VkIHRvIHRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uIHJldHVybmVkIHVuZGVmaW5lZC5cIiwgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHByb3ZpZGUgeW91ciBvd24gYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbi5cIiwgXCJUaGUgZW50aXR5IHRoYXQgd2FzIHBhc3NlZDpcIiwgZW50aXR5LCBcIlRoZSBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uOlwiLCBzZWxlY3RJZC50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gZW5zdXJlRW50aXRpZXNBcnJheShlbnRpdGllcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSB7XG4gICAgZW50aXRpZXMgPSBPYmplY3QudmFsdWVzKGVudGl0aWVzKTtcbiAgfVxuICByZXR1cm4gZW50aXRpZXM7XG59XG5mdW5jdGlvbiBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpIHtcbiAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgY29uc3QgYWRkZWQgPSBbXTtcbiAgY29uc3QgdXBkYXRlZCA9IFtdO1xuICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgIGNvbnN0IGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHVwZGF0ZWQucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBjaGFuZ2VzOiBlbnRpdHlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRlZC5wdXNoKGVudGl0eSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbYWRkZWQsIHVwZGF0ZWRdO1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdW5zb3J0ZWRfc3RhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpIHtcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgY29uc3Qga2V5ID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKTtcbiAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmICghKGtleSBpbiBzdGF0ZS5lbnRpdGllcykpIHtcbiAgICAgIHN0YXRlLmlkcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBuZXdFbnRpdGllcykge1xuICAgICAgc2V0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVPbmVNdXRhYmx5KGtleSwgc3RhdGUpIHtcbiAgICByZXR1cm4gcmVtb3ZlTWFueU11dGFibHkoW2tleV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzLCBzdGF0ZSkge1xuICAgIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XTtcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlkTXV0YXRlKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMuZmlsdGVyKChpZCkgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlKSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgaWRzOiBbXSxcbiAgICAgIGVudGl0aWVzOiB7fVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoa2V5cywgdXBkYXRlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsMyA9IHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgaWYgKG9yaWdpbmFsMyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnaW5hbDMsIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICBjb25zdCBuZXdLZXkgPSBzZWxlY3RJZFZhbHVlKHVwZGF0ZWQsIHNlbGVjdElkKTtcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZDtcbiAgICBpZiAoaGFzTmV3S2V5KSB7XG4gICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXk7XG4gICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICB9XG4gICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWQ7XG4gICAgcmV0dXJuIGhhc05ld0tleTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5ld0tleXMgPSB7fTtcbiAgICBjb25zdCB1cGRhdGVzUGVyRW50aXR5ID0ge307XG4gICAgdXBkYXRlcy5mb3JFYWNoKCh1cGRhdGUpID0+IHtcbiAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xuICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXG4gICAgICAgICAgLy8gU3ByZWFkcyBpZ25vcmUgZmFsc3kgdmFsdWVzLCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgdGhlcmUgaXNuJ3RcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxuICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgIC4uLnVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA/IHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXS5jaGFuZ2VzIDogbnVsbCxcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpO1xuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwO1xuICAgIGlmIChkaWRNdXRhdGVFbnRpdGllcykge1xuICAgICAgY29uc3QgZGlkTXV0YXRlSWRzID0gdXBkYXRlcy5maWx0ZXIoKHVwZGF0ZSkgPT4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKSkubGVuZ3RoID4gMDtcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcbiAgICAgICAgc3RhdGUuaWRzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcykubWFwKChlKSA9PiBzZWxlY3RJZFZhbHVlKGUsIHNlbGVjdElkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlQWxsOiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IocmVtb3ZlQWxsTXV0YWJseSksXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcbiAgICByZW1vdmVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlT25lTXV0YWJseSksXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3NvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnQpIHtcbiAgY29uc3Qge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbFxuICB9ID0gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gYWRkTWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGNvbnN0IG1vZGVscyA9IG5ld0VudGl0aWVzLmZpbHRlcigobW9kZWwpID0+ICEoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpIGluIHN0YXRlLmVudGl0aWVzKSk7XG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlKG1vZGVscywgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gc2V0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGlmIChuZXdFbnRpdGllcy5sZW5ndGggIT09IDApIHtcbiAgICAgIG1lcmdlKG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgbmV3RW50aXRpZXMgPSBlbnN1cmVFbnRpdGllc0FycmF5KG5ld0VudGl0aWVzKTtcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9O1xuICAgIHN0YXRlLmlkcyA9IFtdO1xuICAgIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlcywgc3RhdGUpIHtcbiAgICBsZXQgYXBwbGllZFVwZGF0ZXMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB1cGRhdGUgb2YgdXBkYXRlcykge1xuICAgICAgY29uc3QgZW50aXR5ID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICAgIGlmICghZW50aXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYXBwbGllZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgT2JqZWN0LmFzc2lnbihlbnRpdHksIHVwZGF0ZS5jaGFuZ2VzKTtcbiAgICAgIGNvbnN0IG5ld0lkID0gc2VsZWN0SWQoZW50aXR5KTtcbiAgICAgIGlmICh1cGRhdGUuaWQgIT09IG5ld0lkKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgICBzdGF0ZS5lbnRpdGllc1tuZXdJZF0gPSBlbnRpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcHBsaWVkVXBkYXRlcykge1xuICAgICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBjb25zdCBbYWRkZWQsIHVwZGF0ZWRdID0gc3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyhuZXdFbnRpdGllcywgc2VsZWN0SWQsIHN0YXRlKTtcbiAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSk7XG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoICYmIGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2UobW9kZWxzLCBzdGF0ZSkge1xuICAgIG1vZGVscy5mb3JFYWNoKChtb2RlbCkgPT4ge1xuICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsO1xuICAgIH0pO1xuICAgIHJlc29ydEVudGl0aWVzKHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiByZXNvcnRFbnRpdGllcyhzdGF0ZSkge1xuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcyk7XG4gICAgYWxsRW50aXRpZXMuc29ydChzb3J0KTtcbiAgICBjb25zdCBuZXdTb3J0ZWRJZHMgPSBhbGxFbnRpdGllcy5tYXAoc2VsZWN0SWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkc1xuICAgIH0gPSBzdGF0ZTtcbiAgICBpZiAoIWFyZUFycmF5c0VxdWFsKGlkcywgbmV3U29ydGVkSWRzKSkge1xuICAgICAgc3RhdGUuaWRzID0gbmV3U29ydGVkSWRzO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHJlbW92ZU9uZSxcbiAgICByZW1vdmVNYW55LFxuICAgIHJlbW92ZUFsbCxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcbiAgICBzZXRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0T25lTXV0YWJseSksXG4gICAgc2V0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRNYW55TXV0YWJseSksXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50c1xuZnVuY3Rpb24gY3JlYXRlRW50aXR5QWRhcHRlcihvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlclxuICB9ID0ge1xuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXG4gICAgc2VsZWN0SWQ6IChpbnN0YW5jZSkgPT4gaW5zdGFuY2UuaWQsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBzdGF0ZUZhY3RvcnkgPSBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5KCk7XG4gIGNvbnN0IHNlbGVjdG9yc0ZhY3RvcnkgPSBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5KCk7XG4gIGNvbnN0IHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlciA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKSA6IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkKTtcbiAgcmV0dXJuIHtcbiAgICBzZWxlY3RJZCxcbiAgICBzb3J0Q29tcGFyZXIsXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXG4gICAgLi4uc3RhdGVBZGFwdGVyXG4gIH07XG59XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvaW5kZXgudHNcbnZhciBpbXBvcnRfcmVkdXg1ID0gcmVxdWlyZShcInJlZHV4XCIpO1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3V0aWxzLnRzXG52YXIgYXNzZXJ0RnVuY3Rpb24gPSAoZnVuYywgZXhwZWN0ZWQpID0+IHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMikgOiBgJHtleHBlY3RlZH0gaXMgbm90IGEgZnVuY3Rpb25gKTtcbiAgfVxufTtcbnZhciBub29wMiA9ICgpID0+IHtcbn07XG52YXIgY2F0Y2hSZWplY3Rpb24gPSAocHJvbWlzZSwgb25FcnJvciA9IG5vb3AyKSA9PiB7XG4gIHByb21pc2UuY2F0Y2gob25FcnJvcik7XG4gIHJldHVybiBwcm9taXNlO1xufTtcbnZhciBhZGRBYm9ydFNpZ25hbExpc3RlbmVyID0gKGFib3J0U2lnbmFsLCBjYWxsYmFjaykgPT4ge1xuICBhYm9ydFNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2ssIHtcbiAgICBvbmNlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gKCkgPT4gYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGNhbGxiYWNrKTtcbn07XG52YXIgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbiA9IChhYm9ydENvbnRyb2xsZXIsIHJlYXNvbikgPT4ge1xuICBjb25zdCBzaWduYWwgPSBhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEoXCJyZWFzb25cIiBpbiBzaWduYWwpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpZ25hbCwgXCJyZWFzb25cIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiByZWFzb24sXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIDtcbiAgYWJvcnRDb250cm9sbGVyLmFib3J0KHJlYXNvbik7XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2V4Y2VwdGlvbnMudHNcbnZhciB0YXNrID0gXCJ0YXNrXCI7XG52YXIgbGlzdGVuZXIgPSBcImxpc3RlbmVyXCI7XG52YXIgY29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbnZhciBjYW5jZWxsZWQgPSBcImNhbmNlbGxlZFwiO1xudmFyIHRhc2tDYW5jZWxsZWQgPSBgdGFzay0ke2NhbmNlbGxlZH1gO1xudmFyIHRhc2tDb21wbGV0ZWQgPSBgdGFzay0ke2NvbXBsZXRlZH1gO1xudmFyIGxpc3RlbmVyQ2FuY2VsbGVkID0gYCR7bGlzdGVuZXJ9LSR7Y2FuY2VsbGVkfWA7XG52YXIgbGlzdGVuZXJDb21wbGV0ZWQgPSBgJHtsaXN0ZW5lcn0tJHtjb21wbGV0ZWR9YDtcbnZhciBUYXNrQWJvcnRFcnJvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29kZSkge1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gYCR7dGFza30gJHtjYW5jZWxsZWR9IChyZWFzb246ICR7Y29kZX0pYDtcbiAgfVxuICBuYW1lID0gXCJUYXNrQWJvcnRFcnJvclwiO1xuICBtZXNzYWdlO1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS90YXNrLnRzXG52YXIgdmFsaWRhdGVBY3RpdmUgPSAoc2lnbmFsKSA9PiB7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlYXNvblxuICAgIH0gPSBzaWduYWw7XG4gICAgdGhyb3cgbmV3IFRhc2tBYm9ydEVycm9yKHJlYXNvbik7XG4gIH1cbn07XG5mdW5jdGlvbiByYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpIHtcbiAgbGV0IGNsZWFudXAgPSBub29wMjtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBub3RpZnlSZWplY3Rpb24gPSAoKSA9PiByZWplY3QobmV3IFRhc2tBYm9ydEVycm9yKHNpZ25hbC5yZWFzb24pKTtcbiAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIG5vdGlmeVJlamVjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhbnVwID0gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihzaWduYWwsIG5vdGlmeVJlamVjdGlvbik7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IGNsZWFudXAoKSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBjbGVhbnVwID0gbm9vcDI7XG4gIH0pO1xufVxudmFyIHJ1blRhc2sgPSBhc3luYyAodGFzazIsIGNsZWFuVXApID0+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRhc2syKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogXCJva1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGVycm9yIGluc3RhbmNlb2YgVGFza0Fib3J0RXJyb3IgPyBcImNhbmNlbGxlZFwiIDogXCJyZWplY3RlZFwiLFxuICAgICAgZXJyb3JcbiAgICB9O1xuICB9IGZpbmFsbHkge1xuICAgIGNsZWFuVXA/LigpO1xuICB9XG59O1xudmFyIGNyZWF0ZVBhdXNlID0gKHNpZ25hbCkgPT4ge1xuICByZXR1cm4gKHByb21pc2UpID0+IHtcbiAgICByZXR1cm4gY2F0Y2hSZWplY3Rpb24ocmFjZVdpdGhTaWduYWwoc2lnbmFsLCBwcm9taXNlKS50aGVuKChvdXRwdXQpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pKTtcbiAgfTtcbn07XG52YXIgY3JlYXRlRGVsYXkgPSAoc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHBhdXNlID0gY3JlYXRlUGF1c2Uoc2lnbmFsKTtcbiAgcmV0dXJuICh0aW1lb3V0TXMpID0+IHtcbiAgICByZXR1cm4gcGF1c2UobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dE1zKSkpO1xuICB9O1xufTtcblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xudmFyIHtcbiAgYXNzaWduXG59ID0gT2JqZWN0O1xudmFyIElOVEVSTkFMX05JTF9UT0tFTiA9IHt9O1xudmFyIGFsbSA9IFwibGlzdGVuZXJNaWRkbGV3YXJlXCI7XG52YXIgY3JlYXRlRm9yayA9IChwYXJlbnRBYm9ydFNpZ25hbCwgcGFyZW50QmxvY2tpbmdQcm9taXNlcykgPT4ge1xuICBjb25zdCBsaW5rQ29udHJvbGxlcnMgPSAoY29udHJvbGxlcikgPT4gYWRkQWJvcnRTaWduYWxMaXN0ZW5lcihwYXJlbnRBYm9ydFNpZ25hbCwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBwYXJlbnRBYm9ydFNpZ25hbC5yZWFzb24pKTtcbiAgcmV0dXJuICh0YXNrRXhlY3V0b3IsIG9wdHMpID0+IHtcbiAgICBhc3NlcnRGdW5jdGlvbih0YXNrRXhlY3V0b3IsIFwidGFza0V4ZWN1dG9yXCIpO1xuICAgIGNvbnN0IGNoaWxkQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxpbmtDb250cm9sbGVycyhjaGlsZEFib3J0Q29udHJvbGxlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gcnVuVGFzayhhc3luYyAoKSA9PiB7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShwYXJlbnRBYm9ydFNpZ25hbCk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRhc2tFeGVjdXRvcih7XG4gICAgICAgIHBhdXNlOiBjcmVhdGVQYXVzZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBkZWxheTogY3JlYXRlRGVsYXkoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgc2lnbmFsOiBjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoY2hpbGRBYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH0sICgpID0+IGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY2hpbGRBYm9ydENvbnRyb2xsZXIsIHRhc2tDb21wbGV0ZWQpKTtcbiAgICBpZiAob3B0cz8uYXV0b0pvaW4pIHtcbiAgICAgIHBhcmVudEJsb2NraW5nUHJvbWlzZXMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBjcmVhdGVQYXVzZShwYXJlbnRBYm9ydFNpZ25hbCkocmVzdWx0KSxcbiAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NhbmNlbGxlZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn07XG52YXIgY3JlYXRlVGFrZVBhdHRlcm4gPSAoc3RhcnRMaXN0ZW5pbmcsIHNpZ25hbCkgPT4ge1xuICBjb25zdCB0YWtlID0gYXN5bmMgKHByZWRpY2F0ZSwgdGltZW91dCkgPT4ge1xuICAgIHZhbGlkYXRlQWN0aXZlKHNpZ25hbCk7XG4gICAgbGV0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgIH07XG4gICAgY29uc3QgdHVwbGVQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHN0b3BMaXN0ZW5pbmcgPSBzdGFydExpc3RlbmluZyh7XG4gICAgICAgIHByZWRpY2F0ZSxcbiAgICAgICAgZWZmZWN0OiAoYWN0aW9uLCBsaXN0ZW5lckFwaSkgPT4ge1xuICAgICAgICAgIGxpc3RlbmVyQXBpLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmVzb2x2ZShbYWN0aW9uLCBsaXN0ZW5lckFwaS5nZXRTdGF0ZSgpLCBsaXN0ZW5lckFwaS5nZXRPcmlnaW5hbFN0YXRlKCldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgc3RvcExpc3RlbmluZygpO1xuICAgICAgICByZWplY3QoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbdHVwbGVQcm9taXNlXTtcbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQsIG51bGwpKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByYWNlV2l0aFNpZ25hbChzaWduYWwsIFByb21pc2UucmFjZShwcm9taXNlcykpO1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gKHByZWRpY2F0ZSwgdGltZW91dCkgPT4gY2F0Y2hSZWplY3Rpb24odGFrZShwcmVkaWNhdGUsIHRpbWVvdXQpKTtcbn07XG52YXIgZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSA9IChvcHRpb25zKSA9PiB7XG4gIGxldCB7XG4gICAgdHlwZSxcbiAgICBhY3Rpb25DcmVhdG9yLFxuICAgIG1hdGNoZXIsXG4gICAgcHJlZGljYXRlLFxuICAgIGVmZmVjdFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGUpIHtcbiAgICBwcmVkaWNhdGUgPSBjcmVhdGVBY3Rpb24odHlwZSkubWF0Y2g7XG4gIH0gZWxzZSBpZiAoYWN0aW9uQ3JlYXRvcikge1xuICAgIHR5cGUgPSBhY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgcHJlZGljYXRlID0gYWN0aW9uQ3JlYXRvci5tYXRjaDtcbiAgfSBlbHNlIGlmIChtYXRjaGVyKSB7XG4gICAgcHJlZGljYXRlID0gbWF0Y2hlcjtcbiAgfSBlbHNlIGlmIChwcmVkaWNhdGUpIHtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMSkgOiBcIkNyZWF0aW5nIG9yIHJlbW92aW5nIGEgbGlzdGVuZXIgcmVxdWlyZXMgb25lIG9mIHRoZSBrbm93biBmaWVsZHMgZm9yIG1hdGNoaW5nIGFuIGFjdGlvblwiKTtcbiAgfVxuICBhc3NlcnRGdW5jdGlvbihlZmZlY3QsIFwib3B0aW9ucy5saXN0ZW5lclwiKTtcbiAgcmV0dXJuIHtcbiAgICBwcmVkaWNhdGUsXG4gICAgdHlwZSxcbiAgICBlZmZlY3RcbiAgfTtcbn07XG52YXIgY3JlYXRlTGlzdGVuZXJFbnRyeSA9IChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBlZmZlY3RcbiAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gIGNvbnN0IGlkID0gbmFub2lkKCk7XG4gIGNvbnN0IGVudHJ5ID0ge1xuICAgIGlkLFxuICAgIGVmZmVjdCxcbiAgICB0eXBlLFxuICAgIHByZWRpY2F0ZSxcbiAgICBwZW5kaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTIoMjIpIDogXCJVbnN1YnNjcmliZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZW50cnk7XG59O1xudmFyIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyA9IChlbnRyeSkgPT4ge1xuICBlbnRyeS5wZW5kaW5nLmZvckVhY2goKGNvbnRyb2xsZXIpID0+IHtcbiAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgfSk7XG59O1xudmFyIGNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlID0gKGxpc3RlbmVyTWFwKSA9PiB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJNYXAuZm9yRWFjaChjYW5jZWxBY3RpdmVMaXN0ZW5lcnMpO1xuICAgIGxpc3RlbmVyTWFwLmNsZWFyKCk7XG4gIH07XG59O1xudmFyIHNhZmVseU5vdGlmeUVycm9yID0gKGVycm9ySGFuZGxlciwgZXJyb3JUb05vdGlmeSwgZXJyb3JJbmZvKSA9PiB7XG4gIHRyeSB7XG4gICAgZXJyb3JIYW5kbGVyKGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbyk7XG4gIH0gY2F0Y2ggKGVycm9ySGFuZGxlckVycm9yKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aHJvdyBlcnJvckhhbmRsZXJFcnJvcjtcbiAgICB9LCAwKTtcbiAgfVxufTtcbnZhciBhZGRMaXN0ZW5lciA9IGNyZWF0ZUFjdGlvbihgJHthbG19L2FkZGApO1xudmFyIGNsZWFyQWxsTGlzdGVuZXJzID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlQWxsYCk7XG52YXIgcmVtb3ZlTGlzdGVuZXIgPSBjcmVhdGVBY3Rpb24oYCR7YWxtfS9yZW1vdmVgKTtcbnZhciBkZWZhdWx0RXJyb3JIYW5kbGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5lcnJvcihgJHthbG19L2Vycm9yYCwgLi4uYXJncyk7XG59O1xuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJNaWRkbGV3YXJlKG1pZGRsZXdhcmVPcHRpb25zID0ge30pIHtcbiAgY29uc3QgbGlzdGVuZXJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7XG4gICAgZXh0cmEsXG4gICAgb25FcnJvciA9IGRlZmF1bHRFcnJvckhhbmRsZXJcbiAgfSA9IG1pZGRsZXdhcmVPcHRpb25zO1xuICBhc3NlcnRGdW5jdGlvbihvbkVycm9yLCBcIm9uRXJyb3JcIik7XG4gIGNvbnN0IGluc2VydEVudHJ5ID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkudW5zdWJzY3JpYmUgPSAoKSA9PiBsaXN0ZW5lck1hcC5kZWxldGUoZW50cnkuaWQpO1xuICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIHJldHVybiAoY2FuY2VsT3B0aW9ucykgPT4ge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChjYW5jZWxPcHRpb25zPy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBjb25zdCBzdGFydExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgbGV0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGV4aXN0aW5nRW50cnkpID0+IGV4aXN0aW5nRW50cnkuZWZmZWN0ID09PSBvcHRpb25zLmVmZmVjdCk7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgZW50cnkgPSBjcmVhdGVMaXN0ZW5lckVudHJ5KG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zZXJ0RW50cnkoZW50cnkpO1xuICB9O1xuICBjb25zdCBzdG9wTGlzdGVuaW5nID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgZWZmZWN0LFxuICAgICAgcHJlZGljYXRlXG4gICAgfSA9IGdldExpc3RlbmVyRW50cnlQcm9wc0Zyb20ob3B0aW9ucyk7XG4gICAgY29uc3QgZW50cnkgPSBmaW5kKEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpLCAoZW50cnkyKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaFByZWRpY2F0ZU9yVHlwZSA9IHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiID8gZW50cnkyLnR5cGUgPT09IHR5cGUgOiBlbnRyeTIucHJlZGljYXRlID09PSBwcmVkaWNhdGU7XG4gICAgICByZXR1cm4gbWF0Y2hQcmVkaWNhdGVPclR5cGUgJiYgZW50cnkyLmVmZmVjdCA9PT0gZWZmZWN0O1xuICAgIH0pO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudW5zdWJzY3JpYmUoKTtcbiAgICAgIGlmIChvcHRpb25zLmNhbmNlbEFjdGl2ZSkge1xuICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMoZW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gISFlbnRyeTtcbiAgfTtcbiAgY29uc3Qgbm90aWZ5TGlzdGVuZXIgPSBhc3luYyAoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJuYWxUYXNrQ29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCB0YWtlID0gY3JlYXRlVGFrZVBhdHRlcm4oc3RhcnRMaXN0ZW5pbmcsIGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICBjb25zdCBhdXRvSm9pblByb21pc2VzID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGVudHJ5LnBlbmRpbmcuYWRkKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGVudHJ5LmVmZmVjdChcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICAvLyBVc2UgYXNzaWduKCkgcmF0aGVyIHRoYW4gLi4uIHRvIGF2b2lkIGV4dHJhIGhlbHBlciBmdW5jdGlvbnMgYWRkZWQgdG8gYnVuZGxlXG4gICAgICAgIGFzc2lnbih7fSwgYXBpLCB7XG4gICAgICAgICAgZ2V0T3JpZ2luYWxTdGF0ZSxcbiAgICAgICAgICBjb25kaXRpb246IChwcmVkaWNhdGUsIHRpbWVvdXQpID0+IHRha2UocHJlZGljYXRlLCB0aW1lb3V0KS50aGVuKEJvb2xlYW4pLFxuICAgICAgICAgIHRha2UsXG4gICAgICAgICAgZGVsYXk6IGNyZWF0ZURlbGF5KGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBwYXVzZTogY3JlYXRlUGF1c2UoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICAgIGV4dHJhLFxuICAgICAgICAgIHNpZ25hbDogaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgZm9yazogY3JlYXRlRm9yayhpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCwgYXV0b0pvaW5Qcm9taXNlcyksXG4gICAgICAgICAgdW5zdWJzY3JpYmU6IGVudHJ5LnVuc3Vic2NyaWJlLFxuICAgICAgICAgIHN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXJNYXAuc2V0KGVudHJ5LmlkLCBlbnRyeSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWxBY3RpdmVMaXN0ZW5lcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZm9yRWFjaCgoY29udHJvbGxlciwgXywgc2V0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb250cm9sbGVyICE9PSBpbnRlcm5hbFRhc2tDb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgICAgc2V0LmRlbGV0ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aHJvd0lmQ2FuY2VsbGVkOiAoKSA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0ZUFjdGl2ZShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKSk7XG4gICAgfSBjYXRjaCAobGlzdGVuZXJFcnJvcikge1xuICAgICAgaWYgKCEobGlzdGVuZXJFcnJvciBpbnN0YW5jZW9mIFRhc2tBYm9ydEVycm9yKSkge1xuICAgICAgICBzYWZlbHlOb3RpZnlFcnJvcihvbkVycm9yLCBsaXN0ZW5lckVycm9yLCB7XG4gICAgICAgICAgcmFpc2VkQnk6IFwiZWZmZWN0XCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChhdXRvSm9pblByb21pc2VzKTtcbiAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oaW50ZXJuYWxUYXNrQ29udHJvbGxlciwgbGlzdGVuZXJDb21wbGV0ZWQpO1xuICAgICAgZW50cnkucGVuZGluZy5kZWxldGUoaW50ZXJuYWxUYXNrQ29udHJvbGxlcik7XG4gICAgfVxuICB9O1xuICBjb25zdCBjbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IGNyZWF0ZUNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlKGxpc3RlbmVyTWFwKTtcbiAgY29uc3QgbWlkZGxld2FyZSA9IChhcGkpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiB7XG4gICAgaWYgKCEoMCwgaW1wb3J0X3JlZHV4NS5pc0FjdGlvbikoYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIG5leHQoYWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGFkZExpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdGFydExpc3RlbmluZyhhY3Rpb24ucGF5bG9hZCk7XG4gICAgfVxuICAgIGlmIChjbGVhckFsbExpc3RlbmVycy5tYXRjaChhY3Rpb24pKSB7XG4gICAgICBjbGVhckxpc3RlbmVyTWlkZGxld2FyZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVtb3ZlTGlzdGVuZXIubWF0Y2goYWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHN0b3BMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgIH1cbiAgICBsZXQgb3JpZ2luYWxTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGdldE9yaWdpbmFsU3RhdGUgPSAoKSA9PiB7XG4gICAgICBpZiAob3JpZ2luYWxTdGF0ZSA9PT0gSU5URVJOQUxfTklMX1RPS0VOKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWxzZSA/IF9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlMygyMykgOiBgJHthbG19OiBnZXRPcmlnaW5hbFN0YXRlIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxTdGF0ZTtcbiAgICB9O1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGlmIChsaXN0ZW5lck1hcC5zaXplID4gMCkge1xuICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBsaXN0ZW5lckVudHJpZXMpIHtcbiAgICAgICAgICBsZXQgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBlbnRyeS5wcmVkaWNhdGUoYWN0aW9uLCBjdXJyZW50U3RhdGUsIG9yaWdpbmFsU3RhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgcHJlZGljYXRlRXJyb3IsIHtcbiAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJ1bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm90aWZ5TGlzdGVuZXIoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBvcmlnaW5hbFN0YXRlID0gSU5URVJOQUxfTklMX1RPS0VOO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RhcnRMaXN0ZW5pbmcsXG4gICAgc3RvcExpc3RlbmluZyxcbiAgICBjbGVhckxpc3RlbmVyczogY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmVcbiAgfTtcbn1cblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG52YXIgaW1wb3J0X3JlZHV4NiA9IHJlcXVpcmUoXCJyZWR1eFwiKTtcbnZhciBjcmVhdGVNaWRkbGV3YXJlRW50cnkgPSAobWlkZGxld2FyZSkgPT4gKHtcbiAgaWQ6IG5hbm9pZCgpLFxuICBtaWRkbGV3YXJlLFxuICBhcHBsaWVkOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG59KTtcbnZhciBtYXRjaEluc3RhbmNlID0gKGluc3RhbmNlSWQpID0+IChhY3Rpb24pID0+IGFjdGlvbj8ubWV0YT8uaW5zdGFuY2VJZCA9PT0gaW5zdGFuY2VJZDtcbnZhciBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSA9ICgpID0+IHtcbiAgY29uc3QgaW5zdGFuY2VJZCA9IG5hbm9pZCgpO1xuICBjb25zdCBtaWRkbGV3YXJlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3Qgd2l0aE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGNyZWF0ZUFjdGlvbihcImR5bmFtaWNNaWRkbGV3YXJlL2FkZFwiLCAoLi4ubWlkZGxld2FyZXMpID0+ICh7XG4gICAgcGF5bG9hZDogbWlkZGxld2FyZXMsXG4gICAgbWV0YToge1xuICAgICAgaW5zdGFuY2VJZFxuICAgIH1cbiAgfSkpLCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiB3aXRoTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgYWRkTWlkZGxld2FyZSA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gYWRkTWlkZGxld2FyZTIoLi4ubWlkZGxld2FyZXMpIHtcbiAgICBtaWRkbGV3YXJlcy5mb3JFYWNoKChtaWRkbGV3YXJlMikgPT4ge1xuICAgICAgbGV0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKG1pZGRsZXdhcmVNYXAudmFsdWVzKCkpLCAoZW50cnkyKSA9PiBlbnRyeTIubWlkZGxld2FyZSA9PT0gbWlkZGxld2FyZTIpO1xuICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICBlbnRyeSA9IGNyZWF0ZU1pZGRsZXdhcmVFbnRyeShtaWRkbGV3YXJlMik7XG4gICAgICB9XG4gICAgICBtaWRkbGV3YXJlTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgIH0pO1xuICB9LCB7XG4gICAgd2l0aFR5cGVzOiAoKSA9PiBhZGRNaWRkbGV3YXJlXG4gIH0pO1xuICBjb25zdCBnZXRGaW5hbE1pZGRsZXdhcmUgPSAoYXBpKSA9PiB7XG4gICAgY29uc3QgYXBwbGllZE1pZGRsZXdhcmUgPSBBcnJheS5mcm9tKG1pZGRsZXdhcmVNYXAudmFsdWVzKCkpLm1hcCgoZW50cnkpID0+IGVtcGxhY2UoZW50cnkuYXBwbGllZCwgYXBpLCB7XG4gICAgICBpbnNlcnQ6ICgpID0+IGVudHJ5Lm1pZGRsZXdhcmUoYXBpKVxuICAgIH0pKTtcbiAgICByZXR1cm4gKDAsIGltcG9ydF9yZWR1eDYuY29tcG9zZSkoLi4uYXBwbGllZE1pZGRsZXdhcmUpO1xuICB9O1xuICBjb25zdCBpc1dpdGhNaWRkbGV3YXJlID0gaXNBbGxPZih3aXRoTWlkZGxld2FyZSwgbWF0Y2hJbnN0YW5jZShpbnN0YW5jZUlkKSk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc1dpdGhNaWRkbGV3YXJlKGFjdGlvbikpIHtcbiAgICAgIGFkZE1pZGRsZXdhcmUoLi4uYWN0aW9uLnBheWxvYWQpO1xuICAgICAgcmV0dXJuIGFwaS5kaXNwYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpbmFsTWlkZGxld2FyZShhcGkpKG5leHQpKGFjdGlvbik7XG4gIH07XG4gIHJldHVybiB7XG4gICAgbWlkZGxld2FyZSxcbiAgICBhZGRNaWRkbGV3YXJlLFxuICAgIHdpdGhNaWRkbGV3YXJlLFxuICAgIGluc3RhbmNlSWRcbiAgfTtcbn07XG5cbi8vIHNyYy9jb21iaW5lU2xpY2VzLnRzXG52YXIgaW1wb3J0X3JlZHV4NyA9IHJlcXVpcmUoXCJyZWR1eFwiKTtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSlcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKHJlZHVjZXIpIHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZmFsc2UgPyBfZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZhbHNlID8gX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyKDI1KSA6IFwib3JpZ2luYWwgbXVzdCBiZSB1c2VkIG9uIHN0YXRlIFByb3h5XCIpO1xuICB9XG4gIHJldHVybiBzdGF0ZVtPUklHSU5BTF9TVEFURV07XG59O1xuZnVuY3Rpb24gY29tYmluZVNsaWNlcyguLi5zbGljZXMpIHtcbiAgY29uc3QgcmVkdWNlck1hcCA9IE9iamVjdC5mcm9tRW50cmllcyhnZXRSZWR1Y2VycyhzbGljZXMpKTtcbiAgY29uc3QgZ2V0UmVkdWNlciA9ICgpID0+ICgwLCBpbXBvcnRfcmVkdXg3LmNvbWJpbmVSZWR1Y2VycykocmVkdWNlck1hcCk7XG4gIGxldCByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICBmdW5jdGlvbiBjb21iaW5lZFJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgIHJldHVybiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pO1xuICB9XG4gIGNvbWJpbmVkUmVkdWNlci53aXRoTGF6eUxvYWRlZFNsaWNlcyA9ICgpID0+IGNvbWJpbmVkUmVkdWNlcjtcbiAgY29uc3QgaW5qZWN0ID0gKHNsaWNlLCBjb25maWcgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlZHVjZXJQYXRoLFxuICAgICAgcmVkdWNlcjogcmVkdWNlclRvSW5qZWN0XG4gICAgfSA9IHNsaWNlO1xuICAgIGNvbnN0IGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF07XG4gICAgaWYgKCFjb25maWcub3ZlcnJpZGVFeGlzdGluZyAmJiBjdXJyZW50UmVkdWNlciAmJiBjdXJyZW50UmVkdWNlciAhPT0gcmVkdWNlclRvSW5qZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBjYWxsZWQgXFxgaW5qZWN0XFxgIHRvIG92ZXJyaWRlIGFscmVhZHktZXhpc3RpbmcgcmVkdWNlciAke3JlZHVjZXJQYXRofSB3aXRob3V0IHNwZWNpZnlpbmcgXFxgb3ZlcnJpZGVFeGlzdGluZzogdHJ1ZVxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbWJpbmVkUmVkdWNlcjtcbiAgICB9XG4gICAgcmVkdWNlck1hcFtyZWR1Y2VyUGF0aF0gPSByZWR1Y2VyVG9JbmplY3Q7XG4gICAgcmVkdWNlciA9IGdldFJlZHVjZXIoKTtcbiAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICB9O1xuICBjb25zdCBzZWxlY3RvciA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gbWFrZVNlbGVjdG9yKHNlbGVjdG9yRm4sIHNlbGVjdFN0YXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlbGVjdG9yMihzdGF0ZSwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yRm4oY3JlYXRlU3RhdGVQcm94eShzZWxlY3RTdGF0ZSA/IHNlbGVjdFN0YXRlKHN0YXRlLCAuLi5hcmdzKSA6IHN0YXRlLCByZWR1Y2VyTWFwKSwgLi4uYXJncyk7XG4gICAgfTtcbiAgfSwge1xuICAgIG9yaWdpbmFsXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihjb21iaW5lZFJlZHVjZXIsIHtcbiAgICBpbmplY3QsXG4gICAgc2VsZWN0b3JcbiAgfSk7XG59XG5cbi8vIHNyYy9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlLnRzXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgcmV0dXJuIGBNaW5pZmllZCBSZWR1eCBUb29sa2l0IGVycm9yICMke2NvZGV9OyB2aXNpdCBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL0Vycm9ycz9jb2RlPSR7Y29kZX0gZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycy4gYDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZHV4LXRvb2xraXQuZGV2ZWxvcG1lbnQuY2pzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcERlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2dldE93blByb3BOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImdldCIsImVudW1lcmFibGUiLCJfX2NvcHlQcm9wcyIsInRvIiwiZnJvbSIsImV4Y2VwdCIsImRlc2MiLCJrZXkiLCJjYWxsIiwiX19yZUV4cG9ydCIsIm1vZCIsInNlY29uZFRhcmdldCIsIl9fdG9Db21tb25KUyIsInZhbHVlIiwic3JjX2V4cG9ydHMiLCJSZWR1Y2VyVHlwZSIsIlNIT1VMRF9BVVRPQkFUQ0giLCJUYXNrQWJvcnRFcnJvciIsIlR1cGxlIiwiYWRkTGlzdGVuZXIiLCJhc3luY1RodW5rQ3JlYXRvciIsImF1dG9CYXRjaEVuaGFuY2VyIiwiYnVpbGRDcmVhdGVTbGljZSIsImNsZWFyQWxsTGlzdGVuZXJzIiwiY29tYmluZVNsaWNlcyIsImNvbmZpZ3VyZVN0b3JlIiwiY3JlYXRlQWN0aW9uIiwiY3JlYXRlQWN0aW9uQ3JlYXRvckludmFyaWFudE1pZGRsZXdhcmUiLCJjcmVhdGVBc3luY1RodW5rIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IiLCJjcmVhdGVEeW5hbWljTWlkZGxld2FyZSIsImNyZWF0ZUVudGl0eUFkYXB0ZXIiLCJjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUiLCJjcmVhdGVOZXh0U3RhdGUiLCJpbXBvcnRfaW1tZXI1IiwicHJvZHVjZSIsImNyZWF0ZVJlZHVjZXIiLCJjcmVhdGVTZWxlY3RvciIsImltcG9ydF9yZXNlbGVjdDIiLCJjcmVhdGVTZWxlY3RvckNyZWF0b3IiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJjcmVhdGVTbGljZSIsImN1cnJlbnQiLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwiZnJlZXplIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNBbGxPZiIsImlzQW55T2YiLCJpc0FzeW5jVGh1bmtBY3Rpb24iLCJpc0RyYWZ0IiwiaXNGbHV4U3RhbmRhcmRBY3Rpb24iLCJpc0ZTQSIsImlzRnVsZmlsbGVkIiwiaXNJbW11dGFibGVEZWZhdWx0IiwiaXNQZW5kaW5nIiwiaXNQbGFpbiIsImlzUmVqZWN0ZWQiLCJpc1JlamVjdGVkV2l0aFZhbHVlIiwibHJ1TWVtb2l6ZSIsIm1pbmlTZXJpYWxpemVFcnJvciIsIm5hbm9pZCIsIm9yaWdpbmFsIiwicHJlcGFyZUF1dG9CYXRjaGVkIiwicmVtb3ZlTGlzdGVuZXIiLCJ1bndyYXBSZXN1bHQiLCJ3ZWFrTWFwTWVtb2l6ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiaW1wb3J0X2ltbWVyIiwiaW1wb3J0X3Jlc2VsZWN0IiwiYXJncyIsImNyZWF0ZVNlbGVjdG9yMiIsImFyZ3MyIiwic2VsZWN0b3IiLCJ3cmFwcGVkU2VsZWN0b3IiLCJyZXN0IiwiYXNzaWduIiwiaW1wb3J0X3JlZHV4NCIsImltcG9ydF9yZWR1eCIsImNvbXBvc2VXaXRoRGV2VG9vbHMiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjb21wb3NlIiwiYXBwbHkiLCJkZXZUb29sc0VuaGFuY2VyIiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyIsIm5vb3AzIiwiaW1wb3J0X3JlZHV4X3RodW5rIiwiaW1wb3J0X3JlZHV4MiIsImhhc01hdGNoRnVuY3Rpb24iLCJ2IiwibWF0Y2giLCJ0eXBlIiwicHJlcGFyZUFjdGlvbiIsImFjdGlvbkNyZWF0b3IiLCJwcmVwYXJlZCIsIkVycm9yIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UiLCJwYXlsb2FkIiwibWV0YSIsImVycm9yIiwidG9TdHJpbmciLCJhY3Rpb24iLCJpc0FjdGlvbiIsImtleXMiLCJldmVyeSIsImlzVmFsaWRLZXkiLCJpbmRleE9mIiwiZ2V0TWVzc2FnZSIsInNwbGl0VHlwZSIsInNwbGl0IiwiYWN0aW9uTmFtZSIsIm9wdGlvbnMiLCJuZXh0IiwiaXNBY3Rpb25DcmVhdG9yMiIsImNvbnNvbGUiLCJ3YXJuIiwiaW1wb3J0X2ltbWVyMiIsImdldFRpbWVNZWFzdXJlVXRpbHMiLCJtYXhEZWxheSIsImZuTmFtZSIsImVsYXBzZWQiLCJtZWFzdXJlVGltZSIsImZuIiwic3RhcnRlZCIsIkRhdGUiLCJub3ciLCJmaW5pc2hlZCIsIndhcm5JZkV4Y2VlZGVkIiwiZmluZCIsIml0ZXJhYmxlIiwiY29tcGFyYXRvciIsImVudHJ5IiwiX1R1cGxlIiwiQXJyYXkiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwic2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uY2F0IiwiYXJyIiwicHJlcGVuZCIsImlzQXJyYXkiLCJmcmVlemVEcmFmdGFibGUiLCJ2YWwiLCJpc0RyYWZ0YWJsZSIsImVtcGxhY2UiLCJtYXAiLCJoYW5kbGVyIiwiaGFzIiwidXBkYXRlIiwic2V0IiwiaW5zZXJ0IiwiaW5zZXJ0ZWQiLCJpc0Zyb3plbiIsInRyYWNrRm9yTXV0YXRpb25zIiwiaXNJbW11dGFibGUiLCJpZ25vcmVQYXRocyIsIm9iaiIsInRyYWNrZWRQcm9wZXJ0aWVzIiwidHJhY2tQcm9wZXJ0aWVzIiwiZGV0ZWN0TXV0YXRpb25zIiwicGF0aCIsImNoZWNrZWRPYmplY3RzIiwiU2V0IiwidHJhY2tlZCIsImFkZCIsImNoaWxkcmVuIiwiY2hpbGRQYXRoIiwiaWdub3JlZFBhdGhzIiwidHJhY2tlZFByb3BlcnR5Iiwic2FtZVBhcmVudFJlZiIsInByZXZPYmoiLCJzYW1lUmVmIiwiTnVtYmVyIiwiaXNOYU4iLCJ3YXNNdXRhdGVkIiwia2V5c1RvRGV0ZWN0IiwiaGFzSWdub3JlZFBhdGhzIiwibmVzdGVkUGF0aCIsImhhc01hdGNoZXMiLCJzb21lIiwiaWdub3JlZCIsIlJlZ0V4cCIsInRlc3QiLCJyZXN1bHQiLCJzdHJpbmdpZnkyIiwic2VyaWFsaXplciIsImluZGVudCIsImRlY3ljbGVyIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldFNlcmlhbGl6ZTIiLCJzdGFjayIsIl8iLCJzbGljZSIsImpvaW4iLCJ0aGlzUG9zIiwic3BsaWNlIiwicHVzaCIsIkluZmluaXR5IiwiZ2V0U2VyaWFsaXplIiwid2FybkFmdGVyIiwidHJhY2siLCJiaW5kIiwiZ2V0U3RhdGUiLCJzdGF0ZSIsInRyYWNrZXIiLCJtZWFzdXJlVXRpbHMiLCJkaXNwYXRjaGVkQWN0aW9uIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UyIiwiaW1wb3J0X3JlZHV4MyIsImlzUGxhaW5PYmplY3QiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJjYWNoZSIsImZvdW5kTmVzdGVkU2VyaWFsaXphYmxlIiwia2V5UGF0aCIsImVudHJpZXMiLCJuZXN0ZWRWYWx1ZSIsImlzTmVzdGVkRnJvemVuIiwidmFsdWVzIiwiaWdub3JlZEFjdGlvbnMiLCJpZ25vcmVkQWN0aW9uUGF0aHMiLCJpZ25vcmVTdGF0ZSIsImlnbm9yZUFjdGlvbnMiLCJkaXNhYmxlQ2FjaGUiLCJXZWFrU2V0Iiwic3RvcmVBUEkiLCJmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlIiwiZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNCb29sZWFuIiwieCIsImJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJnZXREZWZhdWx0TWlkZGxld2FyZSIsInRodW5rIiwiaW1tdXRhYmxlQ2hlY2siLCJzZXJpYWxpemFibGVDaGVjayIsImFjdGlvbkNyZWF0b3JDaGVjayIsIm1pZGRsZXdhcmVBcnJheSIsIndpdGhFeHRyYUFyZ3VtZW50IiwiZXh0cmFBcmd1bWVudCIsImltbXV0YWJsZU9wdGlvbnMiLCJ1bnNoaWZ0Iiwic2VyaWFsaXphYmxlT3B0aW9ucyIsImFjdGlvbkNyZWF0b3JPcHRpb25zIiwiY3JlYXRlUXVldWVXaXRoVGltZXIiLCJ0aW1lb3V0Iiwibm90aWZ5Iiwic2V0VGltZW91dCIsInJBRiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVNaWNyb3Rhc2siLCJxdWV1ZU5vdGlmaWNhdGlvbiIsIm5vdGlmeUxpc3RlbmVycyIsImZvckVhY2giLCJsIiwic3Vic2NyaWJlIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwidW5zdWJzY3JpYmUiLCJkZWxldGUiLCJkaXNwYXRjaCIsImJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImdldERlZmF1bHRFbmhhbmNlcnMiLCJhdXRvQmF0Y2giLCJlbmhhbmNlckFycmF5IiwiSVNfUFJPRFVDVElPTiIsInJlZHVjZXIiLCJtaWRkbGV3YXJlIiwiZGV2VG9vbHMiLCJwcmVsb2FkZWRTdGF0ZSIsImVuaGFuY2VycyIsInJvb3RSZWR1Y2VyIiwiY29tYmluZVJlZHVjZXJzIiwiZmluYWxNaWRkbGV3YXJlIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UzIiwiaXRlbSIsIl9mb3JtYXRQcm9kRXJyb3JNZXNzYWdlNCIsImZpbmFsQ29tcG9zZSIsInRyYWNlIiwiYXBwbHlNaWRkbGV3YXJlIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U1Iiwic3RvcmVFbmhhbmNlcnMiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTYiLCJfZm9ybWF0UHJvZEVycm9yTWVzc2FnZTciLCJpbmNsdWRlcyIsImNvbXBvc2VkRW5oYW5jZXIiLCJjcmVhdGVTdG9yZSIsImltcG9ydF9pbW1lcjMiLCJleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayIsImJ1aWxkZXJDYWxsYmFjayIsImFjdGlvbnNNYXAiLCJhY3Rpb25NYXRjaGVycyIsImRlZmF1bHRDYXNlUmVkdWNlciIsImJ1aWxkZXIiLCJhZGRDYXNlIiwidHlwZU9yQWN0aW9uQ3JlYXRvciIsImFkZE1hdGNoZXIiLCJtYXRjaGVyIiwiYWRkRGVmYXVsdENhc2UiLCJpc1N0YXRlRnVuY3Rpb24iLCJpbml0aWFsU3RhdGUiLCJtYXBPckJ1aWxkZXJDYWxsYmFjayIsImZpbmFsQWN0aW9uTWF0Y2hlcnMiLCJmaW5hbERlZmF1bHRDYXNlUmVkdWNlciIsImdldEluaXRpYWxTdGF0ZSIsImZyb3plbkluaXRpYWxTdGF0ZSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsInVybEFscGhhYmV0Iiwic2l6ZSIsImlkIiwiaSIsIk1hdGgiLCJyYW5kb20iLCJtYXRjaGVzIiwibWF0Y2hlcnMiLCJoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YSIsInZhbGlkU3RhdHVzIiwiaGFzVmFsaWRSZXF1ZXN0SWQiLCJyZXF1ZXN0SWQiLCJoYXNWYWxpZFJlcXVlc3RTdGF0dXMiLCJyZXF1ZXN0U3RhdHVzIiwiaXNBc3luY1RodW5rQXJyYXkiLCJhIiwiYXN5bmNUaHVua3MiLCJhc3luY1RodW5rIiwicGVuZGluZyIsImNvbWJpbmVkTWF0Y2hlciIsInJlamVjdGVkIiwiaGFzRmxhZyIsInJlamVjdGVkV2l0aFZhbHVlIiwiZnVsZmlsbGVkIiwiY29tbW9uUHJvcGVydGllcyIsIlJlamVjdFdpdGhWYWx1ZSIsIkZ1bGZpbGxXaXRoTWV0YSIsInNpbXBsZUVycm9yIiwicHJvcGVydHkiLCJtZXNzYWdlIiwiU3RyaW5nIiwiY3JlYXRlQXN5bmNUaHVuazIiLCJ0eXBlUHJlZml4IiwicGF5bG9hZENyZWF0b3IiLCJhcmciLCJzZXJpYWxpemVFcnJvciIsImFib3J0ZWQiLCJjb25kaXRpb24iLCJleHRyYSIsImlkR2VuZXJhdG9yIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwiYWJvcnRSZWFzb24iLCJhYm9ydCIsInJlYXNvbiIsInByb21pc2UiLCJmaW5hbEFjdGlvbiIsImNvbmRpdGlvblJlc3VsdCIsImlzVGhlbmFibGUiLCJzaWduYWwiLCJhYm9ydGVkUHJvbWlzZSIsIlByb21pc2UiLCJyZWplY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZ2V0UGVuZGluZ01ldGEiLCJyYWNlIiwicmVzb2x2ZSIsInJlamVjdFdpdGhWYWx1ZSIsImZ1bGZpbGxXaXRoVmFsdWUiLCJ0aGVuIiwiZXJyIiwic2tpcERpc3BhdGNoIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJ1bndyYXAiLCJzZXR0bGVkIiwid2l0aFR5cGVzIiwiYXN5bmNUaHVua1N5bWJvbCIsImZvciIsIlJlZHVjZXJUeXBlMiIsImdldFR5cGUiLCJhY3Rpb25LZXkiLCJjcmVhdG9ycyIsImNBVCIsImNyZWF0ZVNsaWNlMiIsInJlZHVjZXJQYXRoIiwicHJvY2VzcyIsInJlZHVjZXJzIiwiYnVpbGRSZWR1Y2VyQ3JlYXRvcnMiLCJyZWR1Y2VyTmFtZXMiLCJjb250ZXh0Iiwic2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSIsImFjdGlvbkNyZWF0b3JzIiwic2xpY2VNYXRjaGVycyIsImNvbnRleHRNZXRob2RzIiwiZXhwb3NlQWN0aW9uIiwibmFtZTIiLCJleHBvc2VDYXNlUmVkdWNlciIsInJlZHVjZXJOYW1lIiwicmVkdWNlckRlZmluaXRpb24iLCJyZWR1Y2VyRGV0YWlscyIsImNyZWF0ZU5vdGF0aW9uIiwiaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbiIsImhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uIiwiaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24iLCJidWlsZFJlZHVjZXIiLCJleHRyYVJlZHVjZXJzIiwiZmluYWxDYXNlUmVkdWNlcnMiLCJzTSIsIm0iLCJzZWxlY3RTZWxmIiwiaW5qZWN0ZWRTZWxlY3RvckNhY2hlIiwiV2Vha01hcCIsIl9yZWR1Y2VyIiwiYWN0aW9ucyIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0b3JDYWNoZSIsInNlbGVjdG9ycyIsIndyYXBTZWxlY3RvciIsInNlbGVjdFNsaWNlIiwic2xpY2VTdGF0ZSIsImluamVjdEludG8iLCJpbmplY3RhYmxlIiwicGF0aE9wdCIsImNvbmZpZyIsInJlZHVjZXJQYXRoMiIsImluamVjdCIsImluamVjdGVkIiwid3JhcHBlciIsInJvb3RTdGF0ZSIsInVud3JhcHBlZCIsIl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUiLCJwcmVwYXJlZFJlZHVjZXIiLCJwcmVwYXJlIiwibWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUiLCJwcmVwYXJlQ2FsbGJhY2siLCJpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uIiwiX2Zvcm1hdFByb2RFcnJvck1lc3NhZ2U4Iiwibm9vcCIsImdldEluaXRpYWxFbnRpdHlTdGF0ZSIsImlkcyIsImVudGl0aWVzIiwiY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSIsImFkZGl0aW9uYWxTdGF0ZSIsImNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkiLCJzZWxlY3RJZHMiLCJzZWxlY3RFbnRpdGllcyIsInNlbGVjdEFsbCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiaW1wb3J0X2ltbWVyNCIsImlzRHJhZnRUeXBlZCIsImNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvciIsIm11dGF0b3IiLCJvcGVyYXRvciIsImNyZWF0ZVN0YXRlT3BlcmF0b3IiLCJvcGVyYXRpb24iLCJpc1BheWxvYWRBY3Rpb25Bcmd1bWVudCIsImFyZzIiLCJydW5NdXRhdG9yIiwic2VsZWN0SWRWYWx1ZSIsImVudGl0eSIsImVuc3VyZUVudGl0aWVzQXJyYXkiLCJzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzIiwibmV3RW50aXRpZXMiLCJhZGRlZCIsInVwZGF0ZWQiLCJjaGFuZ2VzIiwiY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJhZGRPbmVNdXRhYmx5IiwiYWRkTWFueU11dGFibHkiLCJzZXRPbmVNdXRhYmx5Iiwic2V0TWFueU11dGFibHkiLCJzZXRBbGxNdXRhYmx5IiwicmVtb3ZlT25lTXV0YWJseSIsInJlbW92ZU1hbnlNdXRhYmx5IiwiZGlkTXV0YXRlIiwicmVtb3ZlQWxsTXV0YWJseSIsInRha2VOZXdLZXkiLCJvcmlnaW5hbDMiLCJuZXdLZXkiLCJoYXNOZXdLZXkiLCJ1cGRhdGVPbmVNdXRhYmx5IiwidXBkYXRlTWFueU11dGFibHkiLCJ1cGRhdGVzIiwibmV3S2V5cyIsInVwZGF0ZXNQZXJFbnRpdHkiLCJkaWRNdXRhdGVFbnRpdGllcyIsImRpZE11dGF0ZUlkcyIsImUiLCJ1cHNlcnRPbmVNdXRhYmx5IiwidXBzZXJ0TWFueU11dGFibHkiLCJyZW1vdmVBbGwiLCJhZGRPbmUiLCJhZGRNYW55Iiwic2V0T25lIiwic2V0TWFueSIsInNldEFsbCIsInVwZGF0ZU9uZSIsInVwZGF0ZU1hbnkiLCJ1cHNlcnRPbmUiLCJ1cHNlcnRNYW55IiwicmVtb3ZlT25lIiwicmVtb3ZlTWFueSIsImNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlciIsInNvcnQiLCJtb2RlbHMiLCJtb2RlbCIsIm1lcmdlIiwiYXBwbGllZFVwZGF0ZXMiLCJuZXdJZCIsInJlc29ydEVudGl0aWVzIiwiYXJlQXJyYXlzRXF1YWwiLCJiIiwiYWxsRW50aXRpZXMiLCJuZXdTb3J0ZWRJZHMiLCJzb3J0Q29tcGFyZXIiLCJpbnN0YW5jZSIsInN0YXRlRmFjdG9yeSIsInNlbGVjdG9yc0ZhY3RvcnkiLCJzdGF0ZUFkYXB0ZXIiLCJpbXBvcnRfcmVkdXg1IiwiYXNzZXJ0RnVuY3Rpb24iLCJmdW5jIiwiZXhwZWN0ZWQiLCJub29wMiIsImNhdGNoUmVqZWN0aW9uIiwib25FcnJvciIsImNhdGNoIiwiYWRkQWJvcnRTaWduYWxMaXN0ZW5lciIsImFib3J0U2lnbmFsIiwiY2FsbGJhY2siLCJvbmNlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFib3J0Q29udHJvbGxlcldpdGhSZWFzb24iLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInRhc2siLCJsaXN0ZW5lciIsImNvbXBsZXRlZCIsImNhbmNlbGxlZCIsInRhc2tDYW5jZWxsZWQiLCJ0YXNrQ29tcGxldGVkIiwibGlzdGVuZXJDYW5jZWxsZWQiLCJsaXN0ZW5lckNvbXBsZXRlZCIsImNvZGUiLCJ2YWxpZGF0ZUFjdGl2ZSIsInJhY2VXaXRoU2lnbmFsIiwiY2xlYW51cCIsIm5vdGlmeVJlamVjdGlvbiIsImZpbmFsbHkiLCJydW5UYXNrIiwidGFzazIiLCJjbGVhblVwIiwic3RhdHVzIiwiY3JlYXRlUGF1c2UiLCJvdXRwdXQiLCJjcmVhdGVEZWxheSIsInBhdXNlIiwidGltZW91dE1zIiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidHVwbGVQcm9taXNlIiwic3RvcExpc3RlbmluZyIsImVmZmVjdCIsImxpc3RlbmVyQXBpIiwiZ2V0T3JpZ2luYWxTdGF0ZSIsInByb21pc2VzIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJjYW5jZWxBY3RpdmVMaXN0ZW5lcnMiLCJjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSIsImxpc3RlbmVyTWFwIiwiY2xlYXIiLCJzYWZlbHlOb3RpZnlFcnJvciIsImVycm9ySGFuZGxlciIsImVycm9yVG9Ob3RpZnkiLCJlcnJvckluZm8iLCJlcnJvckhhbmRsZXJFcnJvciIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJtaWRkbGV3YXJlT3B0aW9ucyIsIk1hcCIsImluc2VydEVudHJ5IiwiY2FuY2VsT3B0aW9ucyIsImNhbmNlbEFjdGl2ZSIsImV4aXN0aW5nRW50cnkiLCJlbnRyeTIiLCJtYXRjaFByZWRpY2F0ZU9yVHlwZSIsIm5vdGlmeUxpc3RlbmVyIiwiYXBpIiwiaW50ZXJuYWxUYXNrQ29udHJvbGxlciIsImF1dG9Kb2luUHJvbWlzZXMiLCJCb29sZWFuIiwiZm9yayIsInRocm93SWZDYW5jZWxsZWQiLCJsaXN0ZW5lckVycm9yIiwicmFpc2VkQnkiLCJhbGxTZXR0bGVkIiwiY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUiLCJvcmlnaW5hbFN0YXRlIiwiY3VycmVudFN0YXRlIiwibGlzdGVuZXJFbnRyaWVzIiwicnVuTGlzdGVuZXIiLCJwcmVkaWNhdGVFcnJvciIsImNsZWFyTGlzdGVuZXJzIiwiaW1wb3J0X3JlZHV4NiIsImNyZWF0ZU1pZGRsZXdhcmVFbnRyeSIsImFwcGxpZWQiLCJtYXRjaEluc3RhbmNlIiwiaW5zdGFuY2VJZCIsIm1pZGRsZXdhcmVNYXAiLCJ3aXRoTWlkZGxld2FyZSIsIm1pZGRsZXdhcmVzIiwiYWRkTWlkZGxld2FyZSIsImFkZE1pZGRsZXdhcmUyIiwibWlkZGxld2FyZTIiLCJnZXRGaW5hbE1pZGRsZXdhcmUiLCJhcHBsaWVkTWlkZGxld2FyZSIsImlzV2l0aE1pZGRsZXdhcmUiLCJpbXBvcnRfcmVkdXg3IiwiaXNTbGljZUxpa2UiLCJtYXliZVNsaWNlTGlrZSIsImdldFJlZHVjZXJzIiwic2xpY2VzIiwiZmxhdE1hcCIsInNsaWNlT3JNYXAiLCJPUklHSU5BTF9TVEFURSIsImlzU3RhdGVQcm94eSIsInN0YXRlUHJveHlNYXAiLCJjcmVhdGVTdGF0ZVByb3h5IiwicmVkdWNlck1hcCIsIlByb3h5IiwicHJvcCIsInJlY2VpdmVyIiwiUmVmbGVjdCIsInJlZHVjZXJSZXN1bHQiLCJmcm9tRW50cmllcyIsImdldFJlZHVjZXIiLCJjb21iaW5lZFJlZHVjZXIiLCJ3aXRoTGF6eUxvYWRlZFNsaWNlcyIsInJlZHVjZXJUb0luamVjdCIsImN1cnJlbnRSZWR1Y2VyIiwib3ZlcnJpZGVFeGlzdGluZyIsIm1ha2VTZWxlY3RvciIsInNlbGVjdG9yRm4iLCJzZWxlY3RvcjIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/cjs/redux-toolkit.development.cjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReducerType: () => (/* binding */ ReducerType),\n/* harmony export */   SHOULD_AUTOBATCH: () => (/* binding */ SHOULD_AUTOBATCH),\n/* harmony export */   TaskAbortError: () => (/* binding */ TaskAbortError),\n/* harmony export */   Tuple: () => (/* binding */ Tuple),\n/* harmony export */   __DO_NOT_USE__ActionTypes: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.__DO_NOT_USE__ActionTypes),\n/* harmony export */   addListener: () => (/* binding */ addListener),\n/* harmony export */   applyMiddleware: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware),\n/* harmony export */   asyncThunkCreator: () => (/* binding */ asyncThunkCreator),\n/* harmony export */   autoBatchEnhancer: () => (/* binding */ autoBatchEnhancer),\n/* harmony export */   bindActionCreators: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.bindActionCreators),\n/* harmony export */   buildCreateSlice: () => (/* binding */ buildCreateSlice),\n/* harmony export */   clearAllListeners: () => (/* binding */ clearAllListeners),\n/* harmony export */   combineReducers: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers),\n/* harmony export */   combineSlices: () => (/* binding */ combineSlices),\n/* harmony export */   compose: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.compose),\n/* harmony export */   configureStore: () => (/* binding */ configureStore),\n/* harmony export */   createAction: () => (/* binding */ createAction),\n/* harmony export */   createActionCreatorInvariantMiddleware: () => (/* binding */ createActionCreatorInvariantMiddleware),\n/* harmony export */   createAsyncThunk: () => (/* binding */ createAsyncThunk),\n/* harmony export */   createDraftSafeSelector: () => (/* binding */ createDraftSafeSelector),\n/* harmony export */   createDraftSafeSelectorCreator: () => (/* binding */ createDraftSafeSelectorCreator),\n/* harmony export */   createDynamicMiddleware: () => (/* binding */ createDynamicMiddleware),\n/* harmony export */   createEntityAdapter: () => (/* binding */ createEntityAdapter),\n/* harmony export */   createImmutableStateInvariantMiddleware: () => (/* binding */ createImmutableStateInvariantMiddleware),\n/* harmony export */   createListenerMiddleware: () => (/* binding */ createListenerMiddleware),\n/* harmony export */   createNextState: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.produce),\n/* harmony export */   createReducer: () => (/* binding */ createReducer),\n/* harmony export */   createSelector: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelector),\n/* harmony export */   createSelectorCreator: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator),\n/* harmony export */   createSerializableStateInvariantMiddleware: () => (/* binding */ createSerializableStateInvariantMiddleware),\n/* harmony export */   createSlice: () => (/* binding */ createSlice),\n/* harmony export */   createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.createStore),\n/* harmony export */   current: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.current),\n/* harmony export */   findNonSerializableValue: () => (/* binding */ findNonSerializableValue),\n/* harmony export */   formatProdErrorMessage: () => (/* binding */ formatProdErrorMessage),\n/* harmony export */   freeze: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.freeze),\n/* harmony export */   isAction: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isAction),\n/* harmony export */   isActionCreator: () => (/* binding */ isActionCreator),\n/* harmony export */   isAllOf: () => (/* binding */ isAllOf),\n/* harmony export */   isAnyOf: () => (/* binding */ isAnyOf),\n/* harmony export */   isAsyncThunkAction: () => (/* binding */ isAsyncThunkAction),\n/* harmony export */   isDraft: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.isDraft),\n/* harmony export */   isFluxStandardAction: () => (/* binding */ isFSA),\n/* harmony export */   isFulfilled: () => (/* binding */ isFulfilled),\n/* harmony export */   isImmutableDefault: () => (/* binding */ isImmutableDefault),\n/* harmony export */   isPending: () => (/* binding */ isPending),\n/* harmony export */   isPlain: () => (/* binding */ isPlain),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject),\n/* harmony export */   isRejected: () => (/* binding */ isRejected),\n/* harmony export */   isRejectedWithValue: () => (/* binding */ isRejectedWithValue),\n/* harmony export */   legacy_createStore: () => (/* reexport safe */ redux__WEBPACK_IMPORTED_MODULE_0__.legacy_createStore),\n/* harmony export */   lruMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.lruMemoize),\n/* harmony export */   miniSerializeError: () => (/* binding */ miniSerializeError),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   original: () => (/* reexport safe */ immer__WEBPACK_IMPORTED_MODULE_2__.original),\n/* harmony export */   prepareAutoBatched: () => (/* binding */ prepareAutoBatched),\n/* harmony export */   removeListener: () => (/* binding */ removeListener),\n/* harmony export */   unwrapResult: () => (/* binding */ unwrapResult),\n/* harmony export */   weakMapMemoize: () => (/* reexport safe */ reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize)\n/* harmony export */ });\n/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ \"(ssr)/./node_modules/redux/dist/redux.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/immer/dist/immer.mjs\");\n/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! reselect */ \"(ssr)/./node_modules/reselect/dist/reselect.mjs\");\n/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ \"(ssr)/./node_modules/redux-thunk/dist/redux-thunk.mjs\");\n// src/index.ts\n\n\n\n// src/createDraftSafeSelector.ts\n\n\nvar createDraftSafeSelectorCreator = (...args)=>{\n    const createSelector2 = (0,reselect__WEBPACK_IMPORTED_MODULE_1__.createSelectorCreator)(...args);\n    return (...args2)=>{\n        const selector = createSelector2(...args2);\n        const wrappedSelector = (value, ...rest)=>selector((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(value) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.current)(value) : value, ...rest);\n        Object.assign(wrappedSelector, selector);\n        return wrappedSelector;\n    };\n};\nvar createDraftSafeSelector = createDraftSafeSelectorCreator(reselect__WEBPACK_IMPORTED_MODULE_1__.weakMapMemoize);\n// src/configureStore.ts\n\n// src/devtoolsExtension.ts\n\nvar composeWithDevTools =  false ? 0 : function() {\n    if (arguments.length === 0) return void 0;\n    if (typeof arguments[0] === \"object\") return redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    return redux__WEBPACK_IMPORTED_MODULE_0__.compose.apply(null, arguments);\n};\nvar devToolsEnhancer =  false ? 0 : function() {\n    return function(noop3) {\n        return noop3;\n    };\n};\n// src/getDefaultMiddleware.ts\n\n// src/createAction.ts\n\n// src/tsHelpers.ts\nvar hasMatchFunction = (v)=>{\n    return v && typeof v.match === \"function\";\n};\n// src/createAction.ts\nfunction createAction(type, prepareAction) {\n    function actionCreator(...args) {\n        if (prepareAction) {\n            let prepared = prepareAction(...args);\n            if (!prepared) {\n                throw new Error( false ? 0 : \"prepareAction did not return an object\");\n            }\n            return {\n                type,\n                payload: prepared.payload,\n                ...\"meta\" in prepared && {\n                    meta: prepared.meta\n                },\n                ...\"error\" in prepared && {\n                    error: prepared.error\n                }\n            };\n        }\n        return {\n            type,\n            payload: args[0]\n        };\n    }\n    actionCreator.toString = ()=>`${type}`;\n    actionCreator.type = type;\n    actionCreator.match = (action)=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && action.type === type;\n    return actionCreator;\n}\nfunction isActionCreator(action) {\n    return typeof action === \"function\" && \"type\" in action && // hasMatchFunction only wants Matchers but I don't see the point in rewriting it\n    hasMatchFunction(action);\n}\nfunction isFSA(action) {\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action) && Object.keys(action).every(isValidKey);\n}\nfunction isValidKey(key) {\n    return [\n        \"type\",\n        \"payload\",\n        \"error\",\n        \"meta\"\n    ].indexOf(key) > -1;\n}\n// src/actionCreatorInvariantMiddleware.ts\nfunction getMessage(type) {\n    const splitType = type ? `${type}`.split(\"/\") : [];\n    const actionName = splitType[splitType.length - 1] || \"actionCreator\";\n    return `Detected an action creator with type \"${type || \"unknown\"}\" being dispatched. \nMake sure you're calling the action creator before dispatching, i.e. \\`dispatch(${actionName}())\\` instead of \\`dispatch(${actionName})\\`. This is necessary even if the action has no payload.`;\n}\nfunction createActionCreatorInvariantMiddleware(options = {}) {\n    if (false) {}\n    const { isActionCreator: isActionCreator2 = isActionCreator } = options;\n    return ()=>(next)=>(action)=>{\n                if (isActionCreator2(action)) {\n                    console.warn(getMessage(action.type));\n                }\n                return next(action);\n            };\n}\n// src/utils.ts\n\nfunction getTimeMeasureUtils(maxDelay, fnName) {\n    let elapsed = 0;\n    return {\n        measureTime (fn) {\n            const started = Date.now();\n            try {\n                return fn();\n            } finally{\n                const finished = Date.now();\n                elapsed += finished - started;\n            }\n        },\n        warnIfExceeded () {\n            if (elapsed > maxDelay) {\n                console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.`);\n            }\n        }\n    };\n}\nfunction find(iterable, comparator) {\n    for (const entry of iterable){\n        if (comparator(entry)) {\n            return entry;\n        }\n    }\n    return void 0;\n}\nvar Tuple = class _Tuple extends Array {\n    constructor(...items){\n        super(...items);\n        Object.setPrototypeOf(this, _Tuple.prototype);\n    }\n    static get [Symbol.species]() {\n        return _Tuple;\n    }\n    concat(...arr) {\n        return super.concat.apply(this, arr);\n    }\n    prepend(...arr) {\n        if (arr.length === 1 && Array.isArray(arr[0])) {\n            return new _Tuple(...arr[0].concat(this));\n        }\n        return new _Tuple(...arr.concat(this));\n    }\n};\nfunction freezeDraftable(val) {\n    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(val) ? (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(val, ()=>{}) : val;\n}\nfunction emplace(map, key, handler) {\n    if (map.has(key)) {\n        let value = map.get(key);\n        if (handler.update) {\n            value = handler.update(value, key, map);\n            map.set(key, value);\n        }\n        return value;\n    }\n    if (!handler.insert) throw new Error( false ? 0 : \"No insert provided for key not already in map\");\n    const inserted = handler.insert(key, map);\n    map.set(key, inserted);\n    return inserted;\n}\n// src/immutableStateInvariantMiddleware.ts\nfunction isImmutableDefault(value) {\n    return typeof value !== \"object\" || value == null || Object.isFrozen(value);\n}\nfunction trackForMutations(isImmutable, ignorePaths, obj) {\n    const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);\n    return {\n        detectMutations () {\n            return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);\n        }\n    };\n}\nfunction trackProperties(isImmutable, ignorePaths = [], obj, path = \"\", checkedObjects = /* @__PURE__ */ new Set()) {\n    const tracked = {\n        value: obj\n    };\n    if (!isImmutable(obj) && !checkedObjects.has(obj)) {\n        checkedObjects.add(obj);\n        tracked.children = {};\n        for(const key in obj){\n            const childPath = path ? path + \".\" + key : key;\n            if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) {\n                continue;\n            }\n            tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);\n        }\n    }\n    return tracked;\n}\nfunction detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path = \"\") {\n    const prevObj = trackedProperty ? trackedProperty.value : void 0;\n    const sameRef = prevObj === obj;\n    if (sameParentRef && !sameRef && !Number.isNaN(obj)) {\n        return {\n            wasMutated: true,\n            path\n        };\n    }\n    if (isImmutable(prevObj) || isImmutable(obj)) {\n        return {\n            wasMutated: false\n        };\n    }\n    const keysToDetect = {};\n    for(let key in trackedProperty.children){\n        keysToDetect[key] = true;\n    }\n    for(let key in obj){\n        keysToDetect[key] = true;\n    }\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for(let key in keysToDetect){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);\n        if (result.wasMutated) {\n            return result;\n        }\n    }\n    return {\n        wasMutated: false\n    };\n}\nfunction createImmutableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        let stringify2 = function(obj, serializer, indent, decycler) {\n            return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);\n        }, getSerialize2 = function(serializer, decycler) {\n            let stack = [], keys = [];\n            if (!decycler) decycler = function(_, value) {\n                if (stack[0] === value) return \"[Circular ~]\";\n                return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\";\n            };\n            return function(key, value) {\n                if (stack.length > 0) {\n                    var thisPos = stack.indexOf(this);\n                    ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);\n                    ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);\n                    if (~stack.indexOf(value)) value = decycler.call(this, key, value);\n                } else stack.push(value);\n                return serializer == null ? value : serializer.call(this, key, value);\n            };\n        };\n        var stringify = stringify2, getSerialize = getSerialize2;\n        let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options;\n        const track = trackForMutations.bind(null, isImmutable, ignoredPaths);\n        return ({ getState })=>{\n            let state = getState();\n            let tracker = track(state);\n            let result;\n            return (next)=>(action)=>{\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"ImmutableStateInvariantMiddleware\");\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected between dispatches, in the path '${result.path || \"\"}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    const dispatchedAction = next(action);\n                    measureUtils.measureTime(()=>{\n                        state = getState();\n                        result = tracker.detectMutations();\n                        tracker = track(state);\n                        if (result.wasMutated) {\n                            throw new Error( false ? 0 : `A state mutation was detected inside a dispatch, in the path: ${result.path || \"\"}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);\n                        }\n                    });\n                    measureUtils.warnIfExceeded();\n                    return dispatchedAction;\n                };\n        };\n    }\n}\n// src/serializableStateInvariantMiddleware.ts\n\nfunction isPlain(val) {\n    const type = typeof val;\n    return val == null || type === \"string\" || type === \"boolean\" || type === \"number\" || Array.isArray(val) || (0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(val);\n}\nfunction findNonSerializableValue(value, path = \"\", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {\n    let foundNestedSerializable;\n    if (!isSerializable(value)) {\n        return {\n            keyPath: path || \"<root>\",\n            value\n        };\n    }\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    if (cache?.has(value)) return false;\n    const entries = getEntries != null ? getEntries(value) : Object.entries(value);\n    const hasIgnoredPaths = ignoredPaths.length > 0;\n    for (const [key, nestedValue] of entries){\n        const nestedPath = path ? path + \".\" + key : key;\n        if (hasIgnoredPaths) {\n            const hasMatches = ignoredPaths.some((ignored)=>{\n                if (ignored instanceof RegExp) {\n                    return ignored.test(nestedPath);\n                }\n                return nestedPath === ignored;\n            });\n            if (hasMatches) {\n                continue;\n            }\n        }\n        if (!isSerializable(nestedValue)) {\n            return {\n                keyPath: nestedPath,\n                value: nestedValue\n            };\n        }\n        if (typeof nestedValue === \"object\") {\n            foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);\n            if (foundNestedSerializable) {\n                return foundNestedSerializable;\n            }\n        }\n    }\n    if (cache && isNestedFrozen(value)) cache.add(value);\n    return false;\n}\nfunction isNestedFrozen(value) {\n    if (!Object.isFrozen(value)) return false;\n    for (const nestedValue of Object.values(value)){\n        if (typeof nestedValue !== \"object\" || nestedValue === null) continue;\n        if (!isNestedFrozen(nestedValue)) return false;\n    }\n    return true;\n}\nfunction createSerializableStateInvariantMiddleware(options = {}) {\n    if (false) {} else {\n        const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = [\n            \"meta.arg\",\n            \"meta.baseQueryMeta\"\n        ], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options;\n        const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;\n        return (storeAPI)=>(next)=>(action)=>{\n                    if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                        return next(action);\n                    }\n                    const result = next(action);\n                    const measureUtils = getTimeMeasureUtils(warnAfter, \"SerializableStateInvariantMiddleware\");\n                    if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) {\n                        measureUtils.measureTime(()=>{\n                            const foundActionNonSerializableValue = findNonSerializableValue(action, \"\", isSerializable, getEntries, ignoredActionPaths, cache);\n                            if (foundActionNonSerializableValue) {\n                                const { keyPath, value } = foundActionNonSerializableValue;\n                                console.error(`A non-serializable value was detected in an action, in the path: \\`${keyPath}\\`. Value:`, value, \"\\nTake a look at the logic that dispatched this action: \", action, \"\\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)\", \"\\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)\");\n                            }\n                        });\n                    }\n                    if (!ignoreState) {\n                        measureUtils.measureTime(()=>{\n                            const state = storeAPI.getState();\n                            const foundStateNonSerializableValue = findNonSerializableValue(state, \"\", isSerializable, getEntries, ignoredPaths, cache);\n                            if (foundStateNonSerializableValue) {\n                                const { keyPath, value } = foundStateNonSerializableValue;\n                                console.error(`A non-serializable value was detected in the state, in the path: \\`${keyPath}\\`. Value:`, value, `\nTake a look at the reducer(s) handling this action type: ${action.type}.\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);\n                            }\n                        });\n                        measureUtils.warnIfExceeded();\n                    }\n                    return result;\n                };\n    }\n}\n// src/getDefaultMiddleware.ts\nfunction isBoolean(x) {\n    return typeof x === \"boolean\";\n}\nvar buildGetDefaultMiddleware = ()=>function getDefaultMiddleware(options) {\n        const { thunk = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options ?? {};\n        let middlewareArray = new Tuple();\n        if (thunk) {\n            if (isBoolean(thunk)) {\n                middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__.thunk);\n            } else {\n                middlewareArray.push((0,redux_thunk__WEBPACK_IMPORTED_MODULE_3__.withExtraArgument)(thunk.extraArgument));\n            }\n        }\n        if (true) {\n            if (immutableCheck) {\n                let immutableOptions = {};\n                if (!isBoolean(immutableCheck)) {\n                    immutableOptions = immutableCheck;\n                }\n                middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));\n            }\n            if (serializableCheck) {\n                let serializableOptions = {};\n                if (!isBoolean(serializableCheck)) {\n                    serializableOptions = serializableCheck;\n                }\n                middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));\n            }\n            if (actionCreatorCheck) {\n                let actionCreatorOptions = {};\n                if (!isBoolean(actionCreatorCheck)) {\n                    actionCreatorOptions = actionCreatorCheck;\n                }\n                middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));\n            }\n        }\n        return middlewareArray;\n    };\n// src/autoBatchEnhancer.ts\nvar SHOULD_AUTOBATCH = \"RTK_autoBatch\";\nvar prepareAutoBatched = ()=>(payload)=>({\n            payload,\n            meta: {\n                [SHOULD_AUTOBATCH]: true\n            }\n        });\nvar createQueueWithTimer = (timeout)=>{\n    return (notify)=>{\n        setTimeout(notify, timeout);\n    };\n};\nvar rAF =  false ? 0 : createQueueWithTimer(10);\nvar autoBatchEnhancer = (options = {\n    type: \"raf\"\n})=>(next)=>(...args)=>{\n            const store = next(...args);\n            let notifying = true;\n            let shouldNotifyAtEndOfTick = false;\n            let notificationQueued = false;\n            const listeners = /* @__PURE__ */ new Set();\n            const queueCallback = options.type === \"tick\" ? queueMicrotask : options.type === \"raf\" ? rAF : options.type === \"callback\" ? options.queueNotification : createQueueWithTimer(options.timeout);\n            const notifyListeners = ()=>{\n                notificationQueued = false;\n                if (shouldNotifyAtEndOfTick) {\n                    shouldNotifyAtEndOfTick = false;\n                    listeners.forEach((l)=>l());\n                }\n            };\n            return Object.assign({}, store, {\n                // Override the base `store.subscribe` method to keep original listeners\n                // from running if we're delaying notifications\n                subscribe (listener2) {\n                    const wrappedListener = ()=>notifying && listener2();\n                    const unsubscribe = store.subscribe(wrappedListener);\n                    listeners.add(listener2);\n                    return ()=>{\n                        unsubscribe();\n                        listeners.delete(listener2);\n                    };\n                },\n                // Override the base `store.dispatch` method so that we can check actions\n                // for the `shouldAutoBatch` flag and determine if batching is active\n                dispatch (action) {\n                    try {\n                        notifying = !action?.meta?.[SHOULD_AUTOBATCH];\n                        shouldNotifyAtEndOfTick = !notifying;\n                        if (shouldNotifyAtEndOfTick) {\n                            if (!notificationQueued) {\n                                notificationQueued = true;\n                                queueCallback(notifyListeners);\n                            }\n                        }\n                        return store.dispatch(action);\n                    } finally{\n                        notifying = true;\n                    }\n                }\n            });\n        };\n// src/getDefaultEnhancers.ts\nvar buildGetDefaultEnhancers = (middlewareEnhancer)=>function getDefaultEnhancers(options) {\n        const { autoBatch = true } = options ?? {};\n        let enhancerArray = new Tuple(middlewareEnhancer);\n        if (autoBatch) {\n            enhancerArray.push(autoBatchEnhancer(typeof autoBatch === \"object\" ? autoBatch : void 0));\n        }\n        return enhancerArray;\n    };\n// src/configureStore.ts\nvar IS_PRODUCTION = \"development\" === \"production\";\nfunction configureStore(options) {\n    const getDefaultMiddleware = buildGetDefaultMiddleware();\n    const { reducer = void 0, middleware, devTools = true, preloadedState = void 0, enhancers = void 0 } = options || {};\n    let rootReducer;\n    if (typeof reducer === \"function\") {\n        rootReducer = reducer;\n    } else if ((0,redux__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(reducer)) {\n        rootReducer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducer);\n    } else {\n        throw new Error( false ? 0 : \"`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers\");\n    }\n    if (!IS_PRODUCTION && middleware && typeof middleware !== \"function\") {\n        throw new Error( false ? 0 : \"`middleware` field must be a callback\");\n    }\n    let finalMiddleware;\n    if (typeof middleware === \"function\") {\n        finalMiddleware = middleware(getDefaultMiddleware);\n        if (!IS_PRODUCTION && !Array.isArray(finalMiddleware)) {\n            throw new Error( false ? 0 : \"when using a middleware builder function, an array of middleware must be returned\");\n        }\n    } else {\n        finalMiddleware = getDefaultMiddleware();\n    }\n    if (!IS_PRODUCTION && finalMiddleware.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each middleware provided to configureStore must be a function\");\n    }\n    let finalCompose = redux__WEBPACK_IMPORTED_MODULE_0__.compose;\n    if (devTools) {\n        finalCompose = composeWithDevTools({\n            // Enable capture of stack traces for dispatched Redux actions\n            trace: !IS_PRODUCTION,\n            ...typeof devTools === \"object\" && devTools\n        });\n    }\n    const middlewareEnhancer = (0,redux__WEBPACK_IMPORTED_MODULE_0__.applyMiddleware)(...finalMiddleware);\n    const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);\n    if (!IS_PRODUCTION && enhancers && typeof enhancers !== \"function\") {\n        throw new Error( false ? 0 : \"`enhancers` field must be a callback\");\n    }\n    let storeEnhancers = typeof enhancers === \"function\" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();\n    if (!IS_PRODUCTION && !Array.isArray(storeEnhancers)) {\n        throw new Error( false ? 0 : \"`enhancers` callback must return an array\");\n    }\n    if (!IS_PRODUCTION && storeEnhancers.some((item)=>typeof item !== \"function\")) {\n        throw new Error( false ? 0 : \"each enhancer provided to configureStore must be a function\");\n    }\n    if (!IS_PRODUCTION && finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) {\n        console.error(\"middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`\");\n    }\n    const composedEnhancer = finalCompose(...storeEnhancers);\n    return (0,redux__WEBPACK_IMPORTED_MODULE_0__.createStore)(rootReducer, preloadedState, composedEnhancer);\n}\n// src/createReducer.ts\n\n// src/mapBuilders.ts\nfunction executeReducerBuilderCallback(builderCallback) {\n    const actionsMap = {};\n    const actionMatchers = [];\n    let defaultCaseReducer;\n    const builder = {\n        addCase (typeOrActionCreator, reducer) {\n            if (true) {\n                if (actionMatchers.length > 0) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addMatcher`\");\n                }\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addCase` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n            if (!type) {\n                throw new Error( false ? 0 : \"`builder.addCase` cannot be called with an empty action type\");\n            }\n            if (type in actionsMap) {\n                throw new Error( false ? 0 : `\\`builder.addCase\\` cannot be called with two reducers for the same action type '${type}'`);\n            }\n            actionsMap[type] = reducer;\n            return builder;\n        },\n        addMatcher (matcher, reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addMatcher` should only be called before calling `builder.addDefaultCase`\");\n                }\n            }\n            actionMatchers.push({\n                matcher,\n                reducer\n            });\n            return builder;\n        },\n        addDefaultCase (reducer) {\n            if (true) {\n                if (defaultCaseReducer) {\n                    throw new Error( false ? 0 : \"`builder.addDefaultCase` can only be called once\");\n                }\n            }\n            defaultCaseReducer = reducer;\n            return builder;\n        }\n    };\n    builderCallback(builder);\n    return [\n        actionsMap,\n        actionMatchers,\n        defaultCaseReducer\n    ];\n}\n// src/createReducer.ts\nfunction isStateFunction(x) {\n    return typeof x === \"function\";\n}\nfunction createReducer(initialState, mapOrBuilderCallback) {\n    if (true) {\n        if (typeof mapOrBuilderCallback === \"object\") {\n            throw new Error( false ? 0 : \"The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer\");\n        }\n    }\n    let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);\n    let getInitialState;\n    if (isStateFunction(initialState)) {\n        getInitialState = ()=>freezeDraftable(initialState());\n    } else {\n        const frozenInitialState = freezeDraftable(initialState);\n        getInitialState = ()=>frozenInitialState;\n    }\n    function reducer(state = getInitialState(), action) {\n        let caseReducers = [\n            actionsMap[action.type],\n            ...finalActionMatchers.filter(({ matcher })=>matcher(action)).map(({ reducer: reducer2 })=>reducer2)\n        ];\n        if (caseReducers.filter((cr)=>!!cr).length === 0) {\n            caseReducers = [\n                finalDefaultCaseReducer\n            ];\n        }\n        return caseReducers.reduce((previousState, caseReducer)=>{\n            if (caseReducer) {\n                if ((0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraft)(previousState)) {\n                    const draft = previousState;\n                    const result = caseReducer(draft, action);\n                    if (result === void 0) {\n                        return previousState;\n                    }\n                    return result;\n                } else if (!(0,immer__WEBPACK_IMPORTED_MODULE_2__.isDraftable)(previousState)) {\n                    const result = caseReducer(previousState, action);\n                    if (result === void 0) {\n                        if (previousState === null) {\n                            return previousState;\n                        }\n                        throw new Error( false ? 0 : \"A case reducer on a non-draftable value must not return undefined\");\n                    }\n                    return result;\n                } else {\n                    return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(previousState, (draft)=>{\n                        return caseReducer(draft, action);\n                    });\n                }\n            }\n            return previousState;\n        }, state);\n    }\n    reducer.getInitialState = getInitialState;\n    return reducer;\n}\n// src/nanoid.ts\nvar urlAlphabet = \"ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW\";\nvar nanoid = (size = 21)=>{\n    let id = \"\";\n    let i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/matchers.ts\nvar matches = (matcher, action)=>{\n    if (hasMatchFunction(matcher)) {\n        return matcher.match(action);\n    } else {\n        return matcher(action);\n    }\n};\nfunction isAnyOf(...matchers) {\n    return (action)=>{\n        return matchers.some((matcher)=>matches(matcher, action));\n    };\n}\nfunction isAllOf(...matchers) {\n    return (action)=>{\n        return matchers.every((matcher)=>matches(matcher, action));\n    };\n}\nfunction hasExpectedRequestMetadata(action, validStatus) {\n    if (!action || !action.meta) return false;\n    const hasValidRequestId = typeof action.meta.requestId === \"string\";\n    const hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;\n    return hasValidRequestId && hasValidRequestStatus;\n}\nfunction isAsyncThunkArray(a) {\n    return typeof a[0] === \"function\" && \"pending\" in a[0] && \"fulfilled\" in a[0] && \"rejected\" in a[0];\n}\nfunction isPending(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isPending()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.pending);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejected(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejected()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.rejected);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isRejectedWithValue(...asyncThunks) {\n    const hasFlag = (action)=>{\n        return action && action.meta && action.meta.rejectedWithValue;\n    };\n    if (asyncThunks.length === 0) {\n        return (action)=>{\n            const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n            return combinedMatcher(action);\n        };\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isRejectedWithValue()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const combinedMatcher = isAllOf(isRejected(...asyncThunks), hasFlag);\n        return combinedMatcher(action);\n    };\n}\nfunction isFulfilled(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"fulfilled\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isFulfilled()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = asyncThunks.map((asyncThunk)=>asyncThunk.fulfilled);\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\nfunction isAsyncThunkAction(...asyncThunks) {\n    if (asyncThunks.length === 0) {\n        return (action)=>hasExpectedRequestMetadata(action, [\n                \"pending\",\n                \"fulfilled\",\n                \"rejected\"\n            ]);\n    }\n    if (!isAsyncThunkArray(asyncThunks)) {\n        return isAsyncThunkAction()(asyncThunks[0]);\n    }\n    return (action)=>{\n        const matchers = [];\n        for (const asyncThunk of asyncThunks){\n            matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);\n        }\n        const combinedMatcher = isAnyOf(...matchers);\n        return combinedMatcher(action);\n    };\n}\n// src/createAsyncThunk.ts\nvar commonProperties = [\n    \"name\",\n    \"message\",\n    \"stack\",\n    \"code\"\n];\nvar RejectWithValue = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar FulfillWithMeta = class {\n    constructor(payload, meta){\n        this.payload = payload;\n        this.meta = meta;\n    }\n};\nvar miniSerializeError = (value)=>{\n    if (typeof value === \"object\" && value !== null) {\n        const simpleError = {};\n        for (const property of commonProperties){\n            if (typeof value[property] === \"string\") {\n                simpleError[property] = value[property];\n            }\n        }\n        return simpleError;\n    }\n    return {\n        message: String(value)\n    };\n};\nvar createAsyncThunk = /* @__PURE__ */ (()=>{\n    function createAsyncThunk2(typePrefix, payloadCreator, options) {\n        const fulfilled = createAction(typePrefix + \"/fulfilled\", (payload, requestId, arg, meta)=>({\n                payload,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"fulfilled\"\n                }\n            }));\n        const pending = createAction(typePrefix + \"/pending\", (requestId, arg, meta)=>({\n                payload: void 0,\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    requestStatus: \"pending\"\n                }\n            }));\n        const rejected = createAction(typePrefix + \"/rejected\", (error, requestId, arg, payload, meta)=>({\n                payload,\n                error: (options && options.serializeError || miniSerializeError)(error || \"Rejected\"),\n                meta: {\n                    ...meta || {},\n                    arg,\n                    requestId,\n                    rejectedWithValue: !!payload,\n                    requestStatus: \"rejected\",\n                    aborted: error?.name === \"AbortError\",\n                    condition: error?.name === \"ConditionError\"\n                }\n            }));\n        function actionCreator(arg) {\n            return (dispatch, getState, extra)=>{\n                const requestId = options?.idGenerator ? options.idGenerator(arg) : nanoid();\n                const abortController = new AbortController();\n                let abortReason;\n                function abort(reason) {\n                    abortReason = reason;\n                    abortController.abort();\n                }\n                const promise = async function() {\n                    let finalAction;\n                    try {\n                        let conditionResult = options?.condition?.(arg, {\n                            getState,\n                            extra\n                        });\n                        if (isThenable(conditionResult)) {\n                            conditionResult = await conditionResult;\n                        }\n                        if (conditionResult === false || abortController.signal.aborted) {\n                            throw {\n                                name: \"ConditionError\",\n                                message: \"Aborted due to condition callback returning false.\"\n                            };\n                        }\n                        const abortedPromise = new Promise((_, reject)=>abortController.signal.addEventListener(\"abort\", ()=>reject({\n                                    name: \"AbortError\",\n                                    message: abortReason || \"Aborted\"\n                                })));\n                        dispatch(pending(requestId, arg, options?.getPendingMeta?.({\n                            requestId,\n                            arg\n                        }, {\n                            getState,\n                            extra\n                        })));\n                        finalAction = await Promise.race([\n                            abortedPromise,\n                            Promise.resolve(payloadCreator(arg, {\n                                dispatch,\n                                getState,\n                                extra,\n                                requestId,\n                                signal: abortController.signal,\n                                abort,\n                                rejectWithValue: (value, meta)=>{\n                                    return new RejectWithValue(value, meta);\n                                },\n                                fulfillWithValue: (value, meta)=>{\n                                    return new FulfillWithMeta(value, meta);\n                                }\n                            })).then((result)=>{\n                                if (result instanceof RejectWithValue) {\n                                    throw result;\n                                }\n                                if (result instanceof FulfillWithMeta) {\n                                    return fulfilled(result.payload, requestId, arg, result.meta);\n                                }\n                                return fulfilled(result, requestId, arg);\n                            })\n                        ]);\n                    } catch (err) {\n                        finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);\n                    }\n                    const skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;\n                    if (!skipDispatch) {\n                        dispatch(finalAction);\n                    }\n                    return finalAction;\n                }();\n                return Object.assign(promise, {\n                    abort,\n                    requestId,\n                    arg,\n                    unwrap () {\n                        return promise.then(unwrapResult);\n                    }\n                });\n            };\n        }\n        return Object.assign(actionCreator, {\n            pending,\n            rejected,\n            fulfilled,\n            settled: isAnyOf(rejected, fulfilled),\n            typePrefix\n        });\n    }\n    createAsyncThunk2.withTypes = ()=>createAsyncThunk2;\n    return createAsyncThunk2;\n})();\nfunction unwrapResult(action) {\n    if (action.meta && action.meta.rejectedWithValue) {\n        throw action.payload;\n    }\n    if (action.error) {\n        throw action.error;\n    }\n    return action.payload;\n}\nfunction isThenable(value) {\n    return value !== null && typeof value === \"object\" && typeof value.then === \"function\";\n}\n// src/createSlice.ts\nvar asyncThunkSymbol = Symbol.for(\"rtk-slice-createasyncthunk\");\nvar asyncThunkCreator = {\n    [asyncThunkSymbol]: createAsyncThunk\n};\nvar ReducerType = /* @__PURE__ */ ((ReducerType2)=>{\n    ReducerType2[\"reducer\"] = \"reducer\";\n    ReducerType2[\"reducerWithPrepare\"] = \"reducerWithPrepare\";\n    ReducerType2[\"asyncThunk\"] = \"asyncThunk\";\n    return ReducerType2;\n})(ReducerType || {});\nfunction getType(slice, actionKey) {\n    return `${slice}/${actionKey}`;\n}\nfunction buildCreateSlice({ creators } = {}) {\n    const cAT = creators?.asyncThunk?.[asyncThunkSymbol];\n    return function createSlice2(options) {\n        const { name, reducerPath = name } = options;\n        if (!name) {\n            throw new Error( false ? 0 : \"`name` is a required option for createSlice\");\n        }\n        if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n            if (options.initialState === void 0) {\n                console.error(\"You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`\");\n            }\n        }\n        const reducers = (typeof options.reducers === \"function\" ? options.reducers(buildReducerCreators()) : options.reducers) || {};\n        const reducerNames = Object.keys(reducers);\n        const context = {\n            sliceCaseReducersByName: {},\n            sliceCaseReducersByType: {},\n            actionCreators: {},\n            sliceMatchers: []\n        };\n        const contextMethods = {\n            addCase (typeOrActionCreator, reducer) {\n                const type = typeof typeOrActionCreator === \"string\" ? typeOrActionCreator : typeOrActionCreator.type;\n                if (!type) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with an empty action type\");\n                }\n                if (type in context.sliceCaseReducersByType) {\n                    throw new Error( false ? 0 : \"`context.addCase` cannot be called with two reducers for the same action type: \" + type);\n                }\n                context.sliceCaseReducersByType[type] = reducer;\n                return contextMethods;\n            },\n            addMatcher (matcher, reducer) {\n                context.sliceMatchers.push({\n                    matcher,\n                    reducer\n                });\n                return contextMethods;\n            },\n            exposeAction (name2, actionCreator) {\n                context.actionCreators[name2] = actionCreator;\n                return contextMethods;\n            },\n            exposeCaseReducer (name2, reducer) {\n                context.sliceCaseReducersByName[name2] = reducer;\n                return contextMethods;\n            }\n        };\n        reducerNames.forEach((reducerName)=>{\n            const reducerDefinition = reducers[reducerName];\n            const reducerDetails = {\n                reducerName,\n                type: getType(name, reducerName),\n                createNotation: typeof options.reducers === \"function\"\n            };\n            if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) {\n                handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);\n            } else {\n                handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);\n            }\n        });\n        function buildReducer() {\n            if (true) {\n                if (typeof options.extraReducers === \"object\") {\n                    throw new Error( false ? 0 : \"The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice\");\n                }\n            }\n            const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options.extraReducers === \"function\" ? executeReducerBuilderCallback(options.extraReducers) : [\n                options.extraReducers\n            ];\n            const finalCaseReducers = {\n                ...extraReducers,\n                ...context.sliceCaseReducersByType\n            };\n            return createReducer(options.initialState, (builder)=>{\n                for(let key in finalCaseReducers){\n                    builder.addCase(key, finalCaseReducers[key]);\n                }\n                for (let sM of context.sliceMatchers){\n                    builder.addMatcher(sM.matcher, sM.reducer);\n                }\n                for (let m of actionMatchers){\n                    builder.addMatcher(m.matcher, m.reducer);\n                }\n                if (defaultCaseReducer) {\n                    builder.addDefaultCase(defaultCaseReducer);\n                }\n            });\n        }\n        const selectSelf = (state)=>state;\n        const injectedSelectorCache = /* @__PURE__ */ new WeakMap();\n        let _reducer;\n        const slice = {\n            name,\n            reducerPath,\n            reducer (state, action) {\n                if (!_reducer) _reducer = buildReducer();\n                return _reducer(state, action);\n            },\n            actions: context.actionCreators,\n            caseReducers: context.sliceCaseReducersByName,\n            getInitialState () {\n                if (!_reducer) _reducer = buildReducer();\n                return _reducer.getInitialState();\n            },\n            getSelectors (selectState = selectSelf) {\n                const selectorCache = emplace(injectedSelectorCache, this, {\n                    insert: ()=>/* @__PURE__ */ new WeakMap()\n                });\n                return emplace(selectorCache, selectState, {\n                    insert: ()=>{\n                        const map = {};\n                        for (const [name2, selector] of Object.entries(options.selectors ?? {})){\n                            map[name2] = wrapSelector(this, selector, selectState, this !== slice);\n                        }\n                        return map;\n                    }\n                });\n            },\n            selectSlice (state) {\n                let sliceState = state[this.reducerPath];\n                if (typeof sliceState === \"undefined\") {\n                    if (this !== slice) {\n                        sliceState = this.getInitialState();\n                    } else if (true) {\n                        throw new Error( false ? 0 : \"selectSlice returned undefined for an uninjected slice reducer\");\n                    }\n                }\n                return sliceState;\n            },\n            get selectors () {\n                return this.getSelectors(this.selectSlice);\n            },\n            injectInto (injectable, { reducerPath: pathOpt, ...config } = {}) {\n                const reducerPath2 = pathOpt ?? this.reducerPath;\n                injectable.inject({\n                    reducerPath: reducerPath2,\n                    reducer: this.reducer\n                }, config);\n                return {\n                    ...this,\n                    reducerPath: reducerPath2\n                };\n            }\n        };\n        return slice;\n    };\n}\nfunction wrapSelector(slice, selector, selectState, injected) {\n    function wrapper(rootState, ...args) {\n        let sliceState = selectState.call(slice, rootState);\n        if (typeof sliceState === \"undefined\") {\n            if (injected) {\n                sliceState = slice.getInitialState();\n            } else if (true) {\n                throw new Error( false ? 0 : \"selectState returned undefined for an uninjected slice reducer\");\n            }\n        }\n        return selector(sliceState, ...args);\n    }\n    wrapper.unwrapped = selector;\n    return wrapper;\n}\nvar createSlice = buildCreateSlice();\nfunction buildReducerCreators() {\n    function asyncThunk(payloadCreator, config) {\n        return {\n            _reducerDefinitionType: \"asyncThunk\" /* asyncThunk */ ,\n            payloadCreator,\n            ...config\n        };\n    }\n    asyncThunk.withTypes = ()=>asyncThunk;\n    return {\n        reducer (caseReducer) {\n            return Object.assign({\n                // hack so the wrapping function has the same name as the original\n                // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original\n                [caseReducer.name] (...args) {\n                    return caseReducer(...args);\n                }\n            }[caseReducer.name], {\n                _reducerDefinitionType: \"reducer\" /* reducer */ \n            });\n        },\n        preparedReducer (prepare, reducer) {\n            return {\n                _reducerDefinitionType: \"reducerWithPrepare\" /* reducerWithPrepare */ ,\n                prepare,\n                reducer\n            };\n        },\n        asyncThunk\n    };\n}\nfunction handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {\n    let caseReducer;\n    let prepareCallback;\n    if (\"reducer\" in maybeReducerWithPrepare) {\n        if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) {\n            throw new Error( false ? 0 : \"Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.\");\n        }\n        caseReducer = maybeReducerWithPrepare.reducer;\n        prepareCallback = maybeReducerWithPrepare.prepare;\n    } else {\n        caseReducer = maybeReducerWithPrepare;\n    }\n    context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));\n}\nfunction isAsyncThunkSliceReducerDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"asyncThunk\" /* asyncThunk */ ;\n}\nfunction isCaseReducerWithPrepareDefinition(reducerDefinition) {\n    return reducerDefinition._reducerDefinitionType === \"reducerWithPrepare\" /* reducerWithPrepare */ ;\n}\nfunction handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {\n    if (!cAT) {\n        throw new Error( false ? 0 : \"Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.\");\n    }\n    const { payloadCreator, fulfilled, pending, rejected, settled, options } = reducerDefinition;\n    const thunk = cAT(type, payloadCreator, options);\n    context.exposeAction(reducerName, thunk);\n    if (fulfilled) {\n        context.addCase(thunk.fulfilled, fulfilled);\n    }\n    if (pending) {\n        context.addCase(thunk.pending, pending);\n    }\n    if (rejected) {\n        context.addCase(thunk.rejected, rejected);\n    }\n    if (settled) {\n        context.addMatcher(thunk.settled, settled);\n    }\n    context.exposeCaseReducer(reducerName, {\n        fulfilled: fulfilled || noop,\n        pending: pending || noop,\n        rejected: rejected || noop,\n        settled: settled || noop\n    });\n}\nfunction noop() {}\n// src/entities/entity_state.ts\nfunction getInitialEntityState() {\n    return {\n        ids: [],\n        entities: {}\n    };\n}\nfunction createInitialStateFactory() {\n    function getInitialState(additionalState = {}) {\n        return Object.assign(getInitialEntityState(), additionalState);\n    }\n    return {\n        getInitialState\n    };\n}\n// src/entities/state_selectors.ts\nfunction createSelectorsFactory() {\n    function getSelectors(selectState, options = {}) {\n        const { createSelector: createSelector2 = createDraftSafeSelector } = options;\n        const selectIds = (state)=>state.ids;\n        const selectEntities = (state)=>state.entities;\n        const selectAll = createSelector2(selectIds, selectEntities, (ids, entities)=>ids.map((id)=>entities[id]));\n        const selectId = (_, id)=>id;\n        const selectById = (entities, id)=>entities[id];\n        const selectTotal = createSelector2(selectIds, (ids)=>ids.length);\n        if (!selectState) {\n            return {\n                selectIds,\n                selectEntities,\n                selectAll,\n                selectTotal,\n                selectById: createSelector2(selectEntities, selectId, selectById)\n            };\n        }\n        const selectGlobalizedEntities = createSelector2(selectState, selectEntities);\n        return {\n            selectIds: createSelector2(selectState, selectIds),\n            selectEntities: selectGlobalizedEntities,\n            selectAll: createSelector2(selectState, selectAll),\n            selectTotal: createSelector2(selectState, selectTotal),\n            selectById: createSelector2(selectGlobalizedEntities, selectId, selectById)\n        };\n    }\n    return {\n        getSelectors\n    };\n}\n// src/entities/state_adapter.ts\n\nvar isDraftTyped = immer__WEBPACK_IMPORTED_MODULE_2__.isDraft;\nfunction createSingleArgumentStateOperator(mutator) {\n    const operator = createStateOperator((_, state)=>mutator(state));\n    return function operation(state) {\n        return operator(state, void 0);\n    };\n}\nfunction createStateOperator(mutator) {\n    return function operation(state, arg) {\n        function isPayloadActionArgument(arg2) {\n            return isFSA(arg2);\n        }\n        const runMutator = (draft)=>{\n            if (isPayloadActionArgument(arg)) {\n                mutator(arg.payload, draft);\n            } else {\n                mutator(arg, draft);\n            }\n        };\n        if (isDraftTyped(state)) {\n            runMutator(state);\n            return state;\n        }\n        return (0,immer__WEBPACK_IMPORTED_MODULE_2__.produce)(state, runMutator);\n    };\n}\n// src/entities/utils.ts\nfunction selectIdValue(entity, selectId) {\n    const key = selectId(entity);\n    if ( true && key === void 0) {\n        console.warn(\"The entity passed to the `selectId` implementation returned undefined.\", \"You should probably provide your own `selectId` implementation.\", \"The entity that was passed:\", entity, \"The `selectId` implementation:\", selectId.toString());\n    }\n    return key;\n}\nfunction ensureEntitiesArray(entities) {\n    if (!Array.isArray(entities)) {\n        entities = Object.values(entities);\n    }\n    return entities;\n}\nfunction splitAddedUpdatedEntities(newEntities, selectId, state) {\n    newEntities = ensureEntitiesArray(newEntities);\n    const added = [];\n    const updated = [];\n    for (const entity of newEntities){\n        const id = selectIdValue(entity, selectId);\n        if (id in state.entities) {\n            updated.push({\n                id,\n                changes: entity\n            });\n        } else {\n            added.push(entity);\n        }\n    }\n    return [\n        added,\n        updated\n    ];\n}\n// src/entities/unsorted_state_adapter.ts\nfunction createUnsortedStateAdapter(selectId) {\n    function addOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (key in state.entities) {\n            return;\n        }\n        state.ids.push(key);\n        state.entities[key] = entity;\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            addOneMutably(entity, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        const key = selectIdValue(entity, selectId);\n        if (!(key in state.entities)) {\n            state.ids.push(key);\n        }\n        state.entities[key] = entity;\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        for (const entity of newEntities){\n            setOneMutably(entity, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.ids = [];\n        state.entities = {};\n        addManyMutably(newEntities, state);\n    }\n    function removeOneMutably(key, state) {\n        return removeManyMutably([\n            key\n        ], state);\n    }\n    function removeManyMutably(keys, state) {\n        let didMutate = false;\n        keys.forEach((key)=>{\n            if (key in state.entities) {\n                delete state.entities[key];\n                didMutate = true;\n            }\n        });\n        if (didMutate) {\n            state.ids = state.ids.filter((id)=>id in state.entities);\n        }\n    }\n    function removeAllMutably(state) {\n        Object.assign(state, {\n            ids: [],\n            entities: {}\n        });\n    }\n    function takeNewKey(keys, update, state) {\n        const original3 = state.entities[update.id];\n        if (original3 === void 0) {\n            return false;\n        }\n        const updated = Object.assign({}, original3, update.changes);\n        const newKey = selectIdValue(updated, selectId);\n        const hasNewKey = newKey !== update.id;\n        if (hasNewKey) {\n            keys[update.id] = newKey;\n            delete state.entities[update.id];\n        }\n        state.entities[newKey] = updated;\n        return hasNewKey;\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        const newKeys = {};\n        const updatesPerEntity = {};\n        updates.forEach((update)=>{\n            if (update.id in state.entities) {\n                updatesPerEntity[update.id] = {\n                    id: update.id,\n                    // Spreads ignore falsy values, so this works even if there isn't\n                    // an existing update already at this key\n                    changes: {\n                        ...updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null,\n                        ...update.changes\n                    }\n                };\n            }\n        });\n        updates = Object.values(updatesPerEntity);\n        const didMutateEntities = updates.length > 0;\n        if (didMutateEntities) {\n            const didMutateIds = updates.filter((update)=>takeNewKey(newKeys, update, state)).length > 0;\n            if (didMutateIds) {\n                state.ids = Object.values(state.entities).map((e)=>selectIdValue(e, selectId));\n            }\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    return {\n        removeAll: createSingleArgumentStateOperator(removeAllMutably),\n        addOne: createStateOperator(addOneMutably),\n        addMany: createStateOperator(addManyMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        upsertMany: createStateOperator(upsertManyMutably),\n        removeOne: createStateOperator(removeOneMutably),\n        removeMany: createStateOperator(removeManyMutably)\n    };\n}\n// src/entities/sorted_state_adapter.ts\nfunction createSortedStateAdapter(selectId, sort) {\n    const { removeOne, removeMany, removeAll } = createUnsortedStateAdapter(selectId);\n    function addOneMutably(entity, state) {\n        return addManyMutably([\n            entity\n        ], state);\n    }\n    function addManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        const models = newEntities.filter((model)=>!(selectIdValue(model, selectId) in state.entities));\n        if (models.length !== 0) {\n            merge(models, state);\n        }\n    }\n    function setOneMutably(entity, state) {\n        return setManyMutably([\n            entity\n        ], state);\n    }\n    function setManyMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        if (newEntities.length !== 0) {\n            merge(newEntities, state);\n        }\n    }\n    function setAllMutably(newEntities, state) {\n        newEntities = ensureEntitiesArray(newEntities);\n        state.entities = {};\n        state.ids = [];\n        addManyMutably(newEntities, state);\n    }\n    function updateOneMutably(update, state) {\n        return updateManyMutably([\n            update\n        ], state);\n    }\n    function updateManyMutably(updates, state) {\n        let appliedUpdates = false;\n        for (let update of updates){\n            const entity = state.entities[update.id];\n            if (!entity) {\n                continue;\n            }\n            appliedUpdates = true;\n            Object.assign(entity, update.changes);\n            const newId = selectId(entity);\n            if (update.id !== newId) {\n                delete state.entities[update.id];\n                state.entities[newId] = entity;\n            }\n        }\n        if (appliedUpdates) {\n            resortEntities(state);\n        }\n    }\n    function upsertOneMutably(entity, state) {\n        return upsertManyMutably([\n            entity\n        ], state);\n    }\n    function upsertManyMutably(newEntities, state) {\n        const [added, updated] = splitAddedUpdatedEntities(newEntities, selectId, state);\n        updateManyMutably(updated, state);\n        addManyMutably(added, state);\n    }\n    function areArraysEqual(a, b) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length && i < b.length; i++){\n            if (a[i] === b[i]) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    function merge(models, state) {\n        models.forEach((model)=>{\n            state.entities[selectId(model)] = model;\n        });\n        resortEntities(state);\n    }\n    function resortEntities(state) {\n        const allEntities = Object.values(state.entities);\n        allEntities.sort(sort);\n        const newSortedIds = allEntities.map(selectId);\n        const { ids } = state;\n        if (!areArraysEqual(ids, newSortedIds)) {\n            state.ids = newSortedIds;\n        }\n    }\n    return {\n        removeOne,\n        removeMany,\n        removeAll,\n        addOne: createStateOperator(addOneMutably),\n        updateOne: createStateOperator(updateOneMutably),\n        upsertOne: createStateOperator(upsertOneMutably),\n        setOne: createStateOperator(setOneMutably),\n        setMany: createStateOperator(setManyMutably),\n        setAll: createStateOperator(setAllMutably),\n        addMany: createStateOperator(addManyMutably),\n        updateMany: createStateOperator(updateManyMutably),\n        upsertMany: createStateOperator(upsertManyMutably)\n    };\n}\n// src/entities/create_adapter.ts\nfunction createEntityAdapter(options = {}) {\n    const { selectId, sortComparer } = {\n        sortComparer: false,\n        selectId: (instance)=>instance.id,\n        ...options\n    };\n    const stateFactory = createInitialStateFactory();\n    const selectorsFactory = createSelectorsFactory();\n    const stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);\n    return {\n        selectId,\n        sortComparer,\n        ...stateFactory,\n        ...selectorsFactory,\n        ...stateAdapter\n    };\n}\n// src/listenerMiddleware/index.ts\n\n// src/listenerMiddleware/utils.ts\nvar assertFunction = (func, expected)=>{\n    if (typeof func !== \"function\") {\n        throw new Error( false ? 0 : `${expected} is not a function`);\n    }\n};\nvar noop2 = ()=>{};\nvar catchRejection = (promise, onError = noop2)=>{\n    promise.catch(onError);\n    return promise;\n};\nvar addAbortSignalListener = (abortSignal, callback)=>{\n    abortSignal.addEventListener(\"abort\", callback, {\n        once: true\n    });\n    return ()=>abortSignal.removeEventListener(\"abort\", callback);\n};\nvar abortControllerWithReason = (abortController, reason)=>{\n    const signal = abortController.signal;\n    if (signal.aborted) {\n        return;\n    }\n    if (!(\"reason\" in signal)) {\n        Object.defineProperty(signal, \"reason\", {\n            enumerable: true,\n            value: reason,\n            configurable: true,\n            writable: true\n        });\n    }\n    ;\n    abortController.abort(reason);\n};\n// src/listenerMiddleware/exceptions.ts\nvar task = \"task\";\nvar listener = \"listener\";\nvar completed = \"completed\";\nvar cancelled = \"cancelled\";\nvar taskCancelled = `task-${cancelled}`;\nvar taskCompleted = `task-${completed}`;\nvar listenerCancelled = `${listener}-${cancelled}`;\nvar listenerCompleted = `${listener}-${completed}`;\nvar TaskAbortError = class {\n    constructor(code){\n        this.name = \"TaskAbortError\";\n        this.code = code;\n        this.message = `${task} ${cancelled} (reason: ${code})`;\n    }\n};\n// src/listenerMiddleware/task.ts\nvar validateActive = (signal)=>{\n    if (signal.aborted) {\n        const { reason } = signal;\n        throw new TaskAbortError(reason);\n    }\n};\nfunction raceWithSignal(signal, promise) {\n    let cleanup = noop2;\n    return new Promise((resolve, reject)=>{\n        const notifyRejection = ()=>reject(new TaskAbortError(signal.reason));\n        if (signal.aborted) {\n            notifyRejection();\n            return;\n        }\n        cleanup = addAbortSignalListener(signal, notifyRejection);\n        promise.finally(()=>cleanup()).then(resolve, reject);\n    }).finally(()=>{\n        cleanup = noop2;\n    });\n}\nvar runTask = async (task2, cleanUp)=>{\n    try {\n        await Promise.resolve();\n        const value = await task2();\n        return {\n            status: \"ok\",\n            value\n        };\n    } catch (error) {\n        return {\n            status: error instanceof TaskAbortError ? \"cancelled\" : \"rejected\",\n            error\n        };\n    } finally{\n        cleanUp?.();\n    }\n};\nvar createPause = (signal)=>{\n    return (promise)=>{\n        return catchRejection(raceWithSignal(signal, promise).then((output)=>{\n            validateActive(signal);\n            return output;\n        }));\n    };\n};\nvar createDelay = (signal)=>{\n    const pause = createPause(signal);\n    return (timeoutMs)=>{\n        return pause(new Promise((resolve)=>setTimeout(resolve, timeoutMs)));\n    };\n};\n// src/listenerMiddleware/index.ts\nvar { assign } = Object;\nvar INTERNAL_NIL_TOKEN = {};\nvar alm = \"listenerMiddleware\";\nvar createFork = (parentAbortSignal, parentBlockingPromises)=>{\n    const linkControllers = (controller)=>addAbortSignalListener(parentAbortSignal, ()=>abortControllerWithReason(controller, parentAbortSignal.reason));\n    return (taskExecutor, opts)=>{\n        assertFunction(taskExecutor, \"taskExecutor\");\n        const childAbortController = new AbortController();\n        linkControllers(childAbortController);\n        const result = runTask(async ()=>{\n            validateActive(parentAbortSignal);\n            validateActive(childAbortController.signal);\n            const result2 = await taskExecutor({\n                pause: createPause(childAbortController.signal),\n                delay: createDelay(childAbortController.signal),\n                signal: childAbortController.signal\n            });\n            validateActive(childAbortController.signal);\n            return result2;\n        }, ()=>abortControllerWithReason(childAbortController, taskCompleted));\n        if (opts?.autoJoin) {\n            parentBlockingPromises.push(result);\n        }\n        return {\n            result: createPause(parentAbortSignal)(result),\n            cancel () {\n                abortControllerWithReason(childAbortController, taskCancelled);\n            }\n        };\n    };\n};\nvar createTakePattern = (startListening, signal)=>{\n    const take = async (predicate, timeout)=>{\n        validateActive(signal);\n        let unsubscribe = ()=>{};\n        const tuplePromise = new Promise((resolve, reject)=>{\n            let stopListening = startListening({\n                predicate,\n                effect: (action, listenerApi)=>{\n                    listenerApi.unsubscribe();\n                    resolve([\n                        action,\n                        listenerApi.getState(),\n                        listenerApi.getOriginalState()\n                    ]);\n                }\n            });\n            unsubscribe = ()=>{\n                stopListening();\n                reject();\n            };\n        });\n        const promises = [\n            tuplePromise\n        ];\n        if (timeout != null) {\n            promises.push(new Promise((resolve)=>setTimeout(resolve, timeout, null)));\n        }\n        try {\n            const output = await raceWithSignal(signal, Promise.race(promises));\n            validateActive(signal);\n            return output;\n        } finally{\n            unsubscribe();\n        }\n    };\n    return (predicate, timeout)=>catchRejection(take(predicate, timeout));\n};\nvar getListenerEntryPropsFrom = (options)=>{\n    let { type, actionCreator, matcher, predicate, effect } = options;\n    if (type) {\n        predicate = createAction(type).match;\n    } else if (actionCreator) {\n        type = actionCreator.type;\n        predicate = actionCreator.match;\n    } else if (matcher) {\n        predicate = matcher;\n    } else if (predicate) {} else {\n        throw new Error( false ? 0 : \"Creating or removing a listener requires one of the known fields for matching an action\");\n    }\n    assertFunction(effect, \"options.listener\");\n    return {\n        predicate,\n        type,\n        effect\n    };\n};\nvar createListenerEntry = (options)=>{\n    const { type, predicate, effect } = getListenerEntryPropsFrom(options);\n    const id = nanoid();\n    const entry = {\n        id,\n        effect,\n        type,\n        predicate,\n        pending: /* @__PURE__ */ new Set(),\n        unsubscribe: ()=>{\n            throw new Error( false ? 0 : \"Unsubscribe not initialized\");\n        }\n    };\n    return entry;\n};\nvar cancelActiveListeners = (entry)=>{\n    entry.pending.forEach((controller)=>{\n        abortControllerWithReason(controller, listenerCancelled);\n    });\n};\nvar createClearListenerMiddleware = (listenerMap)=>{\n    return ()=>{\n        listenerMap.forEach(cancelActiveListeners);\n        listenerMap.clear();\n    };\n};\nvar safelyNotifyError = (errorHandler, errorToNotify, errorInfo)=>{\n    try {\n        errorHandler(errorToNotify, errorInfo);\n    } catch (errorHandlerError) {\n        setTimeout(()=>{\n            throw errorHandlerError;\n        }, 0);\n    }\n};\nvar addListener = createAction(`${alm}/add`);\nvar clearAllListeners = createAction(`${alm}/removeAll`);\nvar removeListener = createAction(`${alm}/remove`);\nvar defaultErrorHandler = (...args)=>{\n    console.error(`${alm}/error`, ...args);\n};\nfunction createListenerMiddleware(middlewareOptions = {}) {\n    const listenerMap = /* @__PURE__ */ new Map();\n    const { extra, onError = defaultErrorHandler } = middlewareOptions;\n    assertFunction(onError, \"onError\");\n    const insertEntry = (entry)=>{\n        entry.unsubscribe = ()=>listenerMap.delete(entry.id);\n        listenerMap.set(entry.id, entry);\n        return (cancelOptions)=>{\n            entry.unsubscribe();\n            if (cancelOptions?.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        };\n    };\n    const startListening = (options)=>{\n        let entry = find(Array.from(listenerMap.values()), (existingEntry)=>existingEntry.effect === options.effect);\n        if (!entry) {\n            entry = createListenerEntry(options);\n        }\n        return insertEntry(entry);\n    };\n    const stopListening = (options)=>{\n        const { type, effect, predicate } = getListenerEntryPropsFrom(options);\n        const entry = find(Array.from(listenerMap.values()), (entry2)=>{\n            const matchPredicateOrType = typeof type === \"string\" ? entry2.type === type : entry2.predicate === predicate;\n            return matchPredicateOrType && entry2.effect === effect;\n        });\n        if (entry) {\n            entry.unsubscribe();\n            if (options.cancelActive) {\n                cancelActiveListeners(entry);\n            }\n        }\n        return !!entry;\n    };\n    const notifyListener = async (entry, action, api, getOriginalState)=>{\n        const internalTaskController = new AbortController();\n        const take = createTakePattern(startListening, internalTaskController.signal);\n        const autoJoinPromises = [];\n        try {\n            entry.pending.add(internalTaskController);\n            await Promise.resolve(entry.effect(action, // Use assign() rather than ... to avoid extra helper functions added to bundle\n            assign({}, api, {\n                getOriginalState,\n                condition: (predicate, timeout)=>take(predicate, timeout).then(Boolean),\n                take,\n                delay: createDelay(internalTaskController.signal),\n                pause: createPause(internalTaskController.signal),\n                extra,\n                signal: internalTaskController.signal,\n                fork: createFork(internalTaskController.signal, autoJoinPromises),\n                unsubscribe: entry.unsubscribe,\n                subscribe: ()=>{\n                    listenerMap.set(entry.id, entry);\n                },\n                cancelActiveListeners: ()=>{\n                    entry.pending.forEach((controller, _, set)=>{\n                        if (controller !== internalTaskController) {\n                            abortControllerWithReason(controller, listenerCancelled);\n                            set.delete(controller);\n                        }\n                    });\n                },\n                cancel: ()=>{\n                    abortControllerWithReason(internalTaskController, listenerCancelled);\n                    entry.pending.delete(internalTaskController);\n                },\n                throwIfCancelled: ()=>{\n                    validateActive(internalTaskController.signal);\n                }\n            })));\n        } catch (listenerError) {\n            if (!(listenerError instanceof TaskAbortError)) {\n                safelyNotifyError(onError, listenerError, {\n                    raisedBy: \"effect\"\n                });\n            }\n        } finally{\n            await Promise.allSettled(autoJoinPromises);\n            abortControllerWithReason(internalTaskController, listenerCompleted);\n            entry.pending.delete(internalTaskController);\n        }\n    };\n    const clearListenerMiddleware = createClearListenerMiddleware(listenerMap);\n    const middleware = (api)=>(next)=>(action)=>{\n                if (!(0,redux__WEBPACK_IMPORTED_MODULE_0__.isAction)(action)) {\n                    return next(action);\n                }\n                if (addListener.match(action)) {\n                    return startListening(action.payload);\n                }\n                if (clearAllListeners.match(action)) {\n                    clearListenerMiddleware();\n                    return;\n                }\n                if (removeListener.match(action)) {\n                    return stopListening(action.payload);\n                }\n                let originalState = api.getState();\n                const getOriginalState = ()=>{\n                    if (originalState === INTERNAL_NIL_TOKEN) {\n                        throw new Error( false ? 0 : `${alm}: getOriginalState can only be called synchronously`);\n                    }\n                    return originalState;\n                };\n                let result;\n                try {\n                    result = next(action);\n                    if (listenerMap.size > 0) {\n                        let currentState = api.getState();\n                        const listenerEntries = Array.from(listenerMap.values());\n                        for (let entry of listenerEntries){\n                            let runListener = false;\n                            try {\n                                runListener = entry.predicate(action, currentState, originalState);\n                            } catch (predicateError) {\n                                runListener = false;\n                                safelyNotifyError(onError, predicateError, {\n                                    raisedBy: \"predicate\"\n                                });\n                            }\n                            if (!runListener) {\n                                continue;\n                            }\n                            notifyListener(entry, action, api, getOriginalState);\n                        }\n                    }\n                } finally{\n                    originalState = INTERNAL_NIL_TOKEN;\n                }\n                return result;\n            };\n    return {\n        middleware,\n        startListening,\n        stopListening,\n        clearListeners: clearListenerMiddleware\n    };\n}\n// src/dynamicMiddleware/index.ts\n\nvar createMiddlewareEntry = (middleware)=>({\n        id: nanoid(),\n        middleware,\n        applied: /* @__PURE__ */ new Map()\n    });\nvar matchInstance = (instanceId)=>(action)=>action?.meta?.instanceId === instanceId;\nvar createDynamicMiddleware = ()=>{\n    const instanceId = nanoid();\n    const middlewareMap = /* @__PURE__ */ new Map();\n    const withMiddleware = Object.assign(createAction(\"dynamicMiddleware/add\", (...middlewares)=>({\n            payload: middlewares,\n            meta: {\n                instanceId\n            }\n        })), {\n        withTypes: ()=>withMiddleware\n    });\n    const addMiddleware = Object.assign(function addMiddleware2(...middlewares) {\n        middlewares.forEach((middleware2)=>{\n            let entry = find(Array.from(middlewareMap.values()), (entry2)=>entry2.middleware === middleware2);\n            if (!entry) {\n                entry = createMiddlewareEntry(middleware2);\n            }\n            middlewareMap.set(entry.id, entry);\n        });\n    }, {\n        withTypes: ()=>addMiddleware\n    });\n    const getFinalMiddleware = (api)=>{\n        const appliedMiddleware = Array.from(middlewareMap.values()).map((entry)=>emplace(entry.applied, api, {\n                insert: ()=>entry.middleware(api)\n            }));\n        return (0,redux__WEBPACK_IMPORTED_MODULE_0__.compose)(...appliedMiddleware);\n    };\n    const isWithMiddleware = isAllOf(withMiddleware, matchInstance(instanceId));\n    const middleware = (api)=>(next)=>(action)=>{\n                if (isWithMiddleware(action)) {\n                    addMiddleware(...action.payload);\n                    return api.dispatch;\n                }\n                return getFinalMiddleware(api)(next)(action);\n            };\n    return {\n        middleware,\n        addMiddleware,\n        withMiddleware,\n        instanceId\n    };\n};\n// src/combineSlices.ts\n\nvar isSliceLike = (maybeSliceLike)=>\"reducerPath\" in maybeSliceLike && typeof maybeSliceLike.reducerPath === \"string\";\nvar getReducers = (slices)=>slices.flatMap((sliceOrMap)=>isSliceLike(sliceOrMap) ? [\n            [\n                sliceOrMap.reducerPath,\n                sliceOrMap.reducer\n            ]\n        ] : Object.entries(sliceOrMap));\nvar ORIGINAL_STATE = Symbol.for(\"rtk-state-proxy-original\");\nvar isStateProxy = (value)=>!!value && !!value[ORIGINAL_STATE];\nvar stateProxyMap = /* @__PURE__ */ new WeakMap();\nvar createStateProxy = (state, reducerMap)=>emplace(stateProxyMap, state, {\n        insert: ()=>new Proxy(state, {\n                get: (target, prop, receiver)=>{\n                    if (prop === ORIGINAL_STATE) return target;\n                    const result = Reflect.get(target, prop, receiver);\n                    if (typeof result === \"undefined\") {\n                        const reducer = reducerMap[prop.toString()];\n                        if (reducer) {\n                            const reducerResult = reducer(void 0, {\n                                type: nanoid()\n                            });\n                            if (typeof reducerResult === \"undefined\") {\n                                throw new Error( false ? 0 : `The slice reducer for key \"${prop.toString()}\" returned undefined when called for selector(). If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);\n                            }\n                            return reducerResult;\n                        }\n                    }\n                    return result;\n                }\n            })\n    });\nvar original = (state)=>{\n    if (!isStateProxy(state)) {\n        throw new Error( false ? 0 : \"original must be used on state Proxy\");\n    }\n    return state[ORIGINAL_STATE];\n};\nfunction combineSlices(...slices) {\n    const reducerMap = Object.fromEntries(getReducers(slices));\n    const getReducer = ()=>(0,redux__WEBPACK_IMPORTED_MODULE_0__.combineReducers)(reducerMap);\n    let reducer = getReducer();\n    function combinedReducer(state, action) {\n        return reducer(state, action);\n    }\n    combinedReducer.withLazyLoadedSlices = ()=>combinedReducer;\n    const inject = (slice, config = {})=>{\n        const { reducerPath, reducer: reducerToInject } = slice;\n        const currentReducer = reducerMap[reducerPath];\n        if (!config.overrideExisting && currentReducer && currentReducer !== reducerToInject) {\n            if (typeof process !== \"undefined\" && \"development\" === \"development\") {\n                console.error(`called \\`inject\\` to override already-existing reducer ${reducerPath} without specifying \\`overrideExisting: true\\``);\n            }\n            return combinedReducer;\n        }\n        reducerMap[reducerPath] = reducerToInject;\n        reducer = getReducer();\n        return combinedReducer;\n    };\n    const selector = Object.assign(function makeSelector(selectorFn, selectState) {\n        return function selector2(state, ...args) {\n            return selectorFn(createStateProxy(selectState ? selectState(state, ...args) : state, reducerMap), ...args);\n        };\n    }, {\n        original\n    });\n    return Object.assign(combinedReducer, {\n        inject,\n        selector\n    });\n}\n// src/formatProdErrorMessage.ts\nfunction formatProdErrorMessage(code) {\n    return `Minified Redux Toolkit error #${code}; visit https://redux-toolkit.js.org/Errors?code=${code} for the full message or use the non-minified dev environment for full errors. `;\n}\n //# sourceMappingURL=redux-toolkit.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlZHV4anMvdG9vbGtpdC9kaXN0L3JlZHV4LXRvb2xraXQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ087QUFDbUY7QUFDaUM7QUFFMUksaUNBQWlDO0FBQ1E7QUFDd0I7QUFDakUsSUFBSWMsaUNBQWlDLENBQUMsR0FBR0M7SUFDdkMsTUFBTUMsa0JBQWtCUCwrREFBcUJBLElBQUlNO0lBQ2pELE9BQU8sQ0FBQyxHQUFHRTtRQUNULE1BQU1DLFdBQVdGLG1CQUFtQkM7UUFDcEMsTUFBTUUsa0JBQWtCLENBQUNDLE9BQU8sR0FBR0MsT0FBU0gsU0FBU1osOENBQU9BLENBQUNjLFNBQVNuQiw4Q0FBT0EsQ0FBQ21CLFNBQVNBLFVBQVVDO1FBQ2pHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkQ7UUFDL0IsT0FBT0M7SUFDVDtBQUNGO0FBQ0EsSUFBSUssMEJBQTBCViwrQkFBK0JGLG9EQUFjQTtBQUUzRSx3QkFBd0I7QUFDb0c7QUFFNUgsMkJBQTJCO0FBQ0s7QUFDaEMsSUFBSW9CLHNCQUFzQixNQUE0RSxHQUFHQyxDQUEyQyxHQUFHO0lBQ3JKLElBQUlFLFVBQVVDLE1BQU0sS0FBSyxHQUN2QixPQUFPLEtBQUs7SUFDZCxJQUFJLE9BQU9ELFNBQVMsQ0FBQyxFQUFFLEtBQUssVUFDMUIsT0FBT1IsMENBQU9BO0lBQ2hCLE9BQU9BLDBDQUFPQSxDQUFDVSxLQUFLLENBQUMsTUFBTUY7QUFDN0I7QUFDQSxJQUFJRyxtQkFBbUIsTUFBb0UsR0FBR0wsQ0FBbUMsR0FBRztJQUNsSSxPQUFPLFNBQVNPLEtBQUs7UUFDbkIsT0FBT0E7SUFDVDtBQUNGO0FBRUEsOEJBQThCO0FBQzRDO0FBRTFFLHNCQUFzQjtBQUNXO0FBRWpDLG1CQUFtQjtBQUNuQixJQUFJSyxtQkFBbUIsQ0FBQ0M7SUFD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QUFPa0IsT0FBT0MsTUFBTSxDQUFDZ29CLGlCQUFpQjtRQUNwQ25QO1FBQ0FsWjtJQUNGO0FBQ0Y7QUFFQSxnQ0FBZ0M7QUFDaEMsU0FBU3FDLHVCQUF1QjJlLElBQUk7SUFDbEMsT0FBTyxDQUFDLDhCQUE4QixFQUFFQSxLQUFLLGlEQUFpRCxFQUFFQSxLQUFLLCtFQUErRSxDQUFDO0FBQ3ZMO0FBb0RFLENBQ0YsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90ZW1lLWFwcC8uL25vZGVfbW9kdWxlcy9AcmVkdXhqcy90b29sa2l0L2Rpc3QvcmVkdXgtdG9vbGtpdC5tb2Rlcm4ubWpzP2FkM2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicmVkdXhcIjtcbmltcG9ydCB7IHByb2R1Y2UsIGN1cnJlbnQgYXMgY3VycmVudDIsIGZyZWV6ZSwgb3JpZ2luYWwgYXMgb3JpZ2luYWwyLCBpc0RyYWZ0IGFzIGlzRHJhZnQ0IH0gZnJvbSBcImltbWVyXCI7XG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JDcmVhdG9yIGFzIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcjIsIGxydU1lbW9pemUsIHdlYWtNYXBNZW1vaXplIGFzIHdlYWtNYXBNZW1vaXplMiB9IGZyb20gXCJyZXNlbGVjdFwiO1xuXG4vLyBzcmMvY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IudHNcbmltcG9ydCB7IGN1cnJlbnQsIGlzRHJhZnQgfSBmcm9tIFwiaW1tZXJcIjtcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yQ3JlYXRvciwgd2Vha01hcE1lbW9pemUgfSBmcm9tIFwicmVzZWxlY3RcIjtcbnZhciBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3IgPSAoLi4uYXJncykgPT4ge1xuICBjb25zdCBjcmVhdGVTZWxlY3RvcjIgPSBjcmVhdGVTZWxlY3RvckNyZWF0b3IoLi4uYXJncyk7XG4gIHJldHVybiAoLi4uYXJnczIpID0+IHtcbiAgICBjb25zdCBzZWxlY3RvciA9IGNyZWF0ZVNlbGVjdG9yMiguLi5hcmdzMik7XG4gICAgY29uc3Qgd3JhcHBlZFNlbGVjdG9yID0gKHZhbHVlLCAuLi5yZXN0KSA9PiBzZWxlY3Rvcihpc0RyYWZ0KHZhbHVlKSA/IGN1cnJlbnQodmFsdWUpIDogdmFsdWUsIC4uLnJlc3QpO1xuICAgIE9iamVjdC5hc3NpZ24od3JhcHBlZFNlbGVjdG9yLCBzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHdyYXBwZWRTZWxlY3RvcjtcbiAgfTtcbn07XG52YXIgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IgPSBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvckNyZWF0b3Iod2Vha01hcE1lbW9pemUpO1xuXG4vLyBzcmMvY29uZmlndXJlU3RvcmUudHNcbmltcG9ydCB7IGFwcGx5TWlkZGxld2FyZSwgY3JlYXRlU3RvcmUsIGNvbXBvc2UgYXMgY29tcG9zZTIsIGNvbWJpbmVSZWR1Y2VycywgaXNQbGFpbk9iamVjdCBhcyBpc1BsYWluT2JqZWN0MiB9IGZyb20gXCJyZWR1eFwiO1xuXG4vLyBzcmMvZGV2dG9vbHNFeHRlbnNpb24udHNcbmltcG9ydCB7IGNvbXBvc2UgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBjb21wb3NlV2l0aERldlRvb2xzID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fID8gd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyA6IGZ1bmN0aW9uKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJvYmplY3RcIilcbiAgICByZXR1cm4gY29tcG9zZTtcbiAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn07XG52YXIgZGV2VG9vbHNFbmhhbmNlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Ll9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX18gPyB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXyA6IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZnVuY3Rpb24obm9vcDMpIHtcbiAgICByZXR1cm4gbm9vcDM7XG4gIH07XG59O1xuXG4vLyBzcmMvZ2V0RGVmYXVsdE1pZGRsZXdhcmUudHNcbmltcG9ydCB7IHRodW5rIGFzIHRodW5rTWlkZGxld2FyZSwgd2l0aEV4dHJhQXJndW1lbnQgfSBmcm9tIFwicmVkdXgtdGh1bmtcIjtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuaW1wb3J0IHsgaXNBY3Rpb24gfSBmcm9tIFwicmVkdXhcIjtcblxuLy8gc3JjL3RzSGVscGVycy50c1xudmFyIGhhc01hdGNoRnVuY3Rpb24gPSAodikgPT4ge1xuICByZXR1cm4gdiAmJiB0eXBlb2Ygdi5tYXRjaCA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLy8gc3JjL2NyZWF0ZUFjdGlvbi50c1xuZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVBY3Rpb24pIHtcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzKSB7XG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcbiAgICAgIGxldCBwcmVwYXJlZCA9IHByZXBhcmVBY3Rpb24oLi4uYXJncyk7XG4gICAgICBpZiAoIXByZXBhcmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDApIDogXCJwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBheWxvYWQ6IHByZXBhcmVkLnBheWxvYWQsXG4gICAgICAgIC4uLlwibWV0YVwiIGluIHByZXBhcmVkICYmIHtcbiAgICAgICAgICBtZXRhOiBwcmVwYXJlZC5tZXRhXG4gICAgICAgIH0sXG4gICAgICAgIC4uLlwiZXJyb3JcIiBpbiBwcmVwYXJlZCAmJiB7XG4gICAgICAgICAgZXJyb3I6IHByZXBhcmVkLmVycm9yXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZDogYXJnc1swXVxuICAgIH07XG4gIH1cbiAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9ICgpID0+IGAke3R5cGV9YDtcbiAgYWN0aW9uQ3JlYXRvci50eXBlID0gdHlwZTtcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb24pID0+IGlzQWN0aW9uKGFjdGlvbikgJiYgYWN0aW9uLnR5cGUgPT09IHR5cGU7XG4gIHJldHVybiBhY3Rpb25DcmVhdG9yO1xufVxuZnVuY3Rpb24gaXNBY3Rpb25DcmVhdG9yKGFjdGlvbikge1xuICByZXR1cm4gdHlwZW9mIGFjdGlvbiA9PT0gXCJmdW5jdGlvblwiICYmIFwidHlwZVwiIGluIGFjdGlvbiAmJiAvLyBoYXNNYXRjaEZ1bmN0aW9uIG9ubHkgd2FudHMgTWF0Y2hlcnMgYnV0IEkgZG9uJ3Qgc2VlIHRoZSBwb2ludCBpbiByZXdyaXRpbmcgaXRcbiAgaGFzTWF0Y2hGdW5jdGlvbihhY3Rpb24pO1xufVxuZnVuY3Rpb24gaXNGU0EoYWN0aW9uKSB7XG4gIHJldHVybiBpc0FjdGlvbihhY3Rpb24pICYmIE9iamVjdC5rZXlzKGFjdGlvbikuZXZlcnkoaXNWYWxpZEtleSk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gW1widHlwZVwiLCBcInBheWxvYWRcIiwgXCJlcnJvclwiLCBcIm1ldGFcIl0uaW5kZXhPZihrZXkpID4gLTE7XG59XG5cbi8vIHNyYy9hY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZ2V0TWVzc2FnZSh0eXBlKSB7XG4gIGNvbnN0IHNwbGl0VHlwZSA9IHR5cGUgPyBgJHt0eXBlfWAuc3BsaXQoXCIvXCIpIDogW107XG4gIGNvbnN0IGFjdGlvbk5hbWUgPSBzcGxpdFR5cGVbc3BsaXRUeXBlLmxlbmd0aCAtIDFdIHx8IFwiYWN0aW9uQ3JlYXRvclwiO1xuICByZXR1cm4gYERldGVjdGVkIGFuIGFjdGlvbiBjcmVhdG9yIHdpdGggdHlwZSBcIiR7dHlwZSB8fCBcInVua25vd25cIn1cIiBiZWluZyBkaXNwYXRjaGVkLiBcbk1ha2Ugc3VyZSB5b3UncmUgY2FsbGluZyB0aGUgYWN0aW9uIGNyZWF0b3IgYmVmb3JlIGRpc3BhdGNoaW5nLCBpLmUuIFxcYGRpc3BhdGNoKCR7YWN0aW9uTmFtZX0oKSlcXGAgaW5zdGVhZCBvZiBcXGBkaXNwYXRjaCgke2FjdGlvbk5hbWV9KVxcYC4gVGhpcyBpcyBuZWNlc3NhcnkgZXZlbiBpZiB0aGUgYWN0aW9uIGhhcyBubyBwYXlsb2FkLmA7XG59XG5mdW5jdGlvbiBjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9XG4gIGNvbnN0IHtcbiAgICBpc0FjdGlvbkNyZWF0b3I6IGlzQWN0aW9uQ3JlYXRvcjIgPSBpc0FjdGlvbkNyZWF0b3JcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmIChpc0FjdGlvbkNyZWF0b3IyKGFjdGlvbikpIHtcbiAgICAgIGNvbnNvbGUud2FybihnZXRNZXNzYWdlKGFjdGlvbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gIH07XG59XG5cbi8vIHNyYy91dGlscy50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUsIGlzRHJhZnRhYmxlIH0gZnJvbSBcImltbWVyXCI7XG5mdW5jdGlvbiBnZXRUaW1lTWVhc3VyZVV0aWxzKG1heERlbGF5LCBmbk5hbWUpIHtcbiAgbGV0IGVsYXBzZWQgPSAwO1xuICByZXR1cm4ge1xuICAgIG1lYXN1cmVUaW1lKGZuKSB7XG4gICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29uc3QgZmluaXNoZWQgPSBEYXRlLm5vdygpO1xuICAgICAgICBlbGFwc2VkICs9IGZpbmlzaGVkIC0gc3RhcnRlZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdhcm5JZkV4Y2VlZGVkKCkge1xuICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7Zm5OYW1lfSB0b29rICR7ZWxhcHNlZH1tcywgd2hpY2ggaXMgbW9yZSB0aGFuIHRoZSB3YXJuaW5nIHRocmVzaG9sZCBvZiAke21heERlbGF5fW1zLiBcbklmIHlvdXIgc3RhdGUgb3IgYWN0aW9ucyBhcmUgdmVyeSBsYXJnZSwgeW91IG1heSB3YW50IHRvIGRpc2FibGUgdGhlIG1pZGRsZXdhcmUgYXMgaXQgbWlnaHQgY2F1c2UgdG9vIG11Y2ggb2YgYSBzbG93ZG93biBpbiBkZXZlbG9wbWVudCBtb2RlLiBTZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvZ2V0RGVmYXVsdE1pZGRsZXdhcmUgZm9yIGluc3RydWN0aW9ucy5cbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LmApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmQoaXRlcmFibGUsIGNvbXBhcmF0b3IpIHtcbiAgZm9yIChjb25zdCBlbnRyeSBvZiBpdGVyYWJsZSkge1xuICAgIGlmIChjb21wYXJhdG9yKGVudHJ5KSkge1xuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxudmFyIFR1cGxlID0gY2xhc3MgX1R1cGxlIGV4dGVuZHMgQXJyYXkge1xuICBjb25zdHJ1Y3RvciguLi5pdGVtcykge1xuICAgIHN1cGVyKC4uLml0ZW1zKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1R1cGxlLnByb3RvdHlwZSk7XG4gIH1cbiAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgIHJldHVybiBfVHVwbGU7XG4gIH1cbiAgY29uY2F0KC4uLmFycikge1xuICAgIHJldHVybiBzdXBlci5jb25jYXQuYXBwbHkodGhpcywgYXJyKTtcbiAgfVxuICBwcmVwZW5kKC4uLmFycikge1xuICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xuICAgICAgcmV0dXJuIG5ldyBfVHVwbGUoLi4uYXJyWzBdLmNvbmNhdCh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1R1cGxlKC4uLmFyci5jb25jYXQodGhpcykpO1xuICB9XG59O1xuZnVuY3Rpb24gZnJlZXplRHJhZnRhYmxlKHZhbCkge1xuICByZXR1cm4gaXNEcmFmdGFibGUodmFsKSA/IGNyZWF0ZU5leHRTdGF0ZSh2YWwsICgpID0+IHtcbiAgfSkgOiB2YWw7XG59XG5mdW5jdGlvbiBlbXBsYWNlKG1hcCwga2V5LCBoYW5kbGVyKSB7XG4gIGlmIChtYXAuaGFzKGtleSkpIHtcbiAgICBsZXQgdmFsdWUgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKGhhbmRsZXIudXBkYXRlKSB7XG4gICAgICB2YWx1ZSA9IGhhbmRsZXIudXBkYXRlKHZhbHVlLCBrZXksIG1hcCk7XG4gICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKCFoYW5kbGVyLmluc2VydClcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMCkgOiBcIk5vIGluc2VydCBwcm92aWRlZCBmb3Iga2V5IG5vdCBhbHJlYWR5IGluIG1hcFwiKTtcbiAgY29uc3QgaW5zZXJ0ZWQgPSBoYW5kbGVyLmluc2VydChrZXksIG1hcCk7XG4gIG1hcC5zZXQoa2V5LCBpbnNlcnRlZCk7XG4gIHJldHVybiBpbnNlcnRlZDtcbn1cblxuLy8gc3JjL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZS50c1xuZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCB8fCBPYmplY3QuaXNGcm96ZW4odmFsdWUpO1xufVxuZnVuY3Rpb24gdHJhY2tGb3JNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopIHtcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopO1xuICByZXR1cm4ge1xuICAgIGRldGVjdE11dGF0aW9ucygpIHtcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzID0gW10sIG9iaiwgcGF0aCA9IFwiXCIsIGNoZWNrZWRPYmplY3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBjb25zdCB0cmFja2VkID0ge1xuICAgIHZhbHVlOiBvYmpcbiAgfTtcbiAgaWYgKCFpc0ltbXV0YWJsZShvYmopICYmICFjaGVja2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgIGNoZWNrZWRPYmplY3RzLmFkZChvYmopO1xuICAgIHRyYWNrZWQuY2hpbGRyZW4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoKSAhPT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0cmFja2VkLmNoaWxkcmVuW2tleV0gPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmpba2V5XSwgY2hpbGRQYXRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRyYWNrZWQ7XG59XG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocyA9IFtdLCB0cmFja2VkUHJvcGVydHksIG9iaiwgc2FtZVBhcmVudFJlZiA9IGZhbHNlLCBwYXRoID0gXCJcIikge1xuICBjb25zdCBwcmV2T2JqID0gdHJhY2tlZFByb3BlcnR5ID8gdHJhY2tlZFByb3BlcnR5LnZhbHVlIDogdm9pZCAwO1xuICBjb25zdCBzYW1lUmVmID0gcHJldk9iaiA9PT0gb2JqO1xuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FzTXV0YXRlZDogdHJ1ZSxcbiAgICAgIHBhdGhcbiAgICB9O1xuICB9XG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdhc011dGF0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjb25zdCBrZXlzVG9EZXRlY3QgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikge1xuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZTtcbiAgfVxuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlO1xuICB9XG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwO1xuICBmb3IgKGxldCBrZXkgaW4ga2V5c1RvRGV0ZWN0KSB7XG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGggPyBwYXRoICsgXCIuXCIgKyBrZXkgOiBrZXk7XG4gICAgaWYgKGhhc0lnbm9yZWRQYXRocykge1xuICAgICAgY29uc3QgaGFzTWF0Y2hlcyA9IGlnbm9yZWRQYXRocy5zb21lKChpZ25vcmVkKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVkIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgcmV0dXJuIGlnbm9yZWQudGVzdChuZXN0ZWRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmVzdGVkUGF0aCA9PT0gaWdub3JlZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKGhhc01hdGNoZXMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzLCB0cmFja2VkUHJvcGVydHkuY2hpbGRyZW5ba2V5XSwgb2JqW2tleV0sIHNhbWVSZWYsIG5lc3RlZFBhdGgpO1xuICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3YXNNdXRhdGVkOiBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgcmV0dXJuICgpID0+IChuZXh0KSA9PiAoYWN0aW9uKSA9PiBuZXh0KGFjdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHN0cmluZ2lmeTIgPSBmdW5jdGlvbihvYmosIHNlcmlhbGl6ZXIsIGluZGVudCwgZGVjeWNsZXIpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmosIGdldFNlcmlhbGl6ZTIoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpO1xuICAgIH0sIGdldFNlcmlhbGl6ZTIgPSBmdW5jdGlvbihzZXJpYWxpemVyLCBkZWN5Y2xlcikge1xuICAgICAgbGV0IHN0YWNrID0gW10sIGtleXMgPSBbXTtcbiAgICAgIGlmICghZGVjeWNsZXIpXG4gICAgICAgIGRlY3ljbGVyID0gZnVuY3Rpb24oXywgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoc3RhY2tbMF0gPT09IHZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH5dXCI7XG4gICAgICAgICAgcmV0dXJuIFwiW0NpcmN1bGFyIH4uXCIgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKFwiLlwiKSArIFwiXVwiO1xuICAgICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgfnRoaXNQb3MgPyBzdGFjay5zcGxpY2UodGhpc1BvcyArIDEpIDogc3RhY2sucHVzaCh0aGlzKTtcbiAgICAgICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gZGVjeWNsZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5MiwgZ2V0U2VyaWFsaXplID0gZ2V0U2VyaWFsaXplMjtcbiAgICBsZXQge1xuICAgICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXG4gICAgICBpZ25vcmVkUGF0aHMsXG4gICAgICB3YXJuQWZ0ZXIgPSAzMlxuICAgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKTtcbiAgICByZXR1cm4gKHtcbiAgICAgIGdldFN0YXRlXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIHJldHVybiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKHdhcm5BZnRlciwgXCJJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVcIik7XG4gICAgICAgIG1lYXN1cmVVdGlscy5tZWFzdXJlVGltZSgoKSA9PiB7XG4gICAgICAgICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc3VsdCA9IHRyYWNrZXIuZGV0ZWN0TXV0YXRpb25zKCk7XG4gICAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKTtcbiAgICAgICAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE5KSA6IGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICcke3Jlc3VsdC5wYXRoIHx8IFwiXCJ9Jy4gIFRoaXMgbWF5IGNhdXNlIGluY29ycmVjdCBiZWhhdmlvci4gKGh0dHBzOi8vcmVkdXguanMub3JnL3N0eWxlLWd1aWRlL3N0eWxlLWd1aWRlI2RvLW5vdC1tdXRhdGUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGlzcGF0Y2hlZEFjdGlvbiA9IG5leHQoYWN0aW9uKTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKTtcbiAgICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpO1xuICAgICAgICAgIGlmIChyZXN1bHQud2FzTXV0YXRlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjApIDogYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogJHtyZXN1bHQucGF0aCB8fCBcIlwifS4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiAke3N0cmluZ2lmeTIoYWN0aW9uKX0uIChodHRwczovL3JlZHV4LmpzLm9yZy9zdHlsZS1ndWlkZS9zdHlsZS1ndWlkZSNkby1ub3QtbXV0YXRlLXN0YXRlKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpO1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvbjtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLnRzXG5pbXBvcnQgeyBpc0FjdGlvbiBhcyBpc0FjdGlvbjIsIGlzUGxhaW5PYmplY3QgfSBmcm9tIFwicmVkdXhcIjtcbmZ1bmN0aW9uIGlzUGxhaW4odmFsKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsO1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcImJvb2xlYW5cIiB8fCB0eXBlID09PSBcIm51bWJlclwiIHx8IEFycmF5LmlzQXJyYXkodmFsKSB8fCBpc1BsYWluT2JqZWN0KHZhbCk7XG59XG5mdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUodmFsdWUsIHBhdGggPSBcIlwiLCBpc1NlcmlhbGl6YWJsZSA9IGlzUGxhaW4sIGdldEVudHJpZXMsIGlnbm9yZWRQYXRocyA9IFtdLCBjYWNoZSkge1xuICBsZXQgZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gIGlmICghaXNTZXJpYWxpemFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleVBhdGg6IHBhdGggfHwgXCI8cm9vdD5cIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChjYWNoZT8uaGFzKHZhbHVlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGVudHJpZXMgPSBnZXRFbnRyaWVzICE9IG51bGwgPyBnZXRFbnRyaWVzKHZhbHVlKSA6IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgY29uc3QgaGFzSWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzLmxlbmd0aCA+IDA7XG4gIGZvciAoY29uc3QgW2tleSwgbmVzdGVkVmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBuZXN0ZWRQYXRoID0gcGF0aCA/IHBhdGggKyBcIi5cIiArIGtleSA6IGtleTtcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzKSB7XG4gICAgICBjb25zdCBoYXNNYXRjaGVzID0gaWdub3JlZFBhdGhzLnNvbWUoKGlnbm9yZWQpID0+IHtcbiAgICAgICAgaWYgKGlnbm9yZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICByZXR1cm4gaWdub3JlZC50ZXN0KG5lc3RlZFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXN0ZWRQYXRoID09PSBpZ25vcmVkO1xuICAgICAgfSk7XG4gICAgICBpZiAoaGFzTWF0Y2hlcykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleVBhdGg6IG5lc3RlZFBhdGgsXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm91bmROZXN0ZWRTZXJpYWxpemFibGUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUobmVzdGVkVmFsdWUsIG5lc3RlZFBhdGgsIGlzU2VyaWFsaXphYmxlLCBnZXRFbnRyaWVzLCBpZ25vcmVkUGF0aHMsIGNhY2hlKTtcbiAgICAgIGlmIChmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSkge1xuICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjYWNoZSAmJiBpc05lc3RlZEZyb3plbih2YWx1ZSkpXG4gICAgY2FjaGUuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOZXN0ZWRGcm96ZW4odmFsdWUpIHtcbiAgaWYgKCFPYmplY3QuaXNGcm96ZW4odmFsdWUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBuZXN0ZWRWYWx1ZSBvZiBPYmplY3QudmFsdWVzKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgbmVzdGVkVmFsdWUgPT09IG51bGwpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoIWlzTmVzdGVkRnJvemVuKG5lc3RlZFZhbHVlKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShvcHRpb25zID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiAoKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4gbmV4dChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbixcbiAgICAgIGdldEVudHJpZXMsXG4gICAgICBpZ25vcmVkQWN0aW9ucyA9IFtdLFxuICAgICAgaWdub3JlZEFjdGlvblBhdGhzID0gW1wibWV0YS5hcmdcIiwgXCJtZXRhLmJhc2VRdWVyeU1ldGFcIl0sXG4gICAgICBpZ25vcmVkUGF0aHMgPSBbXSxcbiAgICAgIHdhcm5BZnRlciA9IDMyLFxuICAgICAgaWdub3JlU3RhdGUgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUFjdGlvbnMgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVDYWNoZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY2FjaGUgPSAhZGlzYWJsZUNhY2hlICYmIFdlYWtTZXQgPyAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gKHN0b3JlQVBJKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgICAgaWYgKCFpc0FjdGlvbjIoYWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pO1xuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyh3YXJuQWZ0ZXIsIFwiU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlXCIpO1xuICAgICAgaWYgKCFpZ25vcmVBY3Rpb25zICYmICEoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKGFjdGlvbiwgXCJcIiwgaXNTZXJpYWxpemFibGUsIGdldEVudHJpZXMsIGlnbm9yZWRBY3Rpb25QYXRocywgY2FjaGUpO1xuICAgICAgICAgIGlmIChmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleVBhdGgsXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICB9ID0gZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gYW4gYWN0aW9uLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIFwiXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogXCIsIGFjdGlvbiwgXCJcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKVwiLCBcIlxcbihUbyBhbGxvdyBub24tc2VyaWFsaXphYmxlIHZhbHVlcyBzZWU6IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvdXNhZ2UvdXNhZ2UtZ3VpZGUjd29ya2luZy13aXRoLW5vbi1zZXJpYWxpemFibGUtZGF0YSlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghaWdub3JlU3RhdGUpIHtcbiAgICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKHN0YXRlLCBcIlwiLCBpc1NlcmlhbGl6YWJsZSwgZ2V0RW50cmllcywgaWdub3JlZFBhdGhzLCBjYWNoZSk7XG4gICAgICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCwgdmFsdWUsIGBcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9LlxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVhc3VyZVV0aWxzLndhcm5JZkV4Y2VlZGVkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL2dldERlZmF1bHRNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiYm9vbGVhblwiO1xufVxudmFyIGJ1aWxkR2V0RGVmYXVsdE1pZGRsZXdhcmUgPSAoKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB0aHVuayA9IHRydWUsXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxuICAgIHNlcmlhbGl6YWJsZUNoZWNrID0gdHJ1ZSxcbiAgICBhY3Rpb25DcmVhdG9yQ2hlY2sgPSB0cnVlXG4gIH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgbWlkZGxld2FyZUFycmF5ID0gbmV3IFR1cGxlKCk7XG4gIGlmICh0aHVuaykge1xuICAgIGlmIChpc0Jvb2xlYW4odGh1bmspKSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh0aHVua01pZGRsZXdhcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWRkbGV3YXJlQXJyYXkucHVzaCh3aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KSk7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zID0ge307XG4gICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcbiAgICAgICAgaW1tdXRhYmxlT3B0aW9ucyA9IGltbXV0YWJsZUNoZWNrO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKGltbXV0YWJsZU9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6YWJsZUNoZWNrKSB7XG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XG4gICAgICAgIHNlcmlhbGl6YWJsZU9wdGlvbnMgPSBzZXJpYWxpemFibGVDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKSk7XG4gICAgfVxuICAgIGlmIChhY3Rpb25DcmVhdG9yQ2hlY2spIHtcbiAgICAgIGxldCBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKCFpc0Jvb2xlYW4oYWN0aW9uQ3JlYXRvckNoZWNrKSkge1xuICAgICAgICBhY3Rpb25DcmVhdG9yT3B0aW9ucyA9IGFjdGlvbkNyZWF0b3JDaGVjaztcbiAgICAgIH1cbiAgICAgIG1pZGRsZXdhcmVBcnJheS51bnNoaWZ0KGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlKGFjdGlvbkNyZWF0b3JPcHRpb25zKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaWRkbGV3YXJlQXJyYXk7XG59O1xuXG4vLyBzcmMvYXV0b0JhdGNoRW5oYW5jZXIudHNcbnZhciBTSE9VTERfQVVUT0JBVENIID0gXCJSVEtfYXV0b0JhdGNoXCI7XG52YXIgcHJlcGFyZUF1dG9CYXRjaGVkID0gKCkgPT4gKHBheWxvYWQpID0+ICh7XG4gIHBheWxvYWQsXG4gIG1ldGE6IHtcbiAgICBbU0hPVUxEX0FVVE9CQVRDSF06IHRydWVcbiAgfVxufSk7XG52YXIgY3JlYXRlUXVldWVXaXRoVGltZXIgPSAodGltZW91dCkgPT4ge1xuICByZXR1cm4gKG5vdGlmeSkgPT4ge1xuICAgIHNldFRpbWVvdXQobm90aWZ5LCB0aW1lb3V0KTtcbiAgfTtcbn07XG52YXIgckFGID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKDEwKTtcbnZhciBhdXRvQmF0Y2hFbmhhbmNlciA9IChvcHRpb25zID0ge1xuICB0eXBlOiBcInJhZlwiXG59KSA9PiAobmV4dCkgPT4gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgc3RvcmUgPSBuZXh0KC4uLmFyZ3MpO1xuICBsZXQgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgbGV0IHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gIGxldCBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgcXVldWVDYWxsYmFjayA9IG9wdGlvbnMudHlwZSA9PT0gXCJ0aWNrXCIgPyBxdWV1ZU1pY3JvdGFzayA6IG9wdGlvbnMudHlwZSA9PT0gXCJyYWZcIiA/IHJBRiA6IG9wdGlvbnMudHlwZSA9PT0gXCJjYWxsYmFja1wiID8gb3B0aW9ucy5xdWV1ZU5vdGlmaWNhdGlvbiA6IGNyZWF0ZVF1ZXVlV2l0aFRpbWVyKG9wdGlvbnMudGltZW91dCk7XG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICBub3RpZmljYXRpb25RdWV1ZWQgPSBmYWxzZTtcbiAgICBpZiAoc2hvdWxkTm90aWZ5QXRFbmRPZlRpY2spIHtcbiAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4gbCgpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdG9yZSwge1xuICAgIC8vIE92ZXJyaWRlIHRoZSBiYXNlIGBzdG9yZS5zdWJzY3JpYmVgIG1ldGhvZCB0byBrZWVwIG9yaWdpbmFsIGxpc3RlbmVyc1xuICAgIC8vIGZyb20gcnVubmluZyBpZiB3ZSdyZSBkZWxheWluZyBub3RpZmljYXRpb25zXG4gICAgc3Vic2NyaWJlKGxpc3RlbmVyMikge1xuICAgICAgY29uc3Qgd3JhcHBlZExpc3RlbmVyID0gKCkgPT4gbm90aWZ5aW5nICYmIGxpc3RlbmVyMigpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdG9yZS5zdWJzY3JpYmUod3JhcHBlZExpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIyKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIyKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAvLyBPdmVycmlkZSB0aGUgYmFzZSBgc3RvcmUuZGlzcGF0Y2hgIG1ldGhvZCBzbyB0aGF0IHdlIGNhbiBjaGVjayBhY3Rpb25zXG4gICAgLy8gZm9yIHRoZSBgc2hvdWxkQXV0b0JhdGNoYCBmbGFnIGFuZCBkZXRlcm1pbmUgaWYgYmF0Y2hpbmcgaXMgYWN0aXZlXG4gICAgZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBub3RpZnlpbmcgPSAhYWN0aW9uPy5tZXRhPy5bU0hPVUxEX0FVVE9CQVRDSF07XG4gICAgICAgIHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrID0gIW5vdGlmeWluZztcbiAgICAgICAgaWYgKHNob3VsZE5vdGlmeUF0RW5kT2ZUaWNrKSB7XG4gICAgICAgICAgaWYgKCFub3RpZmljYXRpb25RdWV1ZWQpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlZCA9IHRydWU7XG4gICAgICAgICAgICBxdWV1ZUNhbGxiYWNrKG5vdGlmeUxpc3RlbmVycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbm90aWZ5aW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gc3JjL2dldERlZmF1bHRFbmhhbmNlcnMudHNcbnZhciBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMgPSAobWlkZGxld2FyZUVuaGFuY2VyKSA9PiBmdW5jdGlvbiBnZXREZWZhdWx0RW5oYW5jZXJzKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGF1dG9CYXRjaCA9IHRydWVcbiAgfSA9IG9wdGlvbnMgPz8ge307XG4gIGxldCBlbmhhbmNlckFycmF5ID0gbmV3IFR1cGxlKG1pZGRsZXdhcmVFbmhhbmNlcik7XG4gIGlmIChhdXRvQmF0Y2gpIHtcbiAgICBlbmhhbmNlckFycmF5LnB1c2goYXV0b0JhdGNoRW5oYW5jZXIodHlwZW9mIGF1dG9CYXRjaCA9PT0gXCJvYmplY3RcIiA/IGF1dG9CYXRjaCA6IHZvaWQgMCkpO1xuICB9XG4gIHJldHVybiBlbmhhbmNlckFycmF5O1xufTtcblxuLy8gc3JjL2NvbmZpZ3VyZVN0b3JlLnRzXG52YXIgSVNfUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbmZ1bmN0aW9uIGNvbmZpZ3VyZVN0b3JlKG9wdGlvbnMpIHtcbiAgY29uc3QgZ2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIGNvbnN0IHtcbiAgICByZWR1Y2VyID0gdm9pZCAwLFxuICAgIG1pZGRsZXdhcmUsXG4gICAgZGV2VG9vbHMgPSB0cnVlLFxuICAgIHByZWxvYWRlZFN0YXRlID0gdm9pZCAwLFxuICAgIGVuaGFuY2VycyA9IHZvaWQgMFxuICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgbGV0IHJvb3RSZWR1Y2VyO1xuICBpZiAodHlwZW9mIHJlZHVjZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJvb3RSZWR1Y2VyID0gcmVkdWNlcjtcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0MihyZWR1Y2VyKSkge1xuICAgIHJvb3RSZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHJlZHVjZXIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEpIDogXCJgcmVkdWNlcmAgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnNcIik7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIG1pZGRsZXdhcmUgJiYgdHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIpIDogXCJgbWlkZGxld2FyZWAgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBmaW5hbE1pZGRsZXdhcmU7XG4gIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZmluYWxNaWRkbGV3YXJlID0gbWlkZGxld2FyZShnZXREZWZhdWx0TWlkZGxld2FyZSk7XG4gICAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KGZpbmFsTWlkZGxld2FyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMpIDogXCJ3aGVuIHVzaW5nIGEgbWlkZGxld2FyZSBidWlsZGVyIGZ1bmN0aW9uLCBhbiBhcnJheSBvZiBtaWRkbGV3YXJlIG11c3QgYmUgcmV0dXJuZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZpbmFsTWlkZGxld2FyZSA9IGdldERlZmF1bHRNaWRkbGV3YXJlKCk7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5zb21lKChpdGVtKSA9PiB0eXBlb2YgaXRlbSAhPT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQpIDogXCJlYWNoIG1pZGRsZXdhcmUgcHJvdmlkZWQgdG8gY29uZmlndXJlU3RvcmUgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG4gIGxldCBmaW5hbENvbXBvc2UgPSBjb21wb3NlMjtcbiAgaWYgKGRldlRvb2xzKSB7XG4gICAgZmluYWxDb21wb3NlID0gY29tcG9zZVdpdGhEZXZUb29scyh7XG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xuICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OLFxuICAgICAgLi4udHlwZW9mIGRldlRvb2xzID09PSBcIm9iamVjdFwiICYmIGRldlRvb2xzXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZUVuaGFuY2VyID0gYXBwbHlNaWRkbGV3YXJlKC4uLmZpbmFsTWlkZGxld2FyZSk7XG4gIGNvbnN0IGdldERlZmF1bHRFbmhhbmNlcnMgPSBidWlsZEdldERlZmF1bHRFbmhhbmNlcnMobWlkZGxld2FyZUVuaGFuY2VyKTtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGVuaGFuY2VycyAmJiB0eXBlb2YgZW5oYW5jZXJzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1KSA6IFwiYGVuaGFuY2Vyc2AgZmllbGQgbXVzdCBiZSBhIGNhbGxiYWNrXCIpO1xuICB9XG4gIGxldCBzdG9yZUVuaGFuY2VycyA9IHR5cGVvZiBlbmhhbmNlcnMgPT09IFwiZnVuY3Rpb25cIiA/IGVuaGFuY2VycyhnZXREZWZhdWx0RW5oYW5jZXJzKSA6IGdldERlZmF1bHRFbmhhbmNlcnMoKTtcbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmICFBcnJheS5pc0FycmF5KHN0b3JlRW5oYW5jZXJzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYpIDogXCJgZW5oYW5jZXJzYCBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBhcnJheVwiKTtcbiAgfVxuICBpZiAoIUlTX1BST0RVQ1RJT04gJiYgc3RvcmVFbmhhbmNlcnMuc29tZSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg3KSA6IFwiZWFjaCBlbmhhbmNlciBwcm92aWRlZCB0byBjb25maWd1cmVTdG9yZSBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgaWYgKCFJU19QUk9EVUNUSU9OICYmIGZpbmFsTWlkZGxld2FyZS5sZW5ndGggJiYgIXN0b3JlRW5oYW5jZXJzLmluY2x1ZGVzKG1pZGRsZXdhcmVFbmhhbmNlcikpIHtcbiAgICBjb25zb2xlLmVycm9yKFwibWlkZGxld2FyZXMgd2VyZSBwcm92aWRlZCwgYnV0IG1pZGRsZXdhcmUgZW5oYW5jZXIgd2FzIG5vdCBpbmNsdWRlZCBpbiBmaW5hbCBlbmhhbmNlcnMgLSBtYWtlIHN1cmUgdG8gY2FsbCBgZ2V0RGVmYXVsdEVuaGFuY2Vyc2BcIik7XG4gIH1cbiAgY29uc3QgY29tcG9zZWRFbmhhbmNlciA9IGZpbmFsQ29tcG9zZSguLi5zdG9yZUVuaGFuY2Vycyk7XG4gIHJldHVybiBjcmVhdGVTdG9yZShyb290UmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGNvbXBvc2VkRW5oYW5jZXIpO1xufVxuXG4vLyBzcmMvY3JlYXRlUmVkdWNlci50c1xuaW1wb3J0IHsgcHJvZHVjZSBhcyBjcmVhdGVOZXh0U3RhdGUyLCBpc0RyYWZ0IGFzIGlzRHJhZnQyLCBpc0RyYWZ0YWJsZSBhcyBpc0RyYWZ0YWJsZTIgfSBmcm9tIFwiaW1tZXJcIjtcblxuLy8gc3JjL21hcEJ1aWxkZXJzLnRzXG5mdW5jdGlvbiBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhidWlsZGVyQ2FsbGJhY2spIHtcbiAgY29uc3QgYWN0aW9uc01hcCA9IHt9O1xuICBjb25zdCBhY3Rpb25NYXRjaGVycyA9IFtdO1xuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyO1xuICBjb25zdCBidWlsZGVyID0ge1xuICAgIGFkZENhc2UodHlwZU9yQWN0aW9uQ3JlYXRvciwgcmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoYWN0aW9uTWF0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI2KSA6IFwiYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNykgOiBcImBidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjgpIDogXCJgYnVpbGRlci5hZGRDYXNlYCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggYW4gZW1wdHkgYWN0aW9uIHR5cGVcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5KSA6IGBcXGBidWlsZGVyLmFkZENhc2VcXGAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGUgJyR7dHlwZX0nYCk7XG4gICAgICB9XG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlcjtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMCkgOiBcImBidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goe1xuICAgICAgICBtYXRjaGVyLFxuICAgICAgICByZWR1Y2VyXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBidWlsZGVyO1xuICAgIH0sXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEpIDogXCJgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXI7XG4gICAgICByZXR1cm4gYnVpbGRlcjtcbiAgICB9XG4gIH07XG4gIGJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKTtcbiAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXTtcbn1cblxuLy8gc3JjL2NyZWF0ZVJlZHVjZXIudHNcbmZ1bmN0aW9uIGlzU3RhdGVGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVkdWNlcihpbml0aWFsU3RhdGUsIG1hcE9yQnVpbGRlckNhbGxiYWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg4KSA6IFwiVGhlIG9iamVjdCBub3RhdGlvbiBmb3IgYGNyZWF0ZVJlZHVjZXJgIGhhcyBiZWVuIHJlbW92ZWQuIFBsZWFzZSB1c2UgdGhlICdidWlsZGVyIGNhbGxiYWNrJyBub3RhdGlvbiBpbnN0ZWFkOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL2FwaS9jcmVhdGVSZWR1Y2VyXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9IGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrKG1hcE9yQnVpbGRlckNhbGxiYWNrKTtcbiAgbGV0IGdldEluaXRpYWxTdGF0ZTtcbiAgaWYgKGlzU3RhdGVGdW5jdGlvbihpbml0aWFsU3RhdGUpKSB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlID0gKCkgPT4gZnJlZXplRHJhZnRhYmxlKGluaXRpYWxTdGF0ZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmcm96ZW5Jbml0aWFsU3RhdGUgPSBmcmVlemVEcmFmdGFibGUoaW5pdGlhbFN0YXRlKTtcbiAgICBnZXRJbml0aWFsU3RhdGUgPSAoKSA9PiBmcm96ZW5Jbml0aWFsU3RhdGU7XG4gIH1cbiAgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGdldEluaXRpYWxTdGF0ZSgpLCBhY3Rpb24pIHtcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW2FjdGlvbnNNYXBbYWN0aW9uLnR5cGVdLCAuLi5maW5hbEFjdGlvbk1hdGNoZXJzLmZpbHRlcigoe1xuICAgICAgbWF0Y2hlclxuICAgIH0pID0+IG1hdGNoZXIoYWN0aW9uKSkubWFwKCh7XG4gICAgICByZWR1Y2VyOiByZWR1Y2VyMlxuICAgIH0pID0+IHJlZHVjZXIyKV07XG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoKGNyKSA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl07XG4gICAgfVxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcikgPT4ge1xuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XG4gICAgICAgIGlmIChpc0RyYWZ0MihwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0RyYWZ0YWJsZTIocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihwcmV2aW91c1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5KSA6IFwiQSBjYXNlIHJlZHVjZXIgb24gYSBub24tZHJhZnRhYmxlIHZhbHVlIG11c3Qgbm90IHJldHVybiB1bmRlZmluZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTIocHJldmlvdXNTdGF0ZSwgKGRyYWZ0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlO1xuICAgIH0sIHN0YXRlKTtcbiAgfVxuICByZWR1Y2VyLmdldEluaXRpYWxTdGF0ZSA9IGdldEluaXRpYWxTdGF0ZTtcbiAgcmV0dXJuIHJlZHVjZXI7XG59XG5cbi8vIHNyYy9uYW5vaWQudHNcbnZhciB1cmxBbHBoYWJldCA9IFwiTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRV1wiO1xudmFyIG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gXCJcIjtcbiAgbGV0IGkgPSBzaXplO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gIH1cbiAgcmV0dXJuIGlkO1xufTtcblxuLy8gc3JjL21hdGNoZXJzLnRzXG52YXIgbWF0Y2hlcyA9IChtYXRjaGVyLCBhY3Rpb24pID0+IHtcbiAgaWYgKGhhc01hdGNoRnVuY3Rpb24obWF0Y2hlcikpIHtcbiAgICByZXR1cm4gbWF0Y2hlci5tYXRjaChhY3Rpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYXRjaGVyKGFjdGlvbik7XG4gIH1cbn07XG5mdW5jdGlvbiBpc0FueU9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoZXMobWF0Y2hlciwgYWN0aW9uKSk7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FsbE9mKC4uLm1hdGNoZXJzKSB7XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIG1hdGNoZXJzLmV2ZXJ5KChtYXRjaGVyKSA9PiBtYXRjaGVzKG1hdGNoZXIsIGFjdGlvbikpO1xuICB9O1xufVxuZnVuY3Rpb24gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCB2YWxpZFN0YXR1cykge1xuICBpZiAoIWFjdGlvbiB8fCAhYWN0aW9uLm1ldGEpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoYXNWYWxpZFJlcXVlc3RJZCA9IHR5cGVvZiBhY3Rpb24ubWV0YS5yZXF1ZXN0SWQgPT09IFwic3RyaW5nXCI7XG4gIGNvbnN0IGhhc1ZhbGlkUmVxdWVzdFN0YXR1cyA9IHZhbGlkU3RhdHVzLmluZGV4T2YoYWN0aW9uLm1ldGEucmVxdWVzdFN0YXR1cykgPiAtMTtcbiAgcmV0dXJuIGhhc1ZhbGlkUmVxdWVzdElkICYmIGhhc1ZhbGlkUmVxdWVzdFN0YXR1cztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua0FycmF5KGEpIHtcbiAgcmV0dXJuIHR5cGVvZiBhWzBdID09PSBcImZ1bmN0aW9uXCIgJiYgXCJwZW5kaW5nXCIgaW4gYVswXSAmJiBcImZ1bGZpbGxlZFwiIGluIGFbMF0gJiYgXCJyZWplY3RlZFwiIGluIGFbMF07XG59XG5mdW5jdGlvbiBpc1BlbmRpbmcoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzUGVuZGluZygpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gYXN5bmNUaHVua3MubWFwKChhc3luY1RodW5rKSA9PiBhc3luY1RodW5rLnBlbmRpbmcpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWQoLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInJlamVjdGVkXCJdKTtcbiAgfVxuICBpZiAoIWlzQXN5bmNUaHVua0FycmF5KGFzeW5jVGh1bmtzKSkge1xuICAgIHJldHVybiBpc1JlamVjdGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsucmVqZWN0ZWQpO1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzUmVqZWN0ZWRXaXRoVmFsdWUoLi4uYXN5bmNUaHVua3MpIHtcbiAgY29uc3QgaGFzRmxhZyA9IChhY3Rpb24pID0+IHtcbiAgICByZXR1cm4gYWN0aW9uICYmIGFjdGlvbi5tZXRhICYmIGFjdGlvbi5tZXRhLnJlamVjdGVkV2l0aFZhbHVlO1xuICB9O1xuICBpZiAoYXN5bmNUaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIChhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgICAgcmV0dXJuIGNvbWJpbmVkTWF0Y2hlcihhY3Rpb24pO1xuICAgIH07XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNSZWplY3RlZFdpdGhWYWx1ZSgpKGFzeW5jVGh1bmtzWzBdKTtcbiAgfVxuICByZXR1cm4gKGFjdGlvbikgPT4ge1xuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQWxsT2YoaXNSZWplY3RlZCguLi5hc3luY1RodW5rcyksIGhhc0ZsYWcpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKC4uLmFzeW5jVGh1bmtzKSB7XG4gIGlmIChhc3luY1RodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gKGFjdGlvbikgPT4gaGFzRXhwZWN0ZWRSZXF1ZXN0TWV0YWRhdGEoYWN0aW9uLCBbXCJmdWxmaWxsZWRcIl0pO1xuICB9XG4gIGlmICghaXNBc3luY1RodW5rQXJyYXkoYXN5bmNUaHVua3MpKSB7XG4gICAgcmV0dXJuIGlzRnVsZmlsbGVkKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhc3luY1RodW5rcy5tYXAoKGFzeW5jVGh1bmspID0+IGFzeW5jVGh1bmsuZnVsZmlsbGVkKTtcbiAgICBjb25zdCBjb21iaW5lZE1hdGNoZXIgPSBpc0FueU9mKC4uLm1hdGNoZXJzKTtcbiAgICByZXR1cm4gY29tYmluZWRNYXRjaGVyKGFjdGlvbik7XG4gIH07XG59XG5mdW5jdGlvbiBpc0FzeW5jVGh1bmtBY3Rpb24oLi4uYXN5bmNUaHVua3MpIHtcbiAgaWYgKGFzeW5jVGh1bmtzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAoYWN0aW9uKSA9PiBoYXNFeHBlY3RlZFJlcXVlc3RNZXRhZGF0YShhY3Rpb24sIFtcInBlbmRpbmdcIiwgXCJmdWxmaWxsZWRcIiwgXCJyZWplY3RlZFwiXSk7XG4gIH1cbiAgaWYgKCFpc0FzeW5jVGh1bmtBcnJheShhc3luY1RodW5rcykpIHtcbiAgICByZXR1cm4gaXNBc3luY1RodW5rQWN0aW9uKCkoYXN5bmNUaHVua3NbMF0pO1xuICB9XG4gIHJldHVybiAoYWN0aW9uKSA9PiB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGFzeW5jVGh1bmsgb2YgYXN5bmNUaHVua3MpIHtcbiAgICAgIG1hdGNoZXJzLnB1c2goYXN5bmNUaHVuay5wZW5kaW5nLCBhc3luY1RodW5rLnJlamVjdGVkLCBhc3luY1RodW5rLmZ1bGZpbGxlZCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbWJpbmVkTWF0Y2hlciA9IGlzQW55T2YoLi4ubWF0Y2hlcnMpO1xuICAgIHJldHVybiBjb21iaW5lZE1hdGNoZXIoYWN0aW9uKTtcbiAgfTtcbn1cblxuLy8gc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHNcbnZhciBjb21tb25Qcm9wZXJ0aWVzID0gW1wibmFtZVwiLCBcIm1lc3NhZ2VcIiwgXCJzdGFja1wiLCBcImNvZGVcIl07XG52YXIgUmVqZWN0V2l0aFZhbHVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXlsb2FkLCBtZXRhKSB7XG4gICAgdGhpcy5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICB9XG4gIC8qXG4gIHR5cGUtb25seSBwcm9wZXJ0eSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIFJlamVjdFdpdGhWYWx1ZSBhbmQgRnVsZmlsbFdpdGhNZXRhXG4gIGRvZXMgbm90IGV4aXN0IGF0IHJ1bnRpbWVcbiAgKi9cbiAgX3R5cGU7XG59O1xudmFyIEZ1bGZpbGxXaXRoTWV0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGF5bG9hZCwgbWV0YSkge1xuICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgfVxuICAvKlxuICB0eXBlLW9ubHkgcHJvcGVydHkgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBSZWplY3RXaXRoVmFsdWUgYW5kIEZ1bGZpbGxXaXRoTWV0YVxuICBkb2VzIG5vdCBleGlzdCBhdCBydW50aW1lXG4gICovXG4gIF90eXBlO1xufTtcbnZhciBtaW5pU2VyaWFsaXplRXJyb3IgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHNpbXBsZUVycm9yID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBjb21tb25Qcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzaW1wbGVFcnJvcltwcm9wZXJ0eV0gPSB2YWx1ZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaW1wbGVFcnJvcjtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSlcbiAgfTtcbn07XG52YXIgY3JlYXRlQXN5bmNUaHVuayA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rMih0eXBlUHJlZml4LCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbih0eXBlUHJlZml4ICsgXCIvZnVsZmlsbGVkXCIsIChwYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgbWV0YSkgPT4gKHtcbiAgICAgIHBheWxvYWQsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIC4uLm1ldGEgfHwge30sXG4gICAgICAgIGFyZyxcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXF1ZXN0U3RhdHVzOiBcImZ1bGZpbGxlZFwiXG4gICAgICB9XG4gICAgfSkpO1xuICAgIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3BlbmRpbmdcIiwgKHJlcXVlc3RJZCwgYXJnLCBtZXRhKSA9PiAoe1xuICAgICAgcGF5bG9hZDogdm9pZCAwLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJwZW5kaW5nXCJcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcmVqZWN0ZWQgPSBjcmVhdGVBY3Rpb24odHlwZVByZWZpeCArIFwiL3JlamVjdGVkXCIsIChlcnJvciwgcmVxdWVzdElkLCBhcmcsIHBheWxvYWQsIG1ldGEpID0+ICh7XG4gICAgICBwYXlsb2FkLFxuICAgICAgZXJyb3I6IChvcHRpb25zICYmIG9wdGlvbnMuc2VyaWFsaXplRXJyb3IgfHwgbWluaVNlcmlhbGl6ZUVycm9yKShlcnJvciB8fCBcIlJlamVjdGVkXCIpLFxuICAgICAgbWV0YToge1xuICAgICAgICAuLi5tZXRhIHx8IHt9LFxuICAgICAgICBhcmcsXG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmVqZWN0ZWRXaXRoVmFsdWU6ICEhcGF5bG9hZCxcbiAgICAgICAgcmVxdWVzdFN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICBhYm9ydGVkOiBlcnJvcj8ubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIsXG4gICAgICAgIGNvbmRpdGlvbjogZXJyb3I/Lm5hbWUgPT09IFwiQ29uZGl0aW9uRXJyb3JcIlxuICAgICAgfVxuICAgIH0pKTtcbiAgICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKGFyZykge1xuICAgICAgcmV0dXJuIChkaXNwYXRjaCwgZ2V0U3RhdGUsIGV4dHJhKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IG9wdGlvbnM/LmlkR2VuZXJhdG9yID8gb3B0aW9ucy5pZEdlbmVyYXRvcihhcmcpIDogbmFub2lkKCk7XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgbGV0IGFib3J0UmVhc29uO1xuICAgICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24pIHtcbiAgICAgICAgICBhYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gYXN5bmMgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IGZpbmFsQWN0aW9uO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gb3B0aW9ucz8uY29uZGl0aW9uPy4oYXJnLCB7XG4gICAgICAgICAgICAgIGdldFN0YXRlLFxuICAgICAgICAgICAgICBleHRyYVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZShjb25kaXRpb25SZXN1bHQpKSB7XG4gICAgICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IGF3YWl0IGNvbmRpdGlvblJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25kaXRpb25SZXN1bHQgPT09IGZhbHNlIHx8IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJDb25kaXRpb25FcnJvclwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS5cIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiByZWplY3Qoe1xuICAgICAgICAgICAgICBuYW1lOiBcIkFib3J0RXJyb3JcIixcbiAgICAgICAgICAgICAgbWVzc2FnZTogYWJvcnRSZWFzb24gfHwgXCJBYm9ydGVkXCJcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnLCBvcHRpb25zPy5nZXRQZW5kaW5nTWV0YT8uKHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICBhcmdcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZ2V0U3RhdGUsXG4gICAgICAgICAgICAgIGV4dHJhXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2Fib3J0ZWRQcm9taXNlLCBQcm9taXNlLnJlc29sdmUocGF5bG9hZENyZWF0b3IoYXJnLCB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoLFxuICAgICAgICAgICAgICBnZXRTdGF0ZSxcbiAgICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICBhYm9ydCxcbiAgICAgICAgICAgICAgcmVqZWN0V2l0aFZhbHVlOiAodmFsdWUsIG1ldGEpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSwgbWV0YSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bGZpbGxXaXRoVmFsdWU6ICh2YWx1ZSwgbWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRnVsZmlsbFdpdGhNZXRhKHZhbHVlLCBtZXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBGdWxmaWxsV2l0aE1ldGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkKHJlc3VsdC5wYXlsb2FkLCByZXF1ZXN0SWQsIGFyZywgcmVzdWx0Lm1ldGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZyk7XG4gICAgICAgICAgICB9KV0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZmluYWxBY3Rpb24gPSBlcnIgaW5zdGFuY2VvZiBSZWplY3RXaXRoVmFsdWUgPyByZWplY3RlZChudWxsLCByZXF1ZXN0SWQsIGFyZywgZXJyLnBheWxvYWQsIGVyci5tZXRhKSA6IHJlamVjdGVkKGVyciwgcmVxdWVzdElkLCBhcmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBza2lwRGlzcGF0Y2ggPSBvcHRpb25zICYmICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmIHJlamVjdGVkLm1hdGNoKGZpbmFsQWN0aW9uKSAmJiBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvbjtcbiAgICAgICAgICBpZiAoIXNraXBEaXNwYXRjaCkge1xuICAgICAgICAgICAgZGlzcGF0Y2goZmluYWxBY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluYWxBY3Rpb247XG4gICAgICAgIH0oKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwge1xuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgdW53cmFwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbih1bndyYXBSZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY3Rpb25DcmVhdG9yLCB7XG4gICAgICBwZW5kaW5nLFxuICAgICAgcmVqZWN0ZWQsXG4gICAgICBmdWxmaWxsZWQsXG4gICAgICBzZXR0bGVkOiBpc0FueU9mKHJlamVjdGVkLCBmdWxmaWxsZWQpLFxuICAgICAgdHlwZVByZWZpeFxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZUFzeW5jVGh1bmsyLndpdGhUeXBlcyA9ICgpID0+IGNyZWF0ZUFzeW5jVGh1bmsyO1xuICByZXR1cm4gY3JlYXRlQXN5bmNUaHVuazI7XG59KSgpO1xuZnVuY3Rpb24gdW53cmFwUmVzdWx0KGFjdGlvbikge1xuICBpZiAoYWN0aW9uLm1ldGEgJiYgYWN0aW9uLm1ldGEucmVqZWN0ZWRXaXRoVmFsdWUpIHtcbiAgICB0aHJvdyBhY3Rpb24ucGF5bG9hZDtcbiAgfVxuICBpZiAoYWN0aW9uLmVycm9yKSB7XG4gICAgdGhyb3cgYWN0aW9uLmVycm9yO1xuICB9XG4gIHJldHVybiBhY3Rpb24ucGF5bG9hZDtcbn1cbmZ1bmN0aW9uIGlzVGhlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vLyBzcmMvY3JlYXRlU2xpY2UudHNcbnZhciBhc3luY1RodW5rU3ltYm9sID0gU3ltYm9sLmZvcihcInJ0ay1zbGljZS1jcmVhdGVhc3luY3RodW5rXCIpO1xudmFyIGFzeW5jVGh1bmtDcmVhdG9yID0ge1xuICBbYXN5bmNUaHVua1N5bWJvbF06IGNyZWF0ZUFzeW5jVGh1bmtcbn07XG52YXIgUmVkdWNlclR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZWR1Y2VyVHlwZTIpID0+IHtcbiAgUmVkdWNlclR5cGUyW1wicmVkdWNlclwiXSA9IFwicmVkdWNlclwiO1xuICBSZWR1Y2VyVHlwZTJbXCJyZWR1Y2VyV2l0aFByZXBhcmVcIl0gPSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiO1xuICBSZWR1Y2VyVHlwZTJbXCJhc3luY1RodW5rXCJdID0gXCJhc3luY1RodW5rXCI7XG4gIHJldHVybiBSZWR1Y2VyVHlwZTI7XG59KShSZWR1Y2VyVHlwZSB8fCB7fSk7XG5mdW5jdGlvbiBnZXRUeXBlKHNsaWNlLCBhY3Rpb25LZXkpIHtcbiAgcmV0dXJuIGAke3NsaWNlfS8ke2FjdGlvbktleX1gO1xufVxuZnVuY3Rpb24gYnVpbGRDcmVhdGVTbGljZSh7XG4gIGNyZWF0b3JzXG59ID0ge30pIHtcbiAgY29uc3QgY0FUID0gY3JlYXRvcnM/LmFzeW5jVGh1bms/Llthc3luY1RodW5rU3ltYm9sXTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVNsaWNlMihvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHJlZHVjZXJQYXRoID0gbmFtZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTEpIDogXCJgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbFN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSBtdXN0IHByb3ZpZGUgYW4gYGluaXRpYWxTdGF0ZWAgdmFsdWUgdGhhdCBpcyBub3QgYHVuZGVmaW5lZGAuIFlvdSBtYXkgaGF2ZSBtaXNzcGVsbGVkIGBpbml0aWFsU3RhdGVgXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZWR1Y2VycyA9ICh0eXBlb2Ygb3B0aW9ucy5yZWR1Y2VycyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5yZWR1Y2VycyhidWlsZFJlZHVjZXJDcmVhdG9ycygpKSA6IG9wdGlvbnMucmVkdWNlcnMpIHx8IHt9O1xuICAgIGNvbnN0IHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWU6IHt9LFxuICAgICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGU6IHt9LFxuICAgICAgYWN0aW9uQ3JlYXRvcnM6IHt9LFxuICAgICAgc2xpY2VNYXRjaGVyczogW11cbiAgICB9O1xuICAgIGNvbnN0IGNvbnRleHRNZXRob2RzID0ge1xuICAgICAgYWRkQ2FzZSh0eXBlT3JBY3Rpb25DcmVhdG9yLCByZWR1Y2VyKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gXCJzdHJpbmdcIiA/IHR5cGVPckFjdGlvbkNyZWF0b3IgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEyKSA6IFwiYGNvbnRleHQuYWRkQ2FzZWAgY2Fubm90IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFjdGlvbiB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMykgOiBcImBjb250ZXh0LmFkZENhc2VgIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSByZWR1Y2VyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgYWRkTWF0Y2hlcihtYXRjaGVyLCByZWR1Y2VyKSB7XG4gICAgICAgIGNvbnRleHQuc2xpY2VNYXRjaGVycy5wdXNoKHtcbiAgICAgICAgICBtYXRjaGVyLFxuICAgICAgICAgIHJlZHVjZXJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZXh0TWV0aG9kcztcbiAgICAgIH0sXG4gICAgICBleHBvc2VBY3Rpb24obmFtZTIsIGFjdGlvbkNyZWF0b3IpIHtcbiAgICAgICAgY29udGV4dC5hY3Rpb25DcmVhdG9yc1tuYW1lMl0gPSBhY3Rpb25DcmVhdG9yO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9LFxuICAgICAgZXhwb3NlQ2FzZVJlZHVjZXIobmFtZTIsIHJlZHVjZXIpIHtcbiAgICAgICAgY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZVtuYW1lMl0gPSByZWR1Y2VyO1xuICAgICAgICByZXR1cm4gY29udGV4dE1ldGhvZHM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWR1Y2VyTmFtZXMuZm9yRWFjaCgocmVkdWNlck5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHJlZHVjZXJEZWZpbml0aW9uID0gcmVkdWNlcnNbcmVkdWNlck5hbWVdO1xuICAgICAgY29uc3QgcmVkdWNlckRldGFpbHMgPSB7XG4gICAgICAgIHJlZHVjZXJOYW1lLFxuICAgICAgICB0eXBlOiBnZXRUeXBlKG5hbWUsIHJlZHVjZXJOYW1lKSxcbiAgICAgICAgY3JlYXRlTm90YXRpb246IHR5cGVvZiBvcHRpb25zLnJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpZiAoaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbihyZWR1Y2VyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgaGFuZGxlVGh1bmtDYXNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRldGFpbHMsIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0TWV0aG9kcywgY0FUKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHJlZHVjZXJEZXRhaWxzLCByZWR1Y2VyRGVmaW5pdGlvbiwgY29udGV4dE1ldGhvZHMpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGJ1aWxkUmVkdWNlcigpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNCkgOiBcIlRoZSBvYmplY3Qgbm90YXRpb24gZm9yIGBjcmVhdGVTbGljZS5leHRyYVJlZHVjZXJzYCBoYXMgYmVlbiByZW1vdmVkLiBQbGVhc2UgdXNlIHRoZSAnYnVpbGRlciBjYWxsYmFjaycgbm90YXRpb24gaW5zdGVhZDogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvY3JlYXRlU2xpY2VcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IFtleHRyYVJlZHVjZXJzID0ge30sIGFjdGlvbk1hdGNoZXJzID0gW10sIGRlZmF1bHRDYXNlUmVkdWNlciA9IHZvaWQgMF0gPSB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSBcImZ1bmN0aW9uXCIgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc107XG4gICAgICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHtcbiAgICAgICAgLi4uZXh0cmFSZWR1Y2VycyxcbiAgICAgICAgLi4uY29udGV4dC5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjcmVhdGVSZWR1Y2VyKG9wdGlvbnMuaW5pdGlhbFN0YXRlLCAoYnVpbGRlcikgPT4ge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZmluYWxDYXNlUmVkdWNlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZENhc2Uoa2V5LCBmaW5hbENhc2VSZWR1Y2Vyc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzTSBvZiBjb250ZXh0LnNsaWNlTWF0Y2hlcnMpIHtcbiAgICAgICAgICBidWlsZGVyLmFkZE1hdGNoZXIoc00ubWF0Y2hlciwgc00ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbSBvZiBhY3Rpb25NYXRjaGVycykge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkTWF0Y2hlcihtLm1hdGNoZXIsIG0ucmVkdWNlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRDYXNlUmVkdWNlcikge1xuICAgICAgICAgIGJ1aWxkZXIuYWRkRGVmYXVsdENhc2UoZGVmYXVsdENhc2VSZWR1Y2VyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdFNlbGYgPSAoc3RhdGUpID0+IHN0YXRlO1xuICAgIGNvbnN0IGluamVjdGVkU2VsZWN0b3JDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIGxldCBfcmVkdWNlcjtcbiAgICBjb25zdCBzbGljZSA9IHtcbiAgICAgIG5hbWUsXG4gICAgICByZWR1Y2VyUGF0aCxcbiAgICAgIHJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICAgICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICAgIHJldHVybiBfcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgIH0sXG4gICAgICBhY3Rpb25zOiBjb250ZXh0LmFjdGlvbkNyZWF0b3JzLFxuICAgICAgY2FzZVJlZHVjZXJzOiBjb250ZXh0LnNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lLFxuICAgICAgZ2V0SW5pdGlhbFN0YXRlKCkge1xuICAgICAgICBpZiAoIV9yZWR1Y2VyKVxuICAgICAgICAgIF9yZWR1Y2VyID0gYnVpbGRSZWR1Y2VyKCk7XG4gICAgICAgIHJldHVybiBfcmVkdWNlci5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgIH0sXG4gICAgICBnZXRTZWxlY3RvcnMoc2VsZWN0U3RhdGUgPSBzZWxlY3RTZWxmKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBlbXBsYWNlKGluamVjdGVkU2VsZWN0b3JDYWNoZSwgdGhpcywge1xuICAgICAgICAgIGluc2VydDogKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbXBsYWNlKHNlbGVjdG9yQ2FjaGUsIHNlbGVjdFN0YXRlLCB7XG4gICAgICAgICAgaW5zZXJ0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXAgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUyLCBzZWxlY3Rvcl0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucy5zZWxlY3RvcnMgPz8ge30pKSB7XG4gICAgICAgICAgICAgIG1hcFtuYW1lMl0gPSB3cmFwU2VsZWN0b3IodGhpcywgc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCB0aGlzICE9PSBzbGljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgc2VsZWN0U2xpY2Uoc3RhdGUpIHtcbiAgICAgICAgbGV0IHNsaWNlU3RhdGUgPSBzdGF0ZVt0aGlzLnJlZHVjZXJQYXRoXTtcbiAgICAgICAgaWYgKHR5cGVvZiBzbGljZVN0YXRlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMgIT09IHNsaWNlKSB7XG4gICAgICAgICAgICBzbGljZVN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUpIDogXCJzZWxlY3RTbGljZSByZXR1cm5lZCB1bmRlZmluZWQgZm9yIGFuIHVuaW5qZWN0ZWQgc2xpY2UgcmVkdWNlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNsaWNlU3RhdGU7XG4gICAgICB9LFxuICAgICAgZ2V0IHNlbGVjdG9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0b3JzKHRoaXMuc2VsZWN0U2xpY2UpO1xuICAgICAgfSxcbiAgICAgIGluamVjdEludG8oaW5qZWN0YWJsZSwge1xuICAgICAgICByZWR1Y2VyUGF0aDogcGF0aE9wdCxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVkdWNlclBhdGgyID0gcGF0aE9wdCA/PyB0aGlzLnJlZHVjZXJQYXRoO1xuICAgICAgICBpbmplY3RhYmxlLmluamVjdCh7XG4gICAgICAgICAgcmVkdWNlclBhdGg6IHJlZHVjZXJQYXRoMixcbiAgICAgICAgICByZWR1Y2VyOiB0aGlzLnJlZHVjZXJcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50aGlzLFxuICAgICAgICAgIHJlZHVjZXJQYXRoOiByZWR1Y2VyUGF0aDJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzbGljZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBTZWxlY3RvcihzbGljZSwgc2VsZWN0b3IsIHNlbGVjdFN0YXRlLCBpbmplY3RlZCkge1xuICBmdW5jdGlvbiB3cmFwcGVyKHJvb3RTdGF0ZSwgLi4uYXJncykge1xuICAgIGxldCBzbGljZVN0YXRlID0gc2VsZWN0U3RhdGUuY2FsbChzbGljZSwgcm9vdFN0YXRlKTtcbiAgICBpZiAodHlwZW9mIHNsaWNlU3RhdGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChpbmplY3RlZCkge1xuICAgICAgICBzbGljZVN0YXRlID0gc2xpY2UuZ2V0SW5pdGlhbFN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNikgOiBcInNlbGVjdFN0YXRlIHJldHVybmVkIHVuZGVmaW5lZCBmb3IgYW4gdW5pbmplY3RlZCBzbGljZSByZWR1Y2VyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3Ioc2xpY2VTdGF0ZSwgLi4uYXJncyk7XG4gIH1cbiAgd3JhcHBlci51bndyYXBwZWQgPSBzZWxlY3RvcjtcbiAgcmV0dXJuIHdyYXBwZXI7XG59XG52YXIgY3JlYXRlU2xpY2UgPSBidWlsZENyZWF0ZVNsaWNlKCk7XG5mdW5jdGlvbiBidWlsZFJlZHVjZXJDcmVhdG9ycygpIHtcbiAgZnVuY3Rpb24gYXN5bmNUaHVuayhwYXlsb2FkQ3JlYXRvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9yZWR1Y2VyRGVmaW5pdGlvblR5cGU6IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi8sXG4gICAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG4gIH1cbiAgYXN5bmNUaHVuay53aXRoVHlwZXMgPSAoKSA9PiBhc3luY1RodW5rO1xuICByZXR1cm4ge1xuICAgIHJlZHVjZXIoY2FzZVJlZHVjZXIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgLy8gaGFjayBzbyB0aGUgd3JhcHBpbmcgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gY3JlYXRlIGEgd3JhcHBlciBzbyB0aGUgYHJlZHVjZXJEZWZpbml0aW9uVHlwZWAgaXMgbm90IGFzc2lnbmVkIHRvIHRoZSBvcmlnaW5hbFxuICAgICAgICBbY2FzZVJlZHVjZXIubmFtZV0oLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBjYXNlUmVkdWNlciguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVtjYXNlUmVkdWNlci5uYW1lXSwge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJcIiAvKiByZWR1Y2VyICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHByZXBhcmVkUmVkdWNlcihwcmVwYXJlLCByZWR1Y2VyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcmVkdWNlckRlZmluaXRpb25UeXBlOiBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLyxcbiAgICAgICAgcHJlcGFyZSxcbiAgICAgICAgcmVkdWNlclxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jVGh1bmtcbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5vcm1hbFJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWUsXG4gIGNyZWF0ZU5vdGF0aW9uXG59LCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSwgY29udGV4dCkge1xuICBsZXQgY2FzZVJlZHVjZXI7XG4gIGxldCBwcmVwYXJlQ2FsbGJhY2s7XG4gIGlmIChcInJlZHVjZXJcIiBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xuICAgIGlmIChjcmVhdGVOb3RhdGlvbiAmJiAhaXNDYXNlUmVkdWNlcldpdGhQcmVwYXJlRGVmaW5pdGlvbihtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE3KSA6IFwiUGxlYXNlIHVzZSB0aGUgYGNyZWF0ZS5wcmVwYXJlZFJlZHVjZXJgIG5vdGF0aW9uIGZvciBwcmVwYXJlZCBhY3Rpb24gY3JlYXRvcnMgd2l0aCB0aGUgYGNyZWF0ZWAgbm90YXRpb24uXCIpO1xuICAgIH1cbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXI7XG4gICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZTtcbiAgfSBlbHNlIHtcbiAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlO1xuICB9XG4gIGNvbnRleHQuYWRkQ2FzZSh0eXBlLCBjYXNlUmVkdWNlcikuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIGNhc2VSZWR1Y2VyKS5leHBvc2VBY3Rpb24ocmVkdWNlck5hbWUsIHByZXBhcmVDYWxsYmFjayA/IGNyZWF0ZUFjdGlvbih0eXBlLCBwcmVwYXJlQ2FsbGJhY2spIDogY3JlYXRlQWN0aW9uKHR5cGUpKTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUaHVua1NsaWNlUmVkdWNlckRlZmluaXRpb24ocmVkdWNlckRlZmluaXRpb24pIHtcbiAgcmV0dXJuIHJlZHVjZXJEZWZpbml0aW9uLl9yZWR1Y2VyRGVmaW5pdGlvblR5cGUgPT09IFwiYXN5bmNUaHVua1wiIC8qIGFzeW5jVGh1bmsgKi87XG59XG5mdW5jdGlvbiBpc0Nhc2VSZWR1Y2VyV2l0aFByZXBhcmVEZWZpbml0aW9uKHJlZHVjZXJEZWZpbml0aW9uKSB7XG4gIHJldHVybiByZWR1Y2VyRGVmaW5pdGlvbi5fcmVkdWNlckRlZmluaXRpb25UeXBlID09PSBcInJlZHVjZXJXaXRoUHJlcGFyZVwiIC8qIHJlZHVjZXJXaXRoUHJlcGFyZSAqLztcbn1cbmZ1bmN0aW9uIGhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uKHtcbiAgdHlwZSxcbiAgcmVkdWNlck5hbWVcbn0sIHJlZHVjZXJEZWZpbml0aW9uLCBjb250ZXh0LCBjQVQpIHtcbiAgaWYgKCFjQVQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxOCkgOiBcIkNhbm5vdCB1c2UgYGNyZWF0ZS5hc3luY1RodW5rYCBpbiB0aGUgYnVpbHQtaW4gYGNyZWF0ZVNsaWNlYC4gVXNlIGBidWlsZENyZWF0ZVNsaWNlKHsgY3JlYXRvcnM6IHsgYXN5bmNUaHVuazogYXN5bmNUaHVua0NyZWF0b3IgfSB9KWAgdG8gY3JlYXRlIGEgY3VzdG9taXNlZCB2ZXJzaW9uIG9mIGBjcmVhdGVTbGljZWAuXCIpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBwYXlsb2FkQ3JlYXRvcixcbiAgICBmdWxmaWxsZWQsXG4gICAgcGVuZGluZyxcbiAgICByZWplY3RlZCxcbiAgICBzZXR0bGVkLFxuICAgIG9wdGlvbnNcbiAgfSA9IHJlZHVjZXJEZWZpbml0aW9uO1xuICBjb25zdCB0aHVuayA9IGNBVCh0eXBlLCBwYXlsb2FkQ3JlYXRvciwgb3B0aW9ucyk7XG4gIGNvbnRleHQuZXhwb3NlQWN0aW9uKHJlZHVjZXJOYW1lLCB0aHVuayk7XG4gIGlmIChmdWxmaWxsZWQpIHtcbiAgICBjb250ZXh0LmFkZENhc2UodGh1bmsuZnVsZmlsbGVkLCBmdWxmaWxsZWQpO1xuICB9XG4gIGlmIChwZW5kaW5nKSB7XG4gICAgY29udGV4dC5hZGRDYXNlKHRodW5rLnBlbmRpbmcsIHBlbmRpbmcpO1xuICB9XG4gIGlmIChyZWplY3RlZCkge1xuICAgIGNvbnRleHQuYWRkQ2FzZSh0aHVuay5yZWplY3RlZCwgcmVqZWN0ZWQpO1xuICB9XG4gIGlmIChzZXR0bGVkKSB7XG4gICAgY29udGV4dC5hZGRNYXRjaGVyKHRodW5rLnNldHRsZWQsIHNldHRsZWQpO1xuICB9XG4gIGNvbnRleHQuZXhwb3NlQ2FzZVJlZHVjZXIocmVkdWNlck5hbWUsIHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCB8fCBub29wLFxuICAgIHBlbmRpbmc6IHBlbmRpbmcgfHwgbm9vcCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQgfHwgbm9vcCxcbiAgICBzZXR0bGVkOiBzZXR0bGVkIHx8IG5vb3BcbiAgfSk7XG59XG5mdW5jdGlvbiBub29wKCkge1xufVxuXG4vLyBzcmMvZW50aXRpZXMvZW50aXR5X3N0YXRlLnRzXG5mdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgaWRzOiBbXSxcbiAgICBlbnRpdGllczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZShhZGRpdGlvbmFsU3RhdGUgPSB7fSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGdldEluaXRpYWxFbnRpdHlTdGF0ZSgpLCBhZGRpdGlvbmFsU3RhdGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0SW5pdGlhbFN0YXRlXG4gIH07XG59XG5cbi8vIHNyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHNcbmZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKSB7XG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhzZWxlY3RTdGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgY3JlYXRlU2VsZWN0b3I6IGNyZWF0ZVNlbGVjdG9yMiA9IGNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlKSA9PiBzdGF0ZS5pZHM7XG4gICAgY29uc3Qgc2VsZWN0RW50aXRpZXMgPSAoc3RhdGUpID0+IHN0YXRlLmVudGl0aWVzO1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RJZHMsIHNlbGVjdEVudGl0aWVzLCAoaWRzLCBlbnRpdGllcykgPT4gaWRzLm1hcCgoaWQpID0+IGVudGl0aWVzW2lkXSkpO1xuICAgIGNvbnN0IHNlbGVjdElkID0gKF8sIGlkKSA9PiBpZDtcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzLCBpZCkgPT4gZW50aXRpZXNbaWRdO1xuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3IyKHNlbGVjdElkcywgKGlkcykgPT4gaWRzLmxlbmd0aCk7XG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0SWRzLFxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcbiAgICAgICAgc2VsZWN0QWxsLFxuICAgICAgICBzZWxlY3RUb3RhbCxcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3IyKHNlbGVjdEVudGl0aWVzLCBzZWxlY3RJZCwgc2VsZWN0QnlJZClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyA9IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RJZHM6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXG4gICAgICBzZWxlY3RBbGw6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcjIoc2VsZWN0U3RhdGUsIHNlbGVjdFRvdGFsKSxcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yMihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRTZWxlY3RvcnNcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL3N0YXRlX2FkYXB0ZXIudHNcbmltcG9ydCB7IHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlMywgaXNEcmFmdCBhcyBpc0RyYWZ0MyB9IGZyb20gXCJpbW1lclwiO1xudmFyIGlzRHJhZnRUeXBlZCA9IGlzRHJhZnQzO1xuZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKG11dGF0b3IpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfLCBzdGF0ZSkgPT4gbXV0YXRvcihzdGF0ZSkpO1xuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yKHN0YXRlLCB2b2lkIDApO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGVPcGVyYXRvcihtdXRhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb24oc3RhdGUsIGFyZykge1xuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZzIpIHtcbiAgICAgIHJldHVybiBpc0ZTQShhcmcyKTtcbiAgICB9XG4gICAgY29uc3QgcnVuTXV0YXRvciA9IChkcmFmdCkgPT4ge1xuICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcbiAgICAgICAgbXV0YXRvcihhcmcucGF5bG9hZCwgZHJhZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRvcihhcmcsIGRyYWZ0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0RyYWZ0VHlwZWQoc3RhdGUpKSB7XG4gICAgICBydW5NdXRhdG9yKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5leHRTdGF0ZTMoc3RhdGUsIHJ1bk11dGF0b3IpO1xuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvdXRpbHMudHNcbmZ1bmN0aW9uIHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCkge1xuICBjb25zdCBrZXkgPSBzZWxlY3RJZChlbnRpdHkpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGtleSA9PT0gdm9pZCAwKSB7XG4gICAgY29uc29sZS53YXJuKFwiVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLlwiLCBcIllvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLlwiLCBcIlRoZSBlbnRpdHkgdGhhdCB3YXMgcGFzc2VkOlwiLCBlbnRpdHksIFwiVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246XCIsIHNlbGVjdElkLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBlbnN1cmVFbnRpdGllc0FycmF5KGVudGl0aWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcbiAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpO1xuICB9XG4gIHJldHVybiBlbnRpdGllcztcbn1cbmZ1bmN0aW9uIHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSkge1xuICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICBjb25zdCBhZGRlZCA9IFtdO1xuICBjb25zdCB1cGRhdGVkID0gW107XG4gIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChpZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgdXBkYXRlZC5wdXNoKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNoYW5nZXM6IGVudGl0eVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZGVkLnB1c2goZW50aXR5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthZGRlZCwgdXBkYXRlZF07XG59XG5cbi8vIHNyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCkge1xuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpIHtcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpO1xuICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5O1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgbmV3RW50aXRpZXMpIHtcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZCk7XG4gICAgaWYgKCEoa2V5IGluIHN0YXRlLmVudGl0aWVzKSkge1xuICAgICAgc3RhdGUuaWRzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgc3RhdGUuZW50aXRpZXNba2V5XSA9IGVudGl0eTtcbiAgfVxuICBmdW5jdGlvbiBzZXRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld0VudGl0aWVzKSB7XG4gICAgICBzZXRPbmVNdXRhYmx5KGVudGl0eSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fTtcbiAgICBhZGRNYW55TXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5LCBzdGF0ZSkge1xuICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXMsIHN0YXRlKSB7XG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldO1xuICAgICAgICBkaWRNdXRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkaWRNdXRhdGUpIHtcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoKGlkKSA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGUpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICBpZHM6IFtdLFxuICAgICAgZW50aXRpZXM6IHt9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gdGFrZU5ld0tleShrZXlzLCB1cGRhdGUsIHN0YXRlKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwzID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXTtcbiAgICBpZiAob3JpZ2luYWwzID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsMywgdXBkYXRlLmNoYW5nZXMpO1xuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpO1xuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkO1xuICAgIGlmIChoYXNOZXdLZXkpIHtcbiAgICAgIGtleXNbdXBkYXRlLmlkXSA9IG5ld0tleTtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgIH1cbiAgICBzdGF0ZS5lbnRpdGllc1tuZXdLZXldID0gdXBkYXRlZDtcbiAgICByZXR1cm4gaGFzTmV3S2V5O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlLCBzdGF0ZSkge1xuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgbmV3S2V5cyA9IHt9O1xuICAgIGNvbnN0IHVwZGF0ZXNQZXJFbnRpdHkgPSB7fTtcbiAgICB1cGRhdGVzLmZvckVhY2goKHVwZGF0ZSkgPT4ge1xuICAgICAgaWYgKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykge1xuICAgICAgICB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0gPSB7XG4gICAgICAgICAgaWQ6IHVwZGF0ZS5pZCxcbiAgICAgICAgICAvLyBTcHJlYWRzIGlnbm9yZSBmYWxzeSB2YWx1ZXMsIHNvIHRoaXMgd29ya3MgZXZlbiBpZiB0aGVyZSBpc24ndFxuICAgICAgICAgIC8vIGFuIGV4aXN0aW5nIHVwZGF0ZSBhbHJlYWR5IGF0IHRoaXMga2V5XG4gICAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgICAgLi4udXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID8gdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdLmNoYW5nZXMgOiBudWxsLFxuICAgICAgICAgICAgLi4udXBkYXRlLmNoYW5nZXNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgdXBkYXRlcyA9IE9iamVjdC52YWx1ZXModXBkYXRlc1BlckVudGl0eSk7XG4gICAgY29uc3QgZGlkTXV0YXRlRW50aXRpZXMgPSB1cGRhdGVzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGRpZE11dGF0ZUVudGl0aWVzKSB7XG4gICAgICBjb25zdCBkaWRNdXRhdGVJZHMgPSB1cGRhdGVzLmZpbHRlcigodXBkYXRlKSA9PiB0YWtlTmV3S2V5KG5ld0tleXMsIHVwZGF0ZSwgc3RhdGUpKS5sZW5ndGggPiAwO1xuICAgICAgaWYgKGRpZE11dGF0ZUlkcykge1xuICAgICAgICBzdGF0ZS5pZHMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKS5tYXAoKGUpID0+IHNlbGVjdElkVmFsdWUoZSwgc2VsZWN0SWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHksIHN0YXRlKSB7XG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSk7XG4gIH1cbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKSB7XG4gICAgY29uc3QgW2FkZGVkLCB1cGRhdGVkXSA9IHNwbGl0QWRkZWRVcGRhdGVkRW50aXRpZXMobmV3RW50aXRpZXMsIHNlbGVjdElkLCBzdGF0ZSk7XG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpO1xuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgc2V0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE9uZU11dGFibHkpLFxuICAgIHNldE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0TWFueU11dGFibHkpLFxuICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxuICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcbiAgICByZW1vdmVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU1hbnlNdXRhYmx5KVxuICB9O1xufVxuXG4vLyBzcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydCkge1xuICBjb25zdCB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsXG4gIH0gPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCk7XG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgY29uc3QgbW9kZWxzID0gbmV3RW50aXRpZXMuZmlsdGVyKChtb2RlbCkgPT4gIShzZWxlY3RJZFZhbHVlKG1vZGVsLCBzZWxlY3RJZCkgaW4gc3RhdGUuZW50aXRpZXMpKTtcbiAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2UobW9kZWxzLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiBzZXRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHNldE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIG5ld0VudGl0aWVzID0gZW5zdXJlRW50aXRpZXNBcnJheShuZXdFbnRpdGllcyk7XG4gICAgaWYgKG5ld0VudGl0aWVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgbWVyZ2UobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShuZXdFbnRpdGllcywgc3RhdGUpIHtcbiAgICBuZXdFbnRpdGllcyA9IGVuc3VyZUVudGl0aWVzQXJyYXkobmV3RW50aXRpZXMpO1xuICAgIHN0YXRlLmVudGl0aWVzID0ge307XG4gICAgc3RhdGUuaWRzID0gW107XG4gICAgYWRkTWFueU11dGFibHkobmV3RW50aXRpZXMsIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZSwgc3RhdGUpIHtcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKTtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzLCBzdGF0ZSkge1xuICAgIGxldCBhcHBsaWVkVXBkYXRlcyA9IGZhbHNlO1xuICAgIGZvciAobGV0IHVwZGF0ZSBvZiB1cGRhdGVzKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdO1xuICAgICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhcHBsaWVkVXBkYXRlcyA9IHRydWU7XG4gICAgICBPYmplY3QuYXNzaWduKGVudGl0eSwgdXBkYXRlLmNoYW5nZXMpO1xuICAgICAgY29uc3QgbmV3SWQgPSBzZWxlY3RJZChlbnRpdHkpO1xuICAgICAgaWYgKHVwZGF0ZS5pZCAhPT0gbmV3SWQpIHtcbiAgICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF07XG4gICAgICAgIHN0YXRlLmVudGl0aWVzW25ld0lkXSA9IGVudGl0eTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFwcGxpZWRVcGRhdGVzKSB7XG4gICAgICByZXNvcnRFbnRpdGllcyhzdGF0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSkge1xuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KG5ld0VudGl0aWVzLCBzdGF0ZSkge1xuICAgIGNvbnN0IFthZGRlZCwgdXBkYXRlZF0gPSBzcGxpdEFkZGVkVXBkYXRlZEVudGl0aWVzKG5ld0VudGl0aWVzLCBzZWxlY3RJZCwgc3RhdGUpO1xuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKTtcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIGFyZUFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGggJiYgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldID09PSBiW2ldKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBtZXJnZShtb2RlbHMsIHN0YXRlKSB7XG4gICAgbW9kZWxzLmZvckVhY2goKG1vZGVsKSA9PiB7XG4gICAgICBzdGF0ZS5lbnRpdGllc1tzZWxlY3RJZChtb2RlbCldID0gbW9kZWw7XG4gICAgfSk7XG4gICAgcmVzb3J0RW50aXRpZXMoc3RhdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29ydEVudGl0aWVzKHN0YXRlKSB7XG4gICAgY29uc3QgYWxsRW50aXRpZXMgPSBPYmplY3QudmFsdWVzKHN0YXRlLmVudGl0aWVzKTtcbiAgICBhbGxFbnRpdGllcy5zb3J0KHNvcnQpO1xuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IGFsbEVudGl0aWVzLm1hcChzZWxlY3RJZCk7XG4gICAgY29uc3Qge1xuICAgICAgaWRzXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XG4gICAgICBzdGF0ZS5pZHMgPSBuZXdTb3J0ZWRJZHM7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcmVtb3ZlT25lLFxuICAgIHJlbW92ZU1hbnksXG4gICAgcmVtb3ZlQWxsLFxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXG4gICAgdXBzZXJ0T25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE9uZU11dGFibHkpLFxuICAgIHNldE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRPbmVNdXRhYmx5KSxcbiAgICBzZXRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldE1hbnlNdXRhYmx5KSxcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcbiAgfTtcbn1cblxuLy8gc3JjL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgc2VsZWN0SWQsXG4gICAgc29ydENvbXBhcmVyXG4gIH0gPSB7XG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5pZCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHN0YXRlRmFjdG9yeSA9IGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3RvcnkoKTtcbiAgY29uc3Qgc2VsZWN0b3JzRmFjdG9yeSA9IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkoKTtcbiAgY29uc3Qgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyID8gY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyKHNlbGVjdElkLCBzb3J0Q29tcGFyZXIpIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpO1xuICByZXR1cm4ge1xuICAgIHNlbGVjdElkLFxuICAgIHNvcnRDb21wYXJlcixcbiAgICAuLi5zdGF0ZUZhY3RvcnksXG4gICAgLi4uc2VsZWN0b3JzRmFjdG9yeSxcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcbiAgfTtcbn1cblxuLy8gc3JjL2xpc3RlbmVyTWlkZGxld2FyZS9pbmRleC50c1xuaW1wb3J0IHsgaXNBY3Rpb24gYXMgaXNBY3Rpb24zIH0gZnJvbSBcInJlZHV4XCI7XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvdXRpbHMudHNcbnZhciBhc3NlcnRGdW5jdGlvbiA9IChmdW5jLCBleHBlY3RlZCkgPT4ge1xuICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMyKSA6IGAke2V4cGVjdGVkfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICB9XG59O1xudmFyIG5vb3AyID0gKCkgPT4ge1xufTtcbnZhciBjYXRjaFJlamVjdGlvbiA9IChwcm9taXNlLCBvbkVycm9yID0gbm9vcDIpID0+IHtcbiAgcHJvbWlzZS5jYXRjaChvbkVycm9yKTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xudmFyIGFkZEFib3J0U2lnbmFsTGlzdGVuZXIgPSAoYWJvcnRTaWduYWwsIGNhbGxiYWNrKSA9PiB7XG4gIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBjYWxsYmFjaywge1xuICAgIG9uY2U6IHRydWVcbiAgfSk7XG4gIHJldHVybiAoKSA9PiBhYm9ydFNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgY2FsbGJhY2spO1xufTtcbnZhciBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uID0gKGFib3J0Q29udHJvbGxlciwgcmVhc29uKSA9PiB7XG4gIGNvbnN0IHNpZ25hbCA9IGFib3J0Q29udHJvbGxlci5zaWduYWw7XG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIShcInJlYXNvblwiIGluIHNpZ25hbCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2lnbmFsLCBcInJlYXNvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHJlYXNvbixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgO1xuICBhYm9ydENvbnRyb2xsZXIuYWJvcnQocmVhc29uKTtcbn07XG5cbi8vIHNyYy9saXN0ZW5lck1pZGRsZXdhcmUvZXhjZXB0aW9ucy50c1xudmFyIHRhc2sgPSBcInRhc2tcIjtcbnZhciBsaXN0ZW5lciA9IFwibGlzdGVuZXJcIjtcbnZhciBjb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xudmFyIGNhbmNlbGxlZCA9IFwiY2FuY2VsbGVkXCI7XG52YXIgdGFza0NhbmNlbGxlZCA9IGB0YXNrLSR7Y2FuY2VsbGVkfWA7XG52YXIgdGFza0NvbXBsZXRlZCA9IGB0YXNrLSR7Y29tcGxldGVkfWA7XG52YXIgbGlzdGVuZXJDYW5jZWxsZWQgPSBgJHtsaXN0ZW5lcn0tJHtjYW5jZWxsZWR9YDtcbnZhciBsaXN0ZW5lckNvbXBsZXRlZCA9IGAke2xpc3RlbmVyfS0ke2NvbXBsZXRlZH1gO1xudmFyIFRhc2tBYm9ydEVycm9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihjb2RlKSB7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0YXNrfSAke2NhbmNlbGxlZH0gKHJlYXNvbjogJHtjb2RlfSlgO1xuICB9XG4gIG5hbWUgPSBcIlRhc2tBYm9ydEVycm9yXCI7XG4gIG1lc3NhZ2U7XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL3Rhc2sudHNcbnZhciB2YWxpZGF0ZUFjdGl2ZSA9IChzaWduYWwpID0+IHtcbiAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVhc29uXG4gICAgfSA9IHNpZ25hbDtcbiAgICB0aHJvdyBuZXcgVGFza0Fib3J0RXJyb3IocmVhc29uKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgcHJvbWlzZSkge1xuICBsZXQgY2xlYW51cCA9IG5vb3AyO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IG5vdGlmeVJlamVjdGlvbiA9ICgpID0+IHJlamVjdChuZXcgVGFza0Fib3J0RXJyb3Ioc2lnbmFsLnJlYXNvbikpO1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgbm90aWZ5UmVqZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFudXAgPSBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHNpZ25hbCwgbm90aWZ5UmVqZWN0aW9uKTtcbiAgICBwcm9taXNlLmZpbmFsbHkoKCkgPT4gY2xlYW51cCgpKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgIGNsZWFudXAgPSBub29wMjtcbiAgfSk7XG59XG52YXIgcnVuVGFzayA9IGFzeW5jICh0YXNrMiwgY2xlYW5VcCkgPT4ge1xuICB0cnkge1xuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgdGFzazIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBcIm9rXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogZXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvciA/IFwiY2FuY2VsbGVkXCIgOiBcInJlamVjdGVkXCIsXG4gICAgICBlcnJvclxuICAgIH07XG4gIH0gZmluYWxseSB7XG4gICAgY2xlYW5VcD8uKCk7XG4gIH1cbn07XG52YXIgY3JlYXRlUGF1c2UgPSAoc2lnbmFsKSA9PiB7XG4gIHJldHVybiAocHJvbWlzZSkgPT4ge1xuICAgIHJldHVybiBjYXRjaFJlamVjdGlvbihyYWNlV2l0aFNpZ25hbChzaWduYWwsIHByb21pc2UpLnRoZW4oKG91dHB1dCkgPT4ge1xuICAgICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSkpO1xuICB9O1xufTtcbnZhciBjcmVhdGVEZWxheSA9IChzaWduYWwpID0+IHtcbiAgY29uc3QgcGF1c2UgPSBjcmVhdGVQYXVzZShzaWduYWwpO1xuICByZXR1cm4gKHRpbWVvdXRNcykgPT4ge1xuICAgIHJldHVybiBwYXVzZShuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0TXMpKSk7XG4gIH07XG59O1xuXG4vLyBzcmMvbGlzdGVuZXJNaWRkbGV3YXJlL2luZGV4LnRzXG52YXIge1xuICBhc3NpZ25cbn0gPSBPYmplY3Q7XG52YXIgSU5URVJOQUxfTklMX1RPS0VOID0ge307XG52YXIgYWxtID0gXCJsaXN0ZW5lck1pZGRsZXdhcmVcIjtcbnZhciBjcmVhdGVGb3JrID0gKHBhcmVudEFib3J0U2lnbmFsLCBwYXJlbnRCbG9ja2luZ1Byb21pc2VzKSA9PiB7XG4gIGNvbnN0IGxpbmtDb250cm9sbGVycyA9IChjb250cm9sbGVyKSA9PiBhZGRBYm9ydFNpZ25hbExpc3RlbmVyKHBhcmVudEFib3J0U2lnbmFsLCAoKSA9PiBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNvbnRyb2xsZXIsIHBhcmVudEFib3J0U2lnbmFsLnJlYXNvbikpO1xuICByZXR1cm4gKHRhc2tFeGVjdXRvciwgb3B0cykgPT4ge1xuICAgIGFzc2VydEZ1bmN0aW9uKHRhc2tFeGVjdXRvciwgXCJ0YXNrRXhlY3V0b3JcIik7XG4gICAgY29uc3QgY2hpbGRBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGlua0NvbnRyb2xsZXJzKGNoaWxkQWJvcnRDb250cm9sbGVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBydW5UYXNrKGFzeW5jICgpID0+IHtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKHBhcmVudEFib3J0U2lnbmFsKTtcbiAgICAgIHZhbGlkYXRlQWN0aXZlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgdGFza0V4ZWN1dG9yKHtcbiAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpLFxuICAgICAgICBzaWduYWw6IGNoaWxkQWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShjaGlsZEFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfSwgKCkgPT4gYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjaGlsZEFib3J0Q29udHJvbGxlciwgdGFza0NvbXBsZXRlZCkpO1xuICAgIGlmIChvcHRzPy5hdXRvSm9pbikge1xuICAgICAgcGFyZW50QmxvY2tpbmdQcm9taXNlcy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IGNyZWF0ZVBhdXNlKHBhcmVudEFib3J0U2lnbmFsKShyZXN1bHQpLFxuICAgICAgY2FuY2VsKCkge1xuICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGNoaWxkQWJvcnRDb250cm9sbGVyLCB0YXNrQ2FuY2VsbGVkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufTtcbnZhciBjcmVhdGVUYWtlUGF0dGVybiA9IChzdGFydExpc3RlbmluZywgc2lnbmFsKSA9PiB7XG4gIGNvbnN0IHRha2UgPSBhc3luYyAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB7XG4gICAgdmFsaWRhdGVBY3RpdmUoc2lnbmFsKTtcbiAgICBsZXQgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgfTtcbiAgICBjb25zdCB0dXBsZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgc3RvcExpc3RlbmluZyA9IHN0YXJ0TGlzdGVuaW5nKHtcbiAgICAgICAgcHJlZGljYXRlLFxuICAgICAgICBlZmZlY3Q6IChhY3Rpb24sIGxpc3RlbmVyQXBpKSA9PiB7XG4gICAgICAgICAgbGlzdGVuZXJBcGkudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKFthY3Rpb24sIGxpc3RlbmVyQXBpLmdldFN0YXRlKCksIGxpc3RlbmVyQXBpLmdldE9yaWdpbmFsU3RhdGUoKV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBzdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgIHJlamVjdCgpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBwcm9taXNlcyA9IFt0dXBsZVByb21pc2VdO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgIHByb21pc2VzLnB1c2gobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCwgbnVsbCkpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJhY2VXaXRoU2lnbmFsKHNpZ25hbCwgUHJvbWlzZS5yYWNlKHByb21pc2VzKSk7XG4gICAgICB2YWxpZGF0ZUFjdGl2ZShzaWduYWwpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiBjYXRjaFJlamVjdGlvbih0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkpO1xufTtcbnZhciBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tID0gKG9wdGlvbnMpID0+IHtcbiAgbGV0IHtcbiAgICB0eXBlLFxuICAgIGFjdGlvbkNyZWF0b3IsXG4gICAgbWF0Y2hlcixcbiAgICBwcmVkaWNhdGUsXG4gICAgZWZmZWN0XG4gIH0gPSBvcHRpb25zO1xuICBpZiAodHlwZSkge1xuICAgIHByZWRpY2F0ZSA9IGNyZWF0ZUFjdGlvbih0eXBlKS5tYXRjaDtcbiAgfSBlbHNlIGlmIChhY3Rpb25DcmVhdG9yKSB7XG4gICAgdHlwZSA9IGFjdGlvbkNyZWF0b3IudHlwZTtcbiAgICBwcmVkaWNhdGUgPSBhY3Rpb25DcmVhdG9yLm1hdGNoO1xuICB9IGVsc2UgaWYgKG1hdGNoZXIpIHtcbiAgICBwcmVkaWNhdGUgPSBtYXRjaGVyO1xuICB9IGVsc2UgaWYgKHByZWRpY2F0ZSkge1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIxKSA6IFwiQ3JlYXRpbmcgb3IgcmVtb3ZpbmcgYSBsaXN0ZW5lciByZXF1aXJlcyBvbmUgb2YgdGhlIGtub3duIGZpZWxkcyBmb3IgbWF0Y2hpbmcgYW4gYWN0aW9uXCIpO1xuICB9XG4gIGFzc2VydEZ1bmN0aW9uKGVmZmVjdCwgXCJvcHRpb25zLmxpc3RlbmVyXCIpO1xuICByZXR1cm4ge1xuICAgIHByZWRpY2F0ZSxcbiAgICB0eXBlLFxuICAgIGVmZmVjdFxuICB9O1xufTtcbnZhciBjcmVhdGVMaXN0ZW5lckVudHJ5ID0gKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIGVmZmVjdFxuICB9ID0gZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbShvcHRpb25zKTtcbiAgY29uc3QgaWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgZW50cnkgPSB7XG4gICAgaWQsXG4gICAgZWZmZWN0LFxuICAgIHR5cGUsXG4gICAgcHJlZGljYXRlLFxuICAgIHBlbmRpbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIyKSA6IFwiVW5zdWJzY3JpYmUgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVudHJ5O1xufTtcbnZhciBjYW5jZWxBY3RpdmVMaXN0ZW5lcnMgPSAoZW50cnkpID0+IHtcbiAgZW50cnkucGVuZGluZy5mb3JFYWNoKChjb250cm9sbGVyKSA9PiB7XG4gICAgYWJvcnRDb250cm9sbGVyV2l0aFJlYXNvbihjb250cm9sbGVyLCBsaXN0ZW5lckNhbmNlbGxlZCk7XG4gIH0pO1xufTtcbnZhciBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSA9IChsaXN0ZW5lck1hcCkgPT4ge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxpc3RlbmVyTWFwLmZvckVhY2goY2FuY2VsQWN0aXZlTGlzdGVuZXJzKTtcbiAgICBsaXN0ZW5lck1hcC5jbGVhcigpO1xuICB9O1xufTtcbnZhciBzYWZlbHlOb3RpZnlFcnJvciA9IChlcnJvckhhbmRsZXIsIGVycm9yVG9Ob3RpZnksIGVycm9ySW5mbykgPT4ge1xuICB0cnkge1xuICAgIGVycm9ySGFuZGxlcihlcnJvclRvTm90aWZ5LCBlcnJvckluZm8pO1xuICB9IGNhdGNoIChlcnJvckhhbmRsZXJFcnJvcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyb3JIYW5kbGVyRXJyb3I7XG4gICAgfSwgMCk7XG4gIH1cbn07XG52YXIgYWRkTGlzdGVuZXIgPSBjcmVhdGVBY3Rpb24oYCR7YWxtfS9hZGRgKTtcbnZhciBjbGVhckFsbExpc3RlbmVycyA9IGNyZWF0ZUFjdGlvbihgJHthbG19L3JlbW92ZUFsbGApO1xudmFyIHJlbW92ZUxpc3RlbmVyID0gY3JlYXRlQWN0aW9uKGAke2FsbX0vcmVtb3ZlYCk7XG52YXIgZGVmYXVsdEVycm9ySGFuZGxlciA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoYCR7YWxtfS9lcnJvcmAsIC4uLmFyZ3MpO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyTWlkZGxld2FyZShtaWRkbGV3YXJlT3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGxpc3RlbmVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3Qge1xuICAgIGV4dHJhLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0RXJyb3JIYW5kbGVyXG4gIH0gPSBtaWRkbGV3YXJlT3B0aW9ucztcbiAgYXNzZXJ0RnVuY3Rpb24ob25FcnJvciwgXCJvbkVycm9yXCIpO1xuICBjb25zdCBpbnNlcnRFbnRyeSA9IChlbnRyeSkgPT4ge1xuICAgIGVudHJ5LnVuc3Vic2NyaWJlID0gKCkgPT4gbGlzdGVuZXJNYXAuZGVsZXRlKGVudHJ5LmlkKTtcbiAgICBsaXN0ZW5lck1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICByZXR1cm4gKGNhbmNlbE9wdGlvbnMpID0+IHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAoY2FuY2VsT3B0aW9ucz8uY2FuY2VsQWN0aXZlKSB7XG4gICAgICAgIGNhbmNlbEFjdGl2ZUxpc3RlbmVycyhlbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3Qgc3RhcnRMaXN0ZW5pbmcgPSAob3B0aW9ucykgPT4ge1xuICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShsaXN0ZW5lck1hcC52YWx1ZXMoKSksIChleGlzdGluZ0VudHJ5KSA9PiBleGlzdGluZ0VudHJ5LmVmZmVjdCA9PT0gb3B0aW9ucy5lZmZlY3QpO1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgIGVudHJ5ID0gY3JlYXRlTGlzdGVuZXJFbnRyeShvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc2VydEVudHJ5KGVudHJ5KTtcbiAgfTtcbiAgY29uc3Qgc3RvcExpc3RlbmluZyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGVmZmVjdCxcbiAgICAgIHByZWRpY2F0ZVxuICAgIH0gPSBnZXRMaXN0ZW5lckVudHJ5UHJvcHNGcm9tKG9wdGlvbnMpO1xuICAgIGNvbnN0IGVudHJ5ID0gZmluZChBcnJheS5mcm9tKGxpc3RlbmVyTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hQcmVkaWNhdGVPclR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVudHJ5Mi50eXBlID09PSB0eXBlIDogZW50cnkyLnByZWRpY2F0ZSA9PT0gcHJlZGljYXRlO1xuICAgICAgcmV0dXJuIG1hdGNoUHJlZGljYXRlT3JUeXBlICYmIGVudHJ5Mi5lZmZlY3QgPT09IGVmZmVjdDtcbiAgICB9KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnVuc3Vic2NyaWJlKCk7XG4gICAgICBpZiAob3B0aW9ucy5jYW5jZWxBY3RpdmUpIHtcbiAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzKGVudHJ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEhZW50cnk7XG4gIH07XG4gIGNvbnN0IG5vdGlmeUxpc3RlbmVyID0gYXN5bmMgKGVudHJ5LCBhY3Rpb24sIGFwaSwgZ2V0T3JpZ2luYWxTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGludGVybmFsVGFza0NvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgdGFrZSA9IGNyZWF0ZVRha2VQYXR0ZXJuKHN0YXJ0TGlzdGVuaW5nLCBpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgY29uc3QgYXV0b0pvaW5Qcm9taXNlcyA9IFtdO1xuICAgIHRyeSB7XG4gICAgICBlbnRyeS5wZW5kaW5nLmFkZChpbnRlcm5hbFRhc2tDb250cm9sbGVyKTtcbiAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZShlbnRyeS5lZmZlY3QoXG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgLy8gVXNlIGFzc2lnbigpIHJhdGhlciB0aGFuIC4uLiB0byBhdm9pZCBleHRyYSBoZWxwZXIgZnVuY3Rpb25zIGFkZGVkIHRvIGJ1bmRsZVxuICAgICAgICBhc3NpZ24oe30sIGFwaSwge1xuICAgICAgICAgIGdldE9yaWdpbmFsU3RhdGUsXG4gICAgICAgICAgY29uZGl0aW9uOiAocHJlZGljYXRlLCB0aW1lb3V0KSA9PiB0YWtlKHByZWRpY2F0ZSwgdGltZW91dCkudGhlbihCb29sZWFuKSxcbiAgICAgICAgICB0YWtlLFxuICAgICAgICAgIGRlbGF5OiBjcmVhdGVEZWxheShpbnRlcm5hbFRhc2tDb250cm9sbGVyLnNpZ25hbCksXG4gICAgICAgICAgcGF1c2U6IGNyZWF0ZVBhdXNlKGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsKSxcbiAgICAgICAgICBleHRyYSxcbiAgICAgICAgICBzaWduYWw6IGludGVybmFsVGFza0NvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIGZvcms6IGNyZWF0ZUZvcmsoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwsIGF1dG9Kb2luUHJvbWlzZXMpLFxuICAgICAgICAgIHVuc3Vic2NyaWJlOiBlbnRyeS51bnN1YnNjcmliZSxcbiAgICAgICAgICBzdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyTWFwLnNldChlbnRyeS5pZCwgZW50cnkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsQWN0aXZlTGlzdGVuZXJzOiAoKSA9PiB7XG4gICAgICAgICAgICBlbnRyeS5wZW5kaW5nLmZvckVhY2goKGNvbnRyb2xsZXIsIF8sIHNldCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY29udHJvbGxlciAhPT0gaW50ZXJuYWxUYXNrQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIGFib3J0Q29udHJvbGxlcldpdGhSZWFzb24oY29udHJvbGxlciwgbGlzdGVuZXJDYW5jZWxsZWQpO1xuICAgICAgICAgICAgICAgIHNldC5kZWxldGUoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FuY2VsOiAoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ2FuY2VsbGVkKTtcbiAgICAgICAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdGhyb3dJZkNhbmNlbGxlZDogKCkgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGVBY3RpdmUoaW50ZXJuYWxUYXNrQ29udHJvbGxlci5zaWduYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICkpO1xuICAgIH0gY2F0Y2ggKGxpc3RlbmVyRXJyb3IpIHtcbiAgICAgIGlmICghKGxpc3RlbmVyRXJyb3IgaW5zdGFuY2VvZiBUYXNrQWJvcnRFcnJvcikpIHtcbiAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgbGlzdGVuZXJFcnJvciwge1xuICAgICAgICAgIHJhaXNlZEJ5OiBcImVmZmVjdFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoYXV0b0pvaW5Qcm9taXNlcyk7XG4gICAgICBhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uKGludGVybmFsVGFza0NvbnRyb2xsZXIsIGxpc3RlbmVyQ29tcGxldGVkKTtcbiAgICAgIGVudHJ5LnBlbmRpbmcuZGVsZXRlKGludGVybmFsVGFza0NvbnRyb2xsZXIpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUgPSBjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZShsaXN0ZW5lck1hcCk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAoYXBpKSA9PiAobmV4dCkgPT4gKGFjdGlvbikgPT4ge1xuICAgIGlmICghaXNBY3Rpb24zKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgfVxuICAgIGlmIChhZGRMaXN0ZW5lci5tYXRjaChhY3Rpb24pKSB7XG4gICAgICByZXR1cm4gc3RhcnRMaXN0ZW5pbmcoYWN0aW9uLnBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoY2xlYXJBbGxMaXN0ZW5lcnMubWF0Y2goYWN0aW9uKSkge1xuICAgICAgY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlbW92ZUxpc3RlbmVyLm1hdGNoKGFjdGlvbikpIHtcbiAgICAgIHJldHVybiBzdG9wTGlzdGVuaW5nKGFjdGlvbi5wYXlsb2FkKTtcbiAgICB9XG4gICAgbGV0IG9yaWdpbmFsU3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBnZXRPcmlnaW5hbFN0YXRlID0gKCkgPT4ge1xuICAgICAgaWYgKG9yaWdpbmFsU3RhdGUgPT09IElOVEVSTkFMX05JTF9UT0tFTikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyMykgOiBgJHthbG19OiBnZXRPcmlnaW5hbFN0YXRlIGNhbiBvbmx5IGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxTdGF0ZTtcbiAgICB9O1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IG5leHQoYWN0aW9uKTtcbiAgICAgIGlmIChsaXN0ZW5lck1hcC5zaXplID4gMCkge1xuICAgICAgICBsZXQgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyRW50cmllcyA9IEFycmF5LmZyb20obGlzdGVuZXJNYXAudmFsdWVzKCkpO1xuICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBsaXN0ZW5lckVudHJpZXMpIHtcbiAgICAgICAgICBsZXQgcnVuTGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcnVuTGlzdGVuZXIgPSBlbnRyeS5wcmVkaWNhdGUoYWN0aW9uLCBjdXJyZW50U3RhdGUsIG9yaWdpbmFsU3RhdGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKHByZWRpY2F0ZUVycm9yKSB7XG4gICAgICAgICAgICBydW5MaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgc2FmZWx5Tm90aWZ5RXJyb3Iob25FcnJvciwgcHJlZGljYXRlRXJyb3IsIHtcbiAgICAgICAgICAgICAgcmFpc2VkQnk6IFwicHJlZGljYXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJ1bkxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm90aWZ5TGlzdGVuZXIoZW50cnksIGFjdGlvbiwgYXBpLCBnZXRPcmlnaW5hbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBvcmlnaW5hbFN0YXRlID0gSU5URVJOQUxfTklMX1RPS0VOO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgc3RhcnRMaXN0ZW5pbmcsXG4gICAgc3RvcExpc3RlbmluZyxcbiAgICBjbGVhckxpc3RlbmVyczogY2xlYXJMaXN0ZW5lck1pZGRsZXdhcmVcbiAgfTtcbn1cblxuLy8gc3JjL2R5bmFtaWNNaWRkbGV3YXJlL2luZGV4LnRzXG5pbXBvcnQgeyBjb21wb3NlIGFzIGNvbXBvc2UzIH0gZnJvbSBcInJlZHV4XCI7XG52YXIgY3JlYXRlTWlkZGxld2FyZUVudHJ5ID0gKG1pZGRsZXdhcmUpID0+ICh7XG4gIGlkOiBuYW5vaWQoKSxcbiAgbWlkZGxld2FyZSxcbiAgYXBwbGllZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKVxufSk7XG52YXIgbWF0Y2hJbnN0YW5jZSA9IChpbnN0YW5jZUlkKSA9PiAoYWN0aW9uKSA9PiBhY3Rpb24/Lm1ldGE/Lmluc3RhbmNlSWQgPT09IGluc3RhbmNlSWQ7XG52YXIgY3JlYXRlRHluYW1pY01pZGRsZXdhcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlSWQgPSBuYW5vaWQoKTtcbiAgY29uc3QgbWlkZGxld2FyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHdpdGhNaWRkbGV3YXJlID0gT2JqZWN0LmFzc2lnbihjcmVhdGVBY3Rpb24oXCJkeW5hbWljTWlkZGxld2FyZS9hZGRcIiwgKC4uLm1pZGRsZXdhcmVzKSA9PiAoe1xuICAgIHBheWxvYWQ6IG1pZGRsZXdhcmVzLFxuICAgIG1ldGE6IHtcbiAgICAgIGluc3RhbmNlSWRcbiAgICB9XG4gIH0pKSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gd2l0aE1pZGRsZXdhcmVcbiAgfSk7XG4gIGNvbnN0IGFkZE1pZGRsZXdhcmUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIGFkZE1pZGRsZXdhcmUyKC4uLm1pZGRsZXdhcmVzKSB7XG4gICAgbWlkZGxld2FyZXMuZm9yRWFjaCgobWlkZGxld2FyZTIpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IGZpbmQoQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKSwgKGVudHJ5MikgPT4gZW50cnkyLm1pZGRsZXdhcmUgPT09IG1pZGRsZXdhcmUyKTtcbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgZW50cnkgPSBjcmVhdGVNaWRkbGV3YXJlRW50cnkobWlkZGxld2FyZTIpO1xuICAgICAgfVxuICAgICAgbWlkZGxld2FyZU1hcC5zZXQoZW50cnkuaWQsIGVudHJ5KTtcbiAgICB9KTtcbiAgfSwge1xuICAgIHdpdGhUeXBlczogKCkgPT4gYWRkTWlkZGxld2FyZVxuICB9KTtcbiAgY29uc3QgZ2V0RmluYWxNaWRkbGV3YXJlID0gKGFwaSkgPT4ge1xuICAgIGNvbnN0IGFwcGxpZWRNaWRkbGV3YXJlID0gQXJyYXkuZnJvbShtaWRkbGV3YXJlTWFwLnZhbHVlcygpKS5tYXAoKGVudHJ5KSA9PiBlbXBsYWNlKGVudHJ5LmFwcGxpZWQsIGFwaSwge1xuICAgICAgaW5zZXJ0OiAoKSA9PiBlbnRyeS5taWRkbGV3YXJlKGFwaSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIGNvbXBvc2UzKC4uLmFwcGxpZWRNaWRkbGV3YXJlKTtcbiAgfTtcbiAgY29uc3QgaXNXaXRoTWlkZGxld2FyZSA9IGlzQWxsT2Yod2l0aE1pZGRsZXdhcmUsIG1hdGNoSW5zdGFuY2UoaW5zdGFuY2VJZCkpO1xuICBjb25zdCBtaWRkbGV3YXJlID0gKGFwaSkgPT4gKG5leHQpID0+IChhY3Rpb24pID0+IHtcbiAgICBpZiAoaXNXaXRoTWlkZGxld2FyZShhY3Rpb24pKSB7XG4gICAgICBhZGRNaWRkbGV3YXJlKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIHJldHVybiBhcGkuZGlzcGF0Y2g7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaW5hbE1pZGRsZXdhcmUoYXBpKShuZXh0KShhY3Rpb24pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG1pZGRsZXdhcmUsXG4gICAgYWRkTWlkZGxld2FyZSxcbiAgICB3aXRoTWlkZGxld2FyZSxcbiAgICBpbnN0YW5jZUlkXG4gIH07XG59O1xuXG4vLyBzcmMvY29tYmluZVNsaWNlcy50c1xuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIGFzIGNvbWJpbmVSZWR1Y2VyczIgfSBmcm9tIFwicmVkdXhcIjtcbnZhciBpc1NsaWNlTGlrZSA9IChtYXliZVNsaWNlTGlrZSkgPT4gXCJyZWR1Y2VyUGF0aFwiIGluIG1heWJlU2xpY2VMaWtlICYmIHR5cGVvZiBtYXliZVNsaWNlTGlrZS5yZWR1Y2VyUGF0aCA9PT0gXCJzdHJpbmdcIjtcbnZhciBnZXRSZWR1Y2VycyA9IChzbGljZXMpID0+IHNsaWNlcy5mbGF0TWFwKChzbGljZU9yTWFwKSA9PiBpc1NsaWNlTGlrZShzbGljZU9yTWFwKSA/IFtbc2xpY2VPck1hcC5yZWR1Y2VyUGF0aCwgc2xpY2VPck1hcC5yZWR1Y2VyXV0gOiBPYmplY3QuZW50cmllcyhzbGljZU9yTWFwKSk7XG52YXIgT1JJR0lOQUxfU1RBVEUgPSBTeW1ib2wuZm9yKFwicnRrLXN0YXRlLXByb3h5LW9yaWdpbmFsXCIpO1xudmFyIGlzU3RhdGVQcm94eSA9ICh2YWx1ZSkgPT4gISF2YWx1ZSAmJiAhIXZhbHVlW09SSUdJTkFMX1NUQVRFXTtcbnZhciBzdGF0ZVByb3h5TWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgY3JlYXRlU3RhdGVQcm94eSA9IChzdGF0ZSwgcmVkdWNlck1hcCkgPT4gZW1wbGFjZShzdGF0ZVByb3h5TWFwLCBzdGF0ZSwge1xuICBpbnNlcnQ6ICgpID0+IG5ldyBQcm94eShzdGF0ZSwge1xuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIGlmIChwcm9wID09PSBPUklHSU5BTF9TVEFURSlcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IHJlZHVjZXJNYXBbcHJvcC50b1N0cmluZygpXTtcbiAgICAgICAgaWYgKHJlZHVjZXIpIHtcbiAgICAgICAgICBjb25zdCByZWR1Y2VyUmVzdWx0ID0gcmVkdWNlcih2b2lkIDAsIHtcbiAgICAgICAgICAgIHR5cGU6IG5hbm9pZCgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZWR1Y2VyUmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNCkgOiBgVGhlIHNsaWNlIHJlZHVjZXIgZm9yIGtleSBcIiR7cHJvcC50b1N0cmluZygpfVwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIGNhbGxlZCBmb3Igc2VsZWN0b3IoKS4gSWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGUgcmVkdWNlciBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgbm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgeW91IGNhbiB1c2UgbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlZHVjZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9KVxufSk7XG52YXIgb3JpZ2luYWwgPSAoc3RhdGUpID0+IHtcbiAgaWYgKCFpc1N0YXRlUHJveHkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjUpIDogXCJvcmlnaW5hbCBtdXN0IGJlIHVzZWQgb24gc3RhdGUgUHJveHlcIik7XG4gIH1cbiAgcmV0dXJuIHN0YXRlW09SSUdJTkFMX1NUQVRFXTtcbn07XG5mdW5jdGlvbiBjb21iaW5lU2xpY2VzKC4uLnNsaWNlcykge1xuICBjb25zdCByZWR1Y2VyTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKGdldFJlZHVjZXJzKHNsaWNlcykpO1xuICBjb25zdCBnZXRSZWR1Y2VyID0gKCkgPT4gY29tYmluZVJlZHVjZXJzMihyZWR1Y2VyTWFwKTtcbiAgbGV0IHJlZHVjZXIgPSBnZXRSZWR1Y2VyKCk7XG4gIGZ1bmN0aW9uIGNvbWJpbmVkUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHJlZHVjZXIoc3RhdGUsIGFjdGlvbik7XG4gIH1cbiAgY29tYmluZWRSZWR1Y2VyLndpdGhMYXp5TG9hZGVkU2xpY2VzID0gKCkgPT4gY29tYmluZWRSZWR1Y2VyO1xuICBjb25zdCBpbmplY3QgPSAoc2xpY2UsIGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVkdWNlclBhdGgsXG4gICAgICByZWR1Y2VyOiByZWR1Y2VyVG9JbmplY3RcbiAgICB9ID0gc2xpY2U7XG4gICAgY29uc3QgY3VycmVudFJlZHVjZXIgPSByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXTtcbiAgICBpZiAoIWNvbmZpZy5vdmVycmlkZUV4aXN0aW5nICYmIGN1cnJlbnRSZWR1Y2VyICYmIGN1cnJlbnRSZWR1Y2VyICE9PSByZWR1Y2VyVG9JbmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYGNhbGxlZCBcXGBpbmplY3RcXGAgdG8gb3ZlcnJpZGUgYWxyZWFkeS1leGlzdGluZyByZWR1Y2VyICR7cmVkdWNlclBhdGh9IHdpdGhvdXQgc3BlY2lmeWluZyBcXGBvdmVycmlkZUV4aXN0aW5nOiB0cnVlXFxgYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tYmluZWRSZWR1Y2VyO1xuICAgIH1cbiAgICByZWR1Y2VyTWFwW3JlZHVjZXJQYXRoXSA9IHJlZHVjZXJUb0luamVjdDtcbiAgICByZWR1Y2VyID0gZ2V0UmVkdWNlcigpO1xuICAgIHJldHVybiBjb21iaW5lZFJlZHVjZXI7XG4gIH07XG4gIGNvbnN0IHNlbGVjdG9yID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiBtYWtlU2VsZWN0b3Ioc2VsZWN0b3JGbiwgc2VsZWN0U3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VsZWN0b3IyKHN0YXRlLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGbihjcmVhdGVTdGF0ZVByb3h5KHNlbGVjdFN0YXRlID8gc2VsZWN0U3RhdGUoc3RhdGUsIC4uLmFyZ3MpIDogc3RhdGUsIHJlZHVjZXJNYXApLCAuLi5hcmdzKTtcbiAgICB9O1xuICB9LCB7XG4gICAgb3JpZ2luYWxcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKGNvbWJpbmVkUmVkdWNlciwge1xuICAgIGluamVjdCxcbiAgICBzZWxlY3RvclxuICB9KTtcbn1cblxuLy8gc3JjL2Zvcm1hdFByb2RFcnJvck1lc3NhZ2UudHNcbmZ1bmN0aW9uIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoY29kZSkge1xuICByZXR1cm4gYE1pbmlmaWVkIFJlZHV4IFRvb2xraXQgZXJyb3IgIyR7Y29kZX07IHZpc2l0IGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvRXJyb3JzP2NvZGU9JHtjb2RlfSBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzLiBgO1xufVxuZXhwb3J0IHtcbiAgUmVkdWNlclR5cGUsXG4gIFNIT1VMRF9BVVRPQkFUQ0gsXG4gIFRhc2tBYm9ydEVycm9yLFxuICBUdXBsZSxcbiAgYWRkTGlzdGVuZXIsXG4gIGFzeW5jVGh1bmtDcmVhdG9yLFxuICBhdXRvQmF0Y2hFbmhhbmNlcixcbiAgYnVpbGRDcmVhdGVTbGljZSxcbiAgY2xlYXJBbGxMaXN0ZW5lcnMsXG4gIGNvbWJpbmVTbGljZXMsXG4gIGNvbmZpZ3VyZVN0b3JlLFxuICBjcmVhdGVBY3Rpb24sXG4gIGNyZWF0ZUFjdGlvbkNyZWF0b3JJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVBc3luY1RodW5rLFxuICBjcmVhdGVEcmFmdFNhZmVTZWxlY3RvcixcbiAgY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3JDcmVhdG9yLFxuICBjcmVhdGVEeW5hbWljTWlkZGxld2FyZSxcbiAgY3JlYXRlRW50aXR5QWRhcHRlcixcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxuICBjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUsXG4gIHByb2R1Y2UgYXMgY3JlYXRlTmV4dFN0YXRlLFxuICBjcmVhdGVSZWR1Y2VyLFxuICBjcmVhdGVTZWxlY3RvcixcbiAgY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiBhcyBjcmVhdGVTZWxlY3RvckNyZWF0b3IsXG4gIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcbiAgY3JlYXRlU2xpY2UsXG4gIGN1cnJlbnQyIGFzIGN1cnJlbnQsXG4gIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcbiAgZm9ybWF0UHJvZEVycm9yTWVzc2FnZSxcbiAgZnJlZXplLFxuICBpc0FjdGlvbkNyZWF0b3IsXG4gIGlzQWxsT2YsXG4gIGlzQW55T2YsXG4gIGlzQXN5bmNUaHVua0FjdGlvbixcbiAgaXNEcmFmdDQgYXMgaXNEcmFmdCxcbiAgaXNGU0EgYXMgaXNGbHV4U3RhbmRhcmRBY3Rpb24sXG4gIGlzRnVsZmlsbGVkLFxuICBpc0ltbXV0YWJsZURlZmF1bHQsXG4gIGlzUGVuZGluZyxcbiAgaXNQbGFpbixcbiAgaXNSZWplY3RlZCxcbiAgaXNSZWplY3RlZFdpdGhWYWx1ZSxcbiAgbHJ1TWVtb2l6ZSxcbiAgbWluaVNlcmlhbGl6ZUVycm9yLFxuICBuYW5vaWQsXG4gIG9yaWdpbmFsMiBhcyBvcmlnaW5hbCxcbiAgcHJlcGFyZUF1dG9CYXRjaGVkLFxuICByZW1vdmVMaXN0ZW5lcixcbiAgdW53cmFwUmVzdWx0LFxuICB3ZWFrTWFwTWVtb2l6ZTIgYXMgd2Vha01hcE1lbW9pemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWR1eC10b29sa2l0Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbInByb2R1Y2UiLCJjdXJyZW50IiwiY3VycmVudDIiLCJmcmVlemUiLCJvcmlnaW5hbCIsIm9yaWdpbmFsMiIsImlzRHJhZnQiLCJpc0RyYWZ0NCIsImNyZWF0ZVNlbGVjdG9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yIiwiY3JlYXRlU2VsZWN0b3JDcmVhdG9yMiIsImxydU1lbW9pemUiLCJ3ZWFrTWFwTWVtb2l6ZSIsIndlYWtNYXBNZW1vaXplMiIsImNyZWF0ZURyYWZ0U2FmZVNlbGVjdG9yQ3JlYXRvciIsImFyZ3MiLCJjcmVhdGVTZWxlY3RvcjIiLCJhcmdzMiIsInNlbGVjdG9yIiwid3JhcHBlZFNlbGVjdG9yIiwidmFsdWUiLCJyZXN0IiwiT2JqZWN0IiwiYXNzaWduIiwiY3JlYXRlRHJhZnRTYWZlU2VsZWN0b3IiLCJhcHBseU1pZGRsZXdhcmUiLCJjcmVhdGVTdG9yZSIsImNvbXBvc2UiLCJjb21wb3NlMiIsImNvbWJpbmVSZWR1Y2VycyIsImlzUGxhaW5PYmplY3QiLCJpc1BsYWluT2JqZWN0MiIsImNvbXBvc2VXaXRoRGV2VG9vbHMiLCJ3aW5kb3ciLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX18iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcHBseSIsImRldlRvb2xzRW5oYW5jZXIiLCJfX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fIiwibm9vcDMiLCJ0aHVuayIsInRodW5rTWlkZGxld2FyZSIsIndpdGhFeHRyYUFyZ3VtZW50IiwiaXNBY3Rpb24iLCJoYXNNYXRjaEZ1bmN0aW9uIiwidiIsIm1hdGNoIiwiY3JlYXRlQWN0aW9uIiwidHlwZSIsInByZXBhcmVBY3Rpb24iLCJhY3Rpb25DcmVhdG9yIiwicHJlcGFyZWQiLCJFcnJvciIsInByb2Nlc3MiLCJmb3JtYXRQcm9kRXJyb3JNZXNzYWdlIiwicGF5bG9hZCIsIm1ldGEiLCJlcnJvciIsInRvU3RyaW5nIiwiYWN0aW9uIiwiaXNBY3Rpb25DcmVhdG9yIiwiaXNGU0EiLCJrZXlzIiwiZXZlcnkiLCJpc1ZhbGlkS2V5Iiwia2V5IiwiaW5kZXhPZiIsImdldE1lc3NhZ2UiLCJzcGxpdFR5cGUiLCJzcGxpdCIsImFjdGlvbk5hbWUiLCJjcmVhdGVBY3Rpb25DcmVhdG9ySW52YXJpYW50TWlkZGxld2FyZSIsIm9wdGlvbnMiLCJuZXh0IiwiaXNBY3Rpb25DcmVhdG9yMiIsImNvbnNvbGUiLCJ3YXJuIiwiY3JlYXRlTmV4dFN0YXRlIiwiaXNEcmFmdGFibGUiLCJnZXRUaW1lTWVhc3VyZVV0aWxzIiwibWF4RGVsYXkiLCJmbk5hbWUiLCJlbGFwc2VkIiwibWVhc3VyZVRpbWUiLCJmbiIsInN0YXJ0ZWQiLCJEYXRlIiwibm93IiwiZmluaXNoZWQiLCJ3YXJuSWZFeGNlZWRlZCIsImZpbmQiLCJpdGVyYWJsZSIsImNvbXBhcmF0b3IiLCJlbnRyeSIsIlR1cGxlIiwiX1R1cGxlIiwiQXJyYXkiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJTeW1ib2wiLCJzcGVjaWVzIiwiY29uY2F0IiwiYXJyIiwicHJlcGVuZCIsImlzQXJyYXkiLCJmcmVlemVEcmFmdGFibGUiLCJ2YWwiLCJlbXBsYWNlIiwibWFwIiwiaGFuZGxlciIsImhhcyIsImdldCIsInVwZGF0ZSIsInNldCIsImluc2VydCIsImluc2VydGVkIiwiaXNJbW11dGFibGVEZWZhdWx0IiwiaXNGcm96ZW4iLCJ0cmFja0Zvck11dGF0aW9ucyIsImlzSW1tdXRhYmxlIiwiaWdub3JlUGF0aHMiLCJvYmoiLCJ0cmFja2VkUHJvcGVydGllcyIsInRyYWNrUHJvcGVydGllcyIsImRldGVjdE11dGF0aW9ucyIsInBhdGgiLCJjaGVja2VkT2JqZWN0cyIsIlNldCIsInRyYWNrZWQiLCJhZGQiLCJjaGlsZHJlbiIsImNoaWxkUGF0aCIsImlnbm9yZWRQYXRocyIsInRyYWNrZWRQcm9wZXJ0eSIsInNhbWVQYXJlbnRSZWYiLCJwcmV2T2JqIiwic2FtZVJlZiIsIk51bWJlciIsImlzTmFOIiwid2FzTXV0YXRlZCIsImtleXNUb0RldGVjdCIsImhhc0lnbm9yZWRQYXRocyIsIm5lc3RlZFBhdGgiLCJoYXNNYXRjaGVzIiwic29tZSIsImlnbm9yZWQiLCJSZWdFeHAiLCJ0ZXN0IiwicmVzdWx0IiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwic3RyaW5naWZ5MiIsInNlcmlhbGl6ZXIiLCJpbmRlbnQiLCJkZWN5Y2xlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJnZXRTZXJpYWxpemUyIiwic3RhY2siLCJfIiwic2xpY2UiLCJqb2luIiwidGhpc1BvcyIsInNwbGljZSIsInB1c2giLCJJbmZpbml0eSIsImNhbGwiLCJnZXRTZXJpYWxpemUiLCJ3YXJuQWZ0ZXIiLCJ0cmFjayIsImJpbmQiLCJnZXRTdGF0ZSIsInN0YXRlIiwidHJhY2tlciIsIm1lYXN1cmVVdGlscyIsImRpc3BhdGNoZWRBY3Rpb24iLCJpc0FjdGlvbjIiLCJpc1BsYWluIiwiZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNTZXJpYWxpemFibGUiLCJnZXRFbnRyaWVzIiwiY2FjaGUiLCJmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSIsImtleVBhdGgiLCJlbnRyaWVzIiwibmVzdGVkVmFsdWUiLCJpc05lc3RlZEZyb3plbiIsInZhbHVlcyIsImNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSIsImlnbm9yZWRBY3Rpb25zIiwiaWdub3JlZEFjdGlvblBhdGhzIiwiaWdub3JlU3RhdGUiLCJpZ25vcmVBY3Rpb25zIiwiZGlzYWJsZUNhY2hlIiwiV2Vha1NldCIsInN0b3JlQVBJIiwiZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSIsImZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSIsImlzQm9vbGVhbiIsIngiLCJidWlsZEdldERlZmF1bHRNaWRkbGV3YXJlIiwiZ2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJpbW11dGFibGVDaGVjayIsInNlcmlhbGl6YWJsZUNoZWNrIiwiYWN0aW9uQ3JlYXRvckNoZWNrIiwibWlkZGxld2FyZUFycmF5IiwiZXh0cmFBcmd1bWVudCIsImltbXV0YWJsZU9wdGlvbnMiLCJ1bnNoaWZ0Iiwic2VyaWFsaXphYmxlT3B0aW9ucyIsImFjdGlvbkNyZWF0b3JPcHRpb25zIiwiU0hPVUxEX0FVVE9CQVRDSCIsInByZXBhcmVBdXRvQmF0Y2hlZCIsImNyZWF0ZVF1ZXVlV2l0aFRpbWVyIiwidGltZW91dCIsIm5vdGlmeSIsInNldFRpbWVvdXQiLCJyQUYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhdXRvQmF0Y2hFbmhhbmNlciIsInN0b3JlIiwibm90aWZ5aW5nIiwic2hvdWxkTm90aWZ5QXRFbmRPZlRpY2siLCJub3RpZmljYXRpb25RdWV1ZWQiLCJsaXN0ZW5lcnMiLCJxdWV1ZUNhbGxiYWNrIiwicXVldWVNaWNyb3Rhc2siLCJxdWV1ZU5vdGlmaWNhdGlvbiIsIm5vdGlmeUxpc3RlbmVycyIsImZvckVhY2giLCJsIiwic3Vic2NyaWJlIiwibGlzdGVuZXIyIiwid3JhcHBlZExpc3RlbmVyIiwidW5zdWJzY3JpYmUiLCJkZWxldGUiLCJkaXNwYXRjaCIsImJ1aWxkR2V0RGVmYXVsdEVuaGFuY2VycyIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImdldERlZmF1bHRFbmhhbmNlcnMiLCJhdXRvQmF0Y2giLCJlbmhhbmNlckFycmF5IiwiSVNfUFJPRFVDVElPTiIsImNvbmZpZ3VyZVN0b3JlIiwicmVkdWNlciIsIm1pZGRsZXdhcmUiLCJkZXZUb29scyIsInByZWxvYWRlZFN0YXRlIiwiZW5oYW5jZXJzIiwicm9vdFJlZHVjZXIiLCJmaW5hbE1pZGRsZXdhcmUiLCJpdGVtIiwiZmluYWxDb21wb3NlIiwidHJhY2UiLCJzdG9yZUVuaGFuY2VycyIsImluY2x1ZGVzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZU5leHRTdGF0ZTIiLCJpc0RyYWZ0MiIsImlzRHJhZnRhYmxlMiIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImlzU3RhdGVGdW5jdGlvbiIsImNyZWF0ZVJlZHVjZXIiLCJpbml0aWFsU3RhdGUiLCJtYXBPckJ1aWxkZXJDYWxsYmFjayIsImZpbmFsQWN0aW9uTWF0Y2hlcnMiLCJmaW5hbERlZmF1bHRDYXNlUmVkdWNlciIsImdldEluaXRpYWxTdGF0ZSIsImZyb3plbkluaXRpYWxTdGF0ZSIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsInJlZHVjZXIyIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJkcmFmdCIsInVybEFscGhhYmV0IiwibmFub2lkIiwic2l6ZSIsImlkIiwiaSIsIk1hdGgiLCJyYW5kb20iLCJtYXRjaGVzIiwiaXNBbnlPZiIsIm1hdGNoZXJzIiwiaXNBbGxPZiIsImhhc0V4cGVjdGVkUmVxdWVzdE1ldGFkYXRhIiwidmFsaWRTdGF0dXMiLCJoYXNWYWxpZFJlcXVlc3RJZCIsInJlcXVlc3RJZCIsImhhc1ZhbGlkUmVxdWVzdFN0YXR1cyIsInJlcXVlc3RTdGF0dXMiLCJpc0FzeW5jVGh1bmtBcnJheSIsImEiLCJpc1BlbmRpbmciLCJhc3luY1RodW5rcyIsImFzeW5jVGh1bmsiLCJwZW5kaW5nIiwiY29tYmluZWRNYXRjaGVyIiwiaXNSZWplY3RlZCIsInJlamVjdGVkIiwiaXNSZWplY3RlZFdpdGhWYWx1ZSIsImhhc0ZsYWciLCJyZWplY3RlZFdpdGhWYWx1ZSIsImlzRnVsZmlsbGVkIiwiZnVsZmlsbGVkIiwiaXNBc3luY1RodW5rQWN0aW9uIiwiY29tbW9uUHJvcGVydGllcyIsIlJlamVjdFdpdGhWYWx1ZSIsIkZ1bGZpbGxXaXRoTWV0YSIsIm1pbmlTZXJpYWxpemVFcnJvciIsInNpbXBsZUVycm9yIiwicHJvcGVydHkiLCJtZXNzYWdlIiwiU3RyaW5nIiwiY3JlYXRlQXN5bmNUaHVuayIsImNyZWF0ZUFzeW5jVGh1bmsyIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwiYXJnIiwic2VyaWFsaXplRXJyb3IiLCJhYm9ydGVkIiwibmFtZSIsImNvbmRpdGlvbiIsImV4dHJhIiwiaWRHZW5lcmF0b3IiLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJhYm9ydFJlYXNvbiIsImFib3J0IiwicmVhc29uIiwicHJvbWlzZSIsImZpbmFsQWN0aW9uIiwiY29uZGl0aW9uUmVzdWx0IiwiaXNUaGVuYWJsZSIsInNpZ25hbCIsImFib3J0ZWRQcm9taXNlIiwiUHJvbWlzZSIsInJlamVjdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJnZXRQZW5kaW5nTWV0YSIsInJhY2UiLCJyZXNvbHZlIiwicmVqZWN0V2l0aFZhbHVlIiwiZnVsZmlsbFdpdGhWYWx1ZSIsInRoZW4iLCJlcnIiLCJza2lwRGlzcGF0Y2giLCJkaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiIsInVud3JhcCIsInVud3JhcFJlc3VsdCIsInNldHRsZWQiLCJ3aXRoVHlwZXMiLCJhc3luY1RodW5rU3ltYm9sIiwiZm9yIiwiYXN5bmNUaHVua0NyZWF0b3IiLCJSZWR1Y2VyVHlwZSIsIlJlZHVjZXJUeXBlMiIsImdldFR5cGUiLCJhY3Rpb25LZXkiLCJidWlsZENyZWF0ZVNsaWNlIiwiY3JlYXRvcnMiLCJjQVQiLCJjcmVhdGVTbGljZTIiLCJyZWR1Y2VyUGF0aCIsInJlZHVjZXJzIiwiYnVpbGRSZWR1Y2VyQ3JlYXRvcnMiLCJyZWR1Y2VyTmFtZXMiLCJjb250ZXh0Iiwic2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSIsImFjdGlvbkNyZWF0b3JzIiwic2xpY2VNYXRjaGVycyIsImNvbnRleHRNZXRob2RzIiwiZXhwb3NlQWN0aW9uIiwibmFtZTIiLCJleHBvc2VDYXNlUmVkdWNlciIsInJlZHVjZXJOYW1lIiwicmVkdWNlckRlZmluaXRpb24iLCJyZWR1Y2VyRGV0YWlscyIsImNyZWF0ZU5vdGF0aW9uIiwiaXNBc3luY1RodW5rU2xpY2VSZWR1Y2VyRGVmaW5pdGlvbiIsImhhbmRsZVRodW5rQ2FzZVJlZHVjZXJEZWZpbml0aW9uIiwiaGFuZGxlTm9ybWFsUmVkdWNlckRlZmluaXRpb24iLCJidWlsZFJlZHVjZXIiLCJleHRyYVJlZHVjZXJzIiwiZmluYWxDYXNlUmVkdWNlcnMiLCJzTSIsIm0iLCJzZWxlY3RTZWxmIiwiaW5qZWN0ZWRTZWxlY3RvckNhY2hlIiwiV2Vha01hcCIsIl9yZWR1Y2VyIiwiYWN0aW9ucyIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0b3JDYWNoZSIsInNlbGVjdG9ycyIsIndyYXBTZWxlY3RvciIsInNlbGVjdFNsaWNlIiwic2xpY2VTdGF0ZSIsImluamVjdEludG8iLCJpbmplY3RhYmxlIiwicGF0aE9wdCIsImNvbmZpZyIsInJlZHVjZXJQYXRoMiIsImluamVjdCIsImluamVjdGVkIiwid3JhcHBlciIsInJvb3RTdGF0ZSIsInVud3JhcHBlZCIsImNyZWF0ZVNsaWNlIiwiX3JlZHVjZXJEZWZpbml0aW9uVHlwZSIsInByZXBhcmVkUmVkdWNlciIsInByZXBhcmUiLCJtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSIsInByZXBhcmVDYWxsYmFjayIsImlzQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZURlZmluaXRpb24iLCJub29wIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiYWRkaXRpb25hbFN0YXRlIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsInNlbGVjdElkcyIsInNlbGVjdEVudGl0aWVzIiwic2VsZWN0QWxsIiwic2VsZWN0SWQiLCJzZWxlY3RCeUlkIiwic2VsZWN0VG90YWwiLCJzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMiLCJjcmVhdGVOZXh0U3RhdGUzIiwiaXNEcmFmdDMiLCJpc0RyYWZ0VHlwZWQiLCJjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IiLCJtdXRhdG9yIiwib3BlcmF0b3IiLCJjcmVhdGVTdGF0ZU9wZXJhdG9yIiwib3BlcmF0aW9uIiwiaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQiLCJhcmcyIiwicnVuTXV0YXRvciIsInNlbGVjdElkVmFsdWUiLCJlbnRpdHkiLCJlbnN1cmVFbnRpdGllc0FycmF5Iiwic3BsaXRBZGRlZFVwZGF0ZWRFbnRpdGllcyIsIm5ld0VudGl0aWVzIiwiYWRkZWQiLCJ1cGRhdGVkIiwiY2hhbmdlcyIsImNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyIiwiYWRkT25lTXV0YWJseSIsImFkZE1hbnlNdXRhYmx5Iiwic2V0T25lTXV0YWJseSIsInNldE1hbnlNdXRhYmx5Iiwic2V0QWxsTXV0YWJseSIsInJlbW92ZU9uZU11dGFibHkiLCJyZW1vdmVNYW55TXV0YWJseSIsImRpZE11dGF0ZSIsInJlbW92ZUFsbE11dGFibHkiLCJ0YWtlTmV3S2V5Iiwib3JpZ2luYWwzIiwibmV3S2V5IiwiaGFzTmV3S2V5IiwidXBkYXRlT25lTXV0YWJseSIsInVwZGF0ZU1hbnlNdXRhYmx5IiwidXBkYXRlcyIsIm5ld0tleXMiLCJ1cGRhdGVzUGVyRW50aXR5IiwiZGlkTXV0YXRlRW50aXRpZXMiLCJkaWRNdXRhdGVJZHMiLCJlIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldE9uZSIsInNldE1hbnkiLCJzZXRBbGwiLCJ1cGRhdGVPbmUiLCJ1cGRhdGVNYW55IiwidXBzZXJ0T25lIiwidXBzZXJ0TWFueSIsInJlbW92ZU9uZSIsInJlbW92ZU1hbnkiLCJjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIiLCJzb3J0IiwibW9kZWxzIiwibW9kZWwiLCJtZXJnZSIsImFwcGxpZWRVcGRhdGVzIiwibmV3SWQiLCJyZXNvcnRFbnRpdGllcyIsImFyZUFycmF5c0VxdWFsIiwiYiIsImFsbEVudGl0aWVzIiwibmV3U29ydGVkSWRzIiwiY3JlYXRlRW50aXR5QWRhcHRlciIsInNvcnRDb21wYXJlciIsImluc3RhbmNlIiwic3RhdGVGYWN0b3J5Iiwic2VsZWN0b3JzRmFjdG9yeSIsInN0YXRlQWRhcHRlciIsImlzQWN0aW9uMyIsImFzc2VydEZ1bmN0aW9uIiwiZnVuYyIsImV4cGVjdGVkIiwibm9vcDIiLCJjYXRjaFJlamVjdGlvbiIsIm9uRXJyb3IiLCJjYXRjaCIsImFkZEFib3J0U2lnbmFsTGlzdGVuZXIiLCJhYm9ydFNpZ25hbCIsImNhbGxiYWNrIiwib25jZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhYm9ydENvbnRyb2xsZXJXaXRoUmVhc29uIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ0YXNrIiwibGlzdGVuZXIiLCJjb21wbGV0ZWQiLCJjYW5jZWxsZWQiLCJ0YXNrQ2FuY2VsbGVkIiwidGFza0NvbXBsZXRlZCIsImxpc3RlbmVyQ2FuY2VsbGVkIiwibGlzdGVuZXJDb21wbGV0ZWQiLCJUYXNrQWJvcnRFcnJvciIsImNvZGUiLCJ2YWxpZGF0ZUFjdGl2ZSIsInJhY2VXaXRoU2lnbmFsIiwiY2xlYW51cCIsIm5vdGlmeVJlamVjdGlvbiIsImZpbmFsbHkiLCJydW5UYXNrIiwidGFzazIiLCJjbGVhblVwIiwic3RhdHVzIiwiY3JlYXRlUGF1c2UiLCJvdXRwdXQiLCJjcmVhdGVEZWxheSIsInBhdXNlIiwidGltZW91dE1zIiwiSU5URVJOQUxfTklMX1RPS0VOIiwiYWxtIiwiY3JlYXRlRm9yayIsInBhcmVudEFib3J0U2lnbmFsIiwicGFyZW50QmxvY2tpbmdQcm9taXNlcyIsImxpbmtDb250cm9sbGVycyIsImNvbnRyb2xsZXIiLCJ0YXNrRXhlY3V0b3IiLCJvcHRzIiwiY2hpbGRBYm9ydENvbnRyb2xsZXIiLCJyZXN1bHQyIiwiZGVsYXkiLCJhdXRvSm9pbiIsImNhbmNlbCIsImNyZWF0ZVRha2VQYXR0ZXJuIiwic3RhcnRMaXN0ZW5pbmciLCJ0YWtlIiwicHJlZGljYXRlIiwidHVwbGVQcm9taXNlIiwic3RvcExpc3RlbmluZyIsImVmZmVjdCIsImxpc3RlbmVyQXBpIiwiZ2V0T3JpZ2luYWxTdGF0ZSIsInByb21pc2VzIiwiZ2V0TGlzdGVuZXJFbnRyeVByb3BzRnJvbSIsImNyZWF0ZUxpc3RlbmVyRW50cnkiLCJjYW5jZWxBY3RpdmVMaXN0ZW5lcnMiLCJjcmVhdGVDbGVhckxpc3RlbmVyTWlkZGxld2FyZSIsImxpc3RlbmVyTWFwIiwiY2xlYXIiLCJzYWZlbHlOb3RpZnlFcnJvciIsImVycm9ySGFuZGxlciIsImVycm9yVG9Ob3RpZnkiLCJlcnJvckluZm8iLCJlcnJvckhhbmRsZXJFcnJvciIsImFkZExpc3RlbmVyIiwiY2xlYXJBbGxMaXN0ZW5lcnMiLCJyZW1vdmVMaXN0ZW5lciIsImRlZmF1bHRFcnJvckhhbmRsZXIiLCJjcmVhdGVMaXN0ZW5lck1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlT3B0aW9ucyIsIk1hcCIsImluc2VydEVudHJ5IiwiY2FuY2VsT3B0aW9ucyIsImNhbmNlbEFjdGl2ZSIsImZyb20iLCJleGlzdGluZ0VudHJ5IiwiZW50cnkyIiwibWF0Y2hQcmVkaWNhdGVPclR5cGUiLCJub3RpZnlMaXN0ZW5lciIsImFwaSIsImludGVybmFsVGFza0NvbnRyb2xsZXIiLCJhdXRvSm9pblByb21pc2VzIiwiQm9vbGVhbiIsImZvcmsiLCJ0aHJvd0lmQ2FuY2VsbGVkIiwibGlzdGVuZXJFcnJvciIsInJhaXNlZEJ5IiwiYWxsU2V0dGxlZCIsImNsZWFyTGlzdGVuZXJNaWRkbGV3YXJlIiwib3JpZ2luYWxTdGF0ZSIsImN1cnJlbnRTdGF0ZSIsImxpc3RlbmVyRW50cmllcyIsInJ1bkxpc3RlbmVyIiwicHJlZGljYXRlRXJyb3IiLCJjbGVhckxpc3RlbmVycyIsImNvbXBvc2UzIiwiY3JlYXRlTWlkZGxld2FyZUVudHJ5IiwiYXBwbGllZCIsIm1hdGNoSW5zdGFuY2UiLCJpbnN0YW5jZUlkIiwiY3JlYXRlRHluYW1pY01pZGRsZXdhcmUiLCJtaWRkbGV3YXJlTWFwIiwid2l0aE1pZGRsZXdhcmUiLCJtaWRkbGV3YXJlcyIsImFkZE1pZGRsZXdhcmUiLCJhZGRNaWRkbGV3YXJlMiIsIm1pZGRsZXdhcmUyIiwiZ2V0RmluYWxNaWRkbGV3YXJlIiwiYXBwbGllZE1pZGRsZXdhcmUiLCJpc1dpdGhNaWRkbGV3YXJlIiwiY29tYmluZVJlZHVjZXJzMiIsImlzU2xpY2VMaWtlIiwibWF5YmVTbGljZUxpa2UiLCJnZXRSZWR1Y2VycyIsInNsaWNlcyIsImZsYXRNYXAiLCJzbGljZU9yTWFwIiwiT1JJR0lOQUxfU1RBVEUiLCJpc1N0YXRlUHJveHkiLCJzdGF0ZVByb3h5TWFwIiwiY3JlYXRlU3RhdGVQcm94eSIsInJlZHVjZXJNYXAiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJyZWNlaXZlciIsIlJlZmxlY3QiLCJyZWR1Y2VyUmVzdWx0IiwiY29tYmluZVNsaWNlcyIsImZyb21FbnRyaWVzIiwiZ2V0UmVkdWNlciIsImNvbWJpbmVkUmVkdWNlciIsIndpdGhMYXp5TG9hZGVkU2xpY2VzIiwicmVkdWNlclRvSW5qZWN0IiwiY3VycmVudFJlZHVjZXIiLCJvdmVycmlkZUV4aXN0aW5nIiwibWFrZVNlbGVjdG9yIiwic2VsZWN0b3JGbiIsInNlbGVjdG9yMiIsImlzRmx1eFN0YW5kYXJkQWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs\n");

/***/ })

};
;